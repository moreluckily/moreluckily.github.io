{"meta":{"title":"Mr.Wang's blog","subtitle":null,"description":null,"author":"moreluckily","url":"http://moreluckily.com"},"pages":[{"title":"关于博主","date":"2018-09-19T04:46:53.000Z","updated":"2018-09-19T12:52:38.695Z","comments":true,"path":"about/index.html","permalink":"http://moreluckily.com/about/index.html","excerpt":"","text":"关于博主我是Mr.Wang，来自于江西省，景德镇市，在哈尔滨理工大学测通学院测控技术与仪器专业就读大四，在2018年9月19号，正式开始更新自己的blog。言归正传，其实做这个blog的主要目的是，记录自己的生活，分享自己平时学习生活中遇到的问题及经验，同时也当做一种复习。希望以后可以跟大家一起学习交流，共同成长。这就是blog存在的原因，希望能记录、分享我在生活中遇到的难题和我认为比较精彩的内容。包括技术类问题以及为人处事，也希望能帮助一些人解决他们遇到的难题，同时提高自己的表达和总结能力。生活中总是有些东西从别人口中说出来，自己都会觉得很容易，也就那么点东西，没什么值得骄傲，但其实知道一些东西不容易，讲给别人并使其听懂更不容易。 喜欢的句子 Cease to struggle and you cease to live.生命不止，奋斗不息。 You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.你不能改变你的过去，但你可以让你的未来变得更美好。一旦时间浪费了，生命就浪费了。 The harder you work, the luckier you will.越努力越幸运 有志者事竟成，破釜沉舟，百二秦关终属楚；苦心人天不负，卧薪尝胆，三千越甲可吞吴。 超级演说家命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，这个故事关于独立，关于梦想，关于勇气，关于坚忍。 人生那么短，我就选择做那种又盲目又热情的傻瓜。永远年轻；永远热泪盈眶；永远相信梦想；相信努力的意义；相信遗憾会比失败更可怕。因为不成功的人生，它只是不完美，但是它完整。 联系博主 博客：www.moreluckily.com 微信号：Wang13677983456 QQ:1328440709"},{"title":"分类","date":"2018-09-19T04:44:42.000Z","updated":"2018-09-19T04:45:42.669Z","comments":true,"path":"categories/index.html","permalink":"http://moreluckily.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-19T04:41:56.000Z","updated":"2018-09-19T04:43:56.893Z","comments":true,"path":"tags/index.html","permalink":"http://moreluckily.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js的对象","slug":"js的对象","date":"2018-09-25T05:29:35.000Z","updated":"2018-09-25T05:44:38.131Z","comments":true,"path":"2018/09/25/js的对象/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的对象/","excerpt":"","text":"","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的闭包","slug":"js的闭包","date":"2018-09-24T17:00:46.000Z","updated":"2018-09-25T05:46:58.358Z","comments":true,"path":"2018/09/25/js的闭包/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的闭包/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中闭包的相关知识。 闭包初探先来举个例子吧，让我们看看什么是闭包。 1234567891011121314function a()&#123; //AO = &#123; aaa:12 , b : function ()&#123;&#125;&#125; function b()&#123; //AO = &#123; bbb: 234&#125; var bbb = 234; console.log(aaa);//12 &#125; var aaa = 12; return b; &#125; a(); var glob = 100; var demo = a(); demo(); 函数里面还套了另一个函数，看起来特别难的样子。让我们先来分析一下。当b执行完之后，就相当于a也执行完了，这样a都会把自己的执行上下文销毁，但是这时候，因为return b，把b保存给了外部的变量demo，这时候当demo执行的时候，可以正常打印出12，具体原因就是，虽然a把自己的执行期上下文删掉，但是这时候b仍然保存有a的劳动成果，当它返回给外部变量的时候，就相当于外部变量也有这个执行期上下文，所以就能够访问到aaa了。这就是我们经常听说的内存泄漏，就是因为原有的作用域链不释放所导致的。具体来看下图。 当a执行完成之后，a scope chain [0] 中的指向将会被删除，但是因为b的指向仍然存在，所以仍能访问到所需要的变量。 举个例子吧。12345678910function a() &#123; var aaa = 123; function b() &#123; console.log(++aaa); &#125; return b;&#125;var demo = a();demo(); //124demo(); //125 当a函数定义的时候，产生一个执行上下文，里面有一个aaa，和一个函数b，当b定义的时候，已经含有a的劳动成果，意思就是它已经有a的执行上下文，并且在b执行的时候，产生它自己的执行上下文，最后当a函数执行完之后，把函数b返回到了全局作用域，虽然a执行完，并且销毁了它自己的执行上下文，但是因为其内部b函数的存在，仍然有a的全部执行上下文，所以，仍然可以通过demo来访问function a( ) { }里面的aaa变量。 闭包的作用实现公有变量实现公有变量的最经典的例子就是实现函数累加器的功能。举个例子： 1234567891011121314function add() &#123; var num = 0; function demo() &#123; num++; console.log(num); &#125; return demo;&#125;var add1 = add();add1();//1add1();//2add1();//3add1();//4add1();//5 我们可以利用闭包产生一个公有变量，对于上述例子，公有变量就是num。add函数，把demo函数返回到了外部，demo函数，仍然有add函数的执行上下文，所有每次执行test的时候，就相当于执行demo函数，并且每次访问的num都是同一个num变量，这样，我们就称num就是公有变量，通过这样的操作方式，就可以利用闭包产生一个累加器了。 做缓存机构首先来看一下下面的代码，我们来分析一下这段代码。 1234567891011121314151617function text() &#123; var num = 0; function a() &#123; console.log(++num); &#125; function b() &#123; console.log(--num); &#125; return [a,b];&#125;var arr = text();arr[0]();//1arr[1]();//0arr[0]();//1arr[0]();//2arr[0]();//3arr[1]();//2 这段代码把a函数和b函数都返回到了外部，这样a函数和b函数都与num产生了一个闭包，并且a和b执行的都是同一个变量，当a改变num的时候，b的num也会发生改变，同理，b操作了num，a的num也会发生改变，因为它们指向的num是同一个num，这样，就相当于一个缓存，每次都是操作之前操作过的同一个变量。 闭包还有一个作用就是可以实现封装，属性私有化。但我们还没有讲到对象，所以先放一下，之后再将这个功能。 立即执行函数立即执行函数的定义：此类函数没有声明，在一次执行过后即释放。适合做初始化工作。 首先来看一下它的写法和功能： 12345(function () &#123; &#125;)() // 写法(function () &#123; //在这里直接执行//执行完就被销毁了 &#125;)() 当然了，立即执行函数也可以传参数，例如： 1234var ret = (function (a,b)&#123; console.log(a + b); return [a,b]; &#125;(a,b)&#125; 立即执行函数的一些基本知识首先我们需要知道它一些基本知识：1、只有表达式才能被执行，2、表达式被执行了就会被销毁，3、函数声明不能被执行 12function test() &#123; &#125; // 函数声明，不是表达式var test = function () &#123;&#125; // 函数表达式 但我们可以利用一些简单的方法将函数声明转化为表达式 1+function test()&#123; &#125; //+号运算符，可以将函数声明转会表达式，这样就可以执行了。那-号也就肯定可以咯。 1! function test() &#123;&#125; //可以在函数声明前加一个!号，也是可以将声明转化为表达式。 1(function () &#123; &#125;) //()也能 但我们写立即执行函数的时候，需要遵循W3C标准，它规定的正确的写法就是下面这样的： 123(function () &#123;console.log(&apos;b&apos;);&#125;()) 举一个比较特殊的例子： 123function test(a,b)&#123; console.log(a,b);&#125;(1, 2); 这种写法是不会报错的，因为它传了参数，这样系统将会解析为这样的：123456function test()&#123; console.log(a,b); &#125; (1,2) 这样，系统认为它们是相互独立的两个部分，不会报错，这时JS引擎的容错机制。 1var text = (1,2); // text=2 是不是很神奇，和C，C++什么的区别的比较大啊。 利用立即执行函数解决闭包的问题我们首先来看一个经典的闭包产生的问题： 12345678910111213function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i ++)&#123; arr[i] = function () &#123; document.write(i + &quot;, &quot;); &#125; &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt; 10; j++)&#123; demo[j]();&#125;//打印10,10,10,10,10... ,10个10 这段代码最后打印出的是10个10，我们的目的是要让它打印出0到9，显然跟我们的目标有差距。为什么呢？ 首先解析一下为什么10个10，首先我们需要知道，function打印出的i并不是马上变限的，意思是，function要等到执行的时候才会去寻找i的值，这时候i的值已经是10了，因为i必须要等于10的时候才会停止循环。 其实循环可以这样理解： 1function () &#123; console.log(i),function () &#123; console.log(i),function () &#123; console.log(i),function () &#123; console.log(i),... 当数组执行完循环之后，i才是真正的打印结果，这时候，i就是10； 另外，打出10个10，就是我们的每一个i，用的都是同一个执行上下文的i，这时候我们需要利用立即执行函数来解决这个问题。 12345678910111213141516function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i ++)&#123; (function (k) &#123; //特别重要 // 相当于i=k=0.... arr[k] = function () &#123; console.log(k); &#125; &#125;(i)) //实参 &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt; 10; j++)&#123; demo[j]();&#125;//0~9 利用立即执行函数，每次访问的i都是不一样的值，这样就可以打印出0-9了。 再来看一个例子： 123456789101112131415161718192021222324a = 100;function demo(e) &#123; function e() &#123;&#125; arguments[0] = 2; document.write(e); //2 if(a)&#123; //if里不能有函数，有的话不报错，但不会在预编译的时候提出来 var b = 123;//if里有声明，预编译使可以提到前面 function c()&#123; //每个人都能做出来 &#125; &#125; var c; a = 10; var a; document.write(b); //undefined f = 123; //暗示全局变量。 //在GO上加f:123 document.write(c); //undefined document.write(a); //10&#125;var a;demo(1);document.write(a);//100document.write(f);//123 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中对象的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的预编译","slug":"js的预编译","date":"2018-09-24T16:30:32.000Z","updated":"2018-09-25T04:03:06.910Z","comments":true,"path":"2018/09/25/js的预编译/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的预编译/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中函数预编译的相关知识。 js运行三部曲首先一个JS程序能运行起来，需要经历三个步骤：第一步，语法分析，先通篇看一遍，看有没有低级语法错误，例如：有没有中文符号，多加了括号什么的。第二步，预编译。第三步，开始执行。 暗示全局变量imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。举一些例子：12a = 1;//a为暗示全局变量var a = b = 1;//b为暗示全局变量 任何地方的变量如果没有声明就赋值，就是全局变量。注意是！！任意的地方，这意味着如果在函数内部没用声明变量，就直接赋值，这个变量在全局都是被访问到。更进一步的意思就是，无论这个变量是否在局部作用域，它都能在全局作用域中被访问到。 在第二行代码中，由于赋值的过程是自右向左进行的，b其实是没有声明的，只有a是声明了的。 一切声明的全局变量，全是window的属性。例如:12a = 3;//window.a=3var a = b = 3;//window.a=3,window.b=3 预编译**预编译四部曲在预编译的时候，会发生下面的四步，我们把这个过程称为预编译四部曲。 1234567第一步：产生执行上下文的对象（activition object）简称AO ，它存在于系统内部。第二步：找形参和变量声明，直接提到函数顶部，将变量和形参名作为AO属性名，并赋值undefined。第三步：将形参和实参相统一。第四步：在函数体里面找函数声明，值赋予函数体。 这个其实是在函数内部发生的，那不是函数内部呢？那就是会创建GO，GO相对AO来说就比较简单了，没有形参。 12345第一步：产生执行上下文的对象简称GO ，它存在于系统内部。第二步：找变量声明，直接提到函数顶部，将变量名作为GO属性名，并赋值undefined。第三步：在非函数体里面找函数声明，值赋予函数体。 其实在GO上的属性就是window上的属性12window = GO = &#123;a: &#125;//a = window.a 还需要注意的一点常识就是，if语句里面不能有function。 举一些例子首先讲一个上节课的一个小例子： 12345var foo = 100 + &apos;200&apos;; //100200var foo = &apos;200&apos; + 100; //200100var foo = &apos;20&apos; * 10; //200var foo = &apos;20&apos; / 10; //2var foo = &apos;21&apos; % 10; //1 接下来就是重点了，我将会讲一些经典的预编译的例子。大家一起加油哦！ 12345678910111213function fn(a) &#123; console.log(a); //function a() &#123;&#125; var a = 123; console.log(a); //123 function a() &#123;&#125; console.log(a); //123 console.log(b); //undefined var b = function () &#123;&#125; console.log(b); //function () &#123;&#125; console.log(d); //function d() &#123;&#125; function d () &#123;&#125;&#125;fn(1); 下面我们来一起分析一下，这是一个函数，会产生AO。会发生预编译四部曲，我们接下来一起分析一下吧。 1234567891、创建AO对象2、找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined3、将实参值和形参统一4、在函数体里面找函数声明，值赋予函数体AO = &#123; a : undefined, --&gt; 1, --&gt;function a() &#123;&#125;, b : undefined, d : function d() &#123;&#125;&#125; 预编译结束，接着一步一步的进行里面的语句，于是就得到了上面程序的结果。 看到这里，可能大家有点懵，没关系，我们继续来讲下一个例子。 123456789101112131415161718function text(a,b) &#123; console.log(a); //1 console.log(c); //undefined c = 0; console.log(c); //0 var c; console.log(c); //0 a = 3; console.log(a); //3 console.log(b); //function b() &#123;&#125; b = 2; console.log(b); //2 function b() &#123;&#125; console.log(d); //function d() &#123;&#125; function d() &#123;&#125; console.log(b); //2&#125;text(1); 这是一个函数，会产生AO。会发生预编译四部曲，我们接下来一起分析一下吧。123456789101、创建AO对象2、找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined3、将实参值和形参统一4、在函数体里面找函数声明，值赋予函数体AO = &#123; a : undefined, --&gt; 1, b : undefined, --&gt; funtion b() &#123;&#125;, c : undefined, d : function d() &#123;&#125;&#125; 是不是明白了许多，接下来我要加入GO了，将GO和AO一起进行分析。请看下面的例子： 12345678var a = 100;function text () &#123; //AO = &#123;&#125; console.log(a); //100,AO里面没有的话会向上找GO里面的a。 a = 200; console.log(a); //把GO里的100改成了200，200&#125;text();console.log(a); //200，GO里的100已经改成了200 可能看的有点懵，我再来举一个相似的例子： 1234567891011121314a = 100;//GO = &#123;100&#125;function text() &#123; //AO = &#123;a : function a() &#123;&#125;&#125; console.log(a); //function a()&#123;&#125; a = 200; //AO = &#123;a : 200&#125;,但没有将GO中的a进行更改 function a()&#123;&#125; console.log(a); //200 var a; console.log(a); //200&#125;text();var a;console.log(a); //100 是不是觉得特别有意思呢？哈哈哈。 为了让大家理解的更深，我多举几个例子吧。 123456789101112131415function b() &#123; console.log(c); //undefined c = 0; //暗示全局变量，会在GO中产生 console.log(c); //0 console.log(a); //undefined a = 123; console.log(a);//123 var a = 324; console.log(a); //324&#125;b();var c;console.log(c);//0//解析：GO = &#123;c : undefined&#125;AO = &#123;a : undefined&#125; 是不是已经比较熟练的掌握了预编译。再来一个例子吧。 123456789101112text();var a;a = 324;function text() &#123; console.log(b);//undefined if(a) &#123; var b = 234; &#125; console.log(b);//undefined&#125;//预编译不看能不能执行，有声明就直接扯出来，在if里面的b就直接给提前了。//并将b赋值为undefined 但是在预编译的时候，也需要return,举个例子： 12345678function a() &#123; //AO = &#123;foo : function foo()&#123;&#125;&#125; return foo;//function foo()&#123;&#125;，直接就返回了 foo = 10; function foo() &#123;&#125; var foo =11;&#125;console.log(a()); 这就是预编译的整个过程。 作用域精讲首先，函数上面有一些东西是不提供操作的，其中有一个就是：scope属性，它存储的就是函数的真实的作用域，是函数执行期上下文的集合。 运行期上下文:当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。 作用域链：就是scope中所存储的执行期上下文的集合，这个集合成链式连接。就是作用域链。来个例子讲解一下： 1234567891011function a() &#123; function b() &#123; var b = 234; &#125; var a = 123; b();&#125;var glob = 100;a();//a定义：a.[ [ scope ] ] --&gt; scope chain ---&gt; 0:GO（全局作用域链）;如图一//a执行：a.[ [ scope ] ] --&gt; scope chain ---&gt; 0:aAO; 1：GO；如图二 图一：图二： 可以看到，当a定义的时候，已经拥有了GO，查找元素的时候，就是在scope里找，如果在自己的作用链就在自己的AO中索取，如果不存在，就从顶往下寻找。 当函数执行完之后，会销毁a中产生的执行期上下文，回归到a定义的时候。这也可以跟我们之前所说的，只能里面访问外面的，不能外面访问里面的一样，具体到理论上，就是外面的作用链，没有局部的作用域链，所以不能找到所需要的变量。 同样，我们在分析一下b，当b定义的时候，已经又有了a的劳动成果，就是a的作用域。如图三。 然后当b执行的时候，又产生了自己的作用域链。如图四。 图三：图四： 最后强调一下，当b执行完之后，意味着a也执行完了，意味着a和b的执行期上下文都被销毁，直接就恢复到a被定义的时候，只有全局的GO。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中闭包的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js函数相关","slug":"js函数相关","date":"2018-09-24T16:01:35.000Z","updated":"2018-09-24T16:50:27.937Z","comments":true,"path":"2018/09/25/js函数相关/","link":"","permalink":"http://moreluckily.com/2018/09/25/js函数相关/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中函数的相关知识。 函数先说一下为什么我们需要函数，请看下面这个例子： 123456789101112131415if(1 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(2 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(3 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125; 我们可以看到，打印出a 、b、c的语句重复了很多次，在编程里面称为耦合（重复），但是这是与编程原则所相违背的，编程要讲究高内聚，弱耦合，我们需要将它们都整合到一起，这时候就出现了函数了。 我们可以定义一个函数，当符合条件的时候就让这个函数执行，我们可以优化代码：1234567891011121314function test()&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(1 &gt; 0) &#123; test(); &#125;if(2 &gt; 0)&#123; test();&#125;if(3 &gt; 0)&#123; test();&#125; 这样，我们就是耦合程度大大降低了，这也是使用函数的一个重要目的。称之为：解耦合，把功能抽象出来，进行逻辑的处理之后，通过编写函数，达到把耦合程度降到最低。 函数的定义方式函数有最基本几个要素： 声明关键词：function， 函数名称， 参数（可选）。 函数的命名方式，是有规范的，如果多个单词进行拼接的时候，我们需要使用小驼峰式命名，即第一个单词小写，之后的每个单词首字母大写。例如: function theFirstName( ) { } 说完函数的命名方式之后，我们需要知道怎样对函数进行定义。 有两种方式： 1、函数声明方式，例如 ：function theFirstName(){} 2、函数表达式方式，例如 ：123var test = function demo() &#123; code &#125; , 函数表达式var test = function () &#123; code &#125; , 匿名函数表达式 (重点) 当我们在控制台调试的时候，我们可以发现第一种方法，利用test ，可以寻找到该函数，但是利用函数的名字demo，却会报错。第二种方法直接利用test就可以寻找到该函数，这表明了，函数表达式的demo这个名字，其实填写和不填写是一样的，因为在JavaScript内部，会将函数表达式最后都转化为 匿名函数表达式，所以我们统一采用匿名函数表达式，并称之为：函数表达式。 函数的参数12function test（a, b）&#123; code &#125;test(1,2); test后面跟着的一个括号就是用来填函数的参数的，这里写上一个a和b，就相当于在函数内部隐式的定义了两个变量a和b，参数不代表实际的值，相当于占位而已，必须是当你传入实际的值的时候，才会有特定的意义。所以我们称之为形式参数，简称形参，然后我们都通过传入1,2，这样就相当于给a赋值1，给b赋值2，这两个实际的值就称之为实际参数，简称实参。 JavaScript的参数机制很强大，它不限制位数，不限制类型。形参和实参都是天生的不定参，两者的长度没有规定相等，你可以形参定义100个，但是实参只传10个，或者形参定义两个，实参传200个都是没有问题的。这里又引出了一个概念：参数列表。 实参列表：arguments[1,2] ,实参列表就是用来存放实际参数的，就是我们传进去的参数，对于test来说，arguments有两位分别是1,2.第二个就是arguments是一个类数组，它有长度，无论形参怎么样，实参都会存储arguments中。 形参列表：test[a,b],实参列表，就是函数名字的类数组，里面存放的就是形参，对于test，里面就是a和b。 要注意的是，形参列表和实参列表之间有个映射关系，这个映射关系必须是两者长度一样的时候才会存在，当这个映射关系存在的时候，如果形参列表发生改变，那么实参列表也会跟着改变。例如： 1234567function func(a,b)&#123; a = 2; b = 3; console.log(argements[0]); //2 console.log(argements[1]); //3&#125;func(1,2); 可以看出，func传进的参数个数跟形参的个数长度是一样的，所以当a，b改变的时候，形参会发生改变。 12345function sum(a,b)&#123;b=2;console.log(arguments[1]);//undefined&#125;sum(1); 但是要注意的是，映射规则必须是要一一对应的时候才会有“你变我就变”，没有一一对应例如，形参个数不等于实参个数，都是没有映射规则的。 12345678function sum()&#123;var result = 0;for(var i = 0; i&lt;arguments.length;i++)&#123;result += arguments[i];&#125;console.log(result);//1+2+3+4+5+6=21&#125;sum(1,2,3,4,5,6); returnreturn是用来确定函数的返回值的，例如：12345function demo2 () &#123; return 222; &#125;var func = demo();console.log(func) //222 第二个作用就是，终止函数，即，当引擎解析到return语句的时候，那么该函数会马上停止执行，并返回出return后面的语句。 作用域作用域是一个很重要的概念，每一个函数代码块都是一个作用域，这里有一个全局作用域和局部作用域的概念。 全局作用域：除了function内部的都是全局作用域，所有在这个作用域声明的变量都是全局变量。 局部作用域：函数可以生成局部作用域，在函数内部声明的变量称之为局部变量。 全局作用域不能访问到局部作用域里面的变量，局部作用域里可以访问到全局作用域的变量。如果利用房子比作作用域的话，一个大房子就相当于一个全局作用域，每个大房子里面的小房子就相当于局部作用域，小房子可以随时开门去到大房子去寻找自身需要的东西，但是大房子没有小房子的钥匙，只能在自身的空间寻找自身需要的东西。这就是全局作用域和局部作用域的概念。 简单来说就是，外面的不能访问到里面的东西，里面的东西可以访问到外面的东西。来看一下这个例子。 123456789var a = 1;function test()&#123; a = 2; console.log(a) //2&#125;function test2()&#123; a = 3; console.log(a) //3&#125; 函数会产生作用域，而作用域产生的效果：里面的可以访问外面的,外面的不能访问到里面的，并列的不可以互相访问。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的预编译 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js类型转换","slug":"js类型转换","date":"2018-09-24T15:29:42.000Z","updated":"2018-09-24T15:31:55.526Z","comments":true,"path":"2018/09/24/js类型转换/","link":"","permalink":"http://moreluckily.com/2018/09/24/js类型转换/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript的类型转换的知识。 初识引用值首先先简单的介绍2种引用值，数组和对象。首先来说一下数组（array）吧，举个例子：1234var arr = [1,undefined,null,true,345]；document.write(arr[0]);//1arr[0] = 2;document.write(arr[0]);//2 能读能写，数组的长度可以用arr.length来表示。接下来说一下对象（object），属性有属性名和属性值组成，举个例子：1234567891011var mrDeng = &#123; name:&quot;XXX&quot;, age:33, lastName:&quot;xxx&quot;, wife : &#123; name:&quot;xxx&quot; &#125;, height:172, health:100&#125;document.write(mrDeng.name);//xxx 这两个今天就先讲到这里吧，后面还会比较详细的讲到。 编程形式的区别编程语言按照形式上分，有两类，第一种称之为面向过程，第二种称为面向对象。面向过程编程：主要是按照步奏来来进行编程，考虑是怎么做。典型例子为C语言。面向对象编程：包含面向过程编程，但是它主要考虑是处理方法，利用什么资源进行编程，更加的结构化。js即面向过程又面向对象。 typeof 运算符在我们处理数据的时候，经常需要关注数据的类型，这时候可以使用typeof运算符。 typeof（）运算符可以区分出数据的类型，他返回六种值，分别是object，number，string，undefined，boolean，function。返回的是形式都是字符串形式。它还有一个特点就是，当一个变量未经声明就使用时会报错的，但是利用typeof判断一个未经声明的变量，会返回undefined，但是不报错。了解了typeof之后，我们就可以正式介绍类型转换了。 举一些例子来看一下吧。12345var a = 123;typeof（a）;//出现numbervar a = NaNtypeof（a）;//出现number 这就很奇怪了，下面就一起来学习类型转换吧。 显式类型转换Number（）这个方法可以将传进去的参数转化为数字类型的数据，如果传进去的不能被转化为数字，就会返回NAN。 有个注意的地方就是，false,null，’’(空串)，会转化成0，undefined，NAN，都会转化为NaN。 举一些例子吧， 12345Number(&apos;asdfa&apos;) // NaNNumber(&apos;12333&apos;) // 12333Number(null) // 0Number(undefined) // NaNNumber(NaN) //0 parseInt()这个方法会将字符串转化为数字类型，并进行数字截断处理，当传入的是数字和字符串，它会把数字单独截取。第二个用法，就是它可以进行十进制数向其他进制数进行转化。举一些例子吧。123456var num = parseInt（xxx）;&quot;123&quot; //123undefined //NaN NaN //NaNvar num=parseInt(&quot;12a3&quot;);//12var num=parseInt(&quot;6&quot;,2)//将6转化为2进制, 110 parseFloat（）toFix（）parseFloat（）这个方法也是将参数转化为数字类型，但是它不可以进行进制的转换。var num=parseFloat(&quot;10.123&quot;) //10.123 toFix（）可以设定保留多少为有效数字.var a = 199.223; a.toFixed(2); //199.23 string()string():这个方法就是将传进的参数转化为字符串类型的数据。这个没什么好说的。 Boolean()boolean():这个方法就是将传进的参数转化为true，或者是false，只有那6个值为false。undefined,null,NaN,””,false,0。 toString()这个方法很重要，首先它可以将调用它的变量转化字符串，第二个就是它可以将调用它的变量转化为十进制。另外可以利用它来判断object和array。这个之后可以跟大家在介绍，今天就不展开了。 12var str = 123;var num = str.toString(2);//string类型,将10进制转化为2进制。 1234将2进制转化为8进制：var num=parseInt(&quot;1000&quot;,2);document.write(num.toString(8));先转化成2进制，再转化为8进制。 隐式类型转化isNaN（）NaN是一个很特殊的东西，它“六亲不认”，它任何东西都不等于，包括它自己。12NaN == NaN //falseNaN === NaN //false isNaN（）就是用来判断NaN的。它可以将传入的参数判断是否为NaN。 12isNaN(NaN) //trueisNaN(0) //false 其他的隐式类型转化一元正负运算符:12var a = &quot;1234&quot;;var b = a + 1; // 12341 当使用+ 号进行字符串和数字类型进行操作的时候，+号两边，会有一个隐式类型转换，就是将数字调用string，然后进行拼接。 还有就是++运算符，例如：123var a = &quot;123&quot;;//Number(a) ++document.write(a++ + &quot;:&quot; + typeof(a));//123:Number 会先把a转化为数字类型,在进行其他的计算。 “- * / %” 转化成number,&amp;&amp; || !转化成布尔值。&gt; &lt; &lt;= &gt;=在一侧是数字时转化成number。 1234underfined == 0 //falsenull == 0 //falsenull == underfined //true(特殊规定)``` var a = “10” &gt; “9”;document.write(a);//输出false(字符串会比较ASCII码)12还有：===绝对等于和 !==绝对不等于不会发生类型转换，只有2侧一致才返回true。 var a = 0 == “”; //truevar a = 0 === “”; //false12 var a=(“11”*3 + “2”)/2 //166, 33+”2” 等于”332”`好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的函数 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的运算符及语句","slug":"js的运算符及语句","date":"2018-09-23T16:12:47.000Z","updated":"2018-09-24T15:31:57.186Z","comments":true,"path":"2018/09/24/js的运算符及语句/","link":"","permalink":"http://moreluckily.com/2018/09/24/js的运算符及语句/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript的运算符和JavaScript的一些基本语句。 JS的运算符运算符首先运算符分为：算数运算符，比较运算符以及逻辑运算符。 “+和-”运算符“+”和“-”运算符其实是一样的规则的，在这里我只介绍“+”运算符，他和”-“运算符是一样的，就不花大量的时间去介绍了。 在这里比较重要的两点：数学运算、字符串链接，而且任何数据类型加字符串都等于字符串。 下面举一些例子来说明这些问题： 12var a = &apos;a&apos; + 1 + 1 ; //得到: a = &apos;a11&apos;var a = 1 + 1 + &apos;a&apos; + 1;//得到: a = &apos;2a1&apos; 这里就需要注意运算时的优先级了。优先级”=“最弱，”()”优先级较高。而且运算时是从左向右运算的，和生活中的数学计算还是有一定的差别的。这里需要注意一下。 再来看一下这些例子： 12345var a = 1;var b = a++; //2var c = ++a; //3console.log(a++);//3console.log(++a);//5 由以上的例子我们可以知道，a++和++a是有区别的，a++是先进行该语句，再进行a+1，++a是先进行a+1，再进行该语句。 “/和%”运算符“/”就是数学中的除法，这个没什么特别的作用，“%”是取余的意思。举个例子吧。 12var a = 10 / 3;//3.3333333333333335var b = 10 % 3;//1 通过这个例子我们也能知道数字在浏览器中只能取小数点后的17位，而且第17位是不准确的。 在来看下面的例子： 12345678var a = 1.0000000000000001;var b = 1.0000000000000001;//小数点后16位var c = a + b;var d = 1.000000000000001;var e = 1.000000000000001;//小数点后15位var f = d + e;console.log(c);//2console.log(f);//2.000000000000002 从这里我们可以知道，浏览器只能计算小数点后15位的数据。 比较运算符比较运算符有“&gt;”，”&lt;”，”==”，“&gt;=”，“&lt;=”，”!=”等等，两个值的比较结果为boolean值，即只有true和false这两种结果，而且需要注意的是：比较运算符如果存在跟算术运算符一起出现的时候，先计算算术运算符部分，即算数运算符的优先级是要高于比较运算符的。 OK，接下来就举一些例子来对其进行说明： 12var a = 1 + 2 &gt; 2 + 2;//falsevar a = 3 &gt; 2 &gt; 1;//false 第一个，首先进行加减运算，即两边得到：3&gt;4，答案肯定是false。第二个，首先进行3&gt;2，答案是true，这里会发生一个隐式类型转换，即会将true转换为1，1&gt;1，答案当然是false。 逻辑运算符*首先要说的就是运算时，会发生隐式类型转换，有6个值会转换为false，其他的都是true。这个是必须要记住的。 underfined NAN null 0 “”（空串） false。这6个值会转换成false,然后再去进行计算。 &amp;&amp; 运算符这是我们常说的与运算符。先不说它的特点。那接下来举一些例子吧：1234var a = 1 &amp;&amp; 2;//2var a = 0 &amp;&amp; 2;//0var a = 3 &amp;&amp; 2 &amp;&amp; 1;//1var a = 1 + 2 &amp;&amp; 2 + 3;//5 &amp;&amp;运算符就是当前面的出现false时，就不看后面的结果，直接将0返回。当前面不为0时，就将后面的值返回，当也要注意的是：加减的优先级任然是高于逻辑运算符的。比较常见的应用就是短路语句了，举个例子：12var data;data &amp;&amp; fn(data);//data有数据才执行后面的函数 | | 运算符或运算符，||当前面为true,就返回前面的东西，||当前面为false,再看后面的东西。举一些例子来看一下：12var a = 1 || 2;//1var a = 0 || NaN || undefined;//undefined ! 运算符非运算符，就是取反的意思。这个没什么介绍的。 JS语句if( )语句如果if( )语句里面的判断是正确的话，那么就会走接下来的代码块，否则就跳过if语句。例如：123if(a)&#123; console.log(a); &#125; if( ) else 语句看例子： 1234567if(a)&#123;console.log(a)&#125;else&#123;var a = 5 ;console.log(a);&#125; 如果，a不为0就会打印出a，否则就进行else里的语句。 else if( )语句看例子:123456if(date is monday）&#123;console.log(&apos;monday&apos;)&#125;else if(date is tuesday)&#123;console.log(tuesday)&#125;else&#123;&#125; for循环语句这个是最常见的语句之一，看例子：123for(var i = 0; i &lt;= 10; i++;)&#123;console.log(i + &apos;,&apos;);&#125; //0,1,2....10 这个也比较好理解，我就不多说了。 while 循环语句这个语句跟for循环是差不多的，但是我们有时候可以利用它来进行递归，这样效率更高（少些几行而已）while（）括号里面直接填写的是判断条件，代码块写的就是执行语句。但是我们要注意，如果填入的是一个一直成立的表达式，那么它就可能会一直死循环下去。never-ending loop 无限死循环。 switch 语句这个语句相信大家都很熟悉吧，我先来举个例子：1234567891011var date = window.prompt(&apos;input&apos;);switch(date)&#123; case &quot;monday&quot;： doucment.write(&apos;working&apos;); case &quot;tuesday&quot;: document.write(&apos;working&apos;); case &quot;wendesday&apos;: document.write(&apos;working&apos;); case &quot;sunday&quot;: document.write(&apos;resting&apos;); &#125; 当输入monday，会出现working，working，working，resting。就需要优化：123456789101112var date = window.prompt(&apos;input&apos;);switch(date)&#123; case &quot;monday&quot; : case &quot;tuesday&quot; : case &quot;wendesday&quot; : document.write(&apos;working&apos;); break; case &quot;sunday&quot; : document.write(&apos;resting&apos;); break; defalut :document.write(&apos;nice!&apos;)//其他的情况；&#125; break停止的是里面的一个循环。外面的循环正常进行。（停止循环就用break），continue结束本次循环，继续进行下一次循环。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的类型转换，谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"javaScript的历史","slug":"javaScript的历史","date":"2018-09-22T17:02:44.000Z","updated":"2018-09-23T15:45:21.913Z","comments":true,"path":"2018/09/23/javaScript的历史/","link":"","permalink":"http://moreluckily.com/2018/09/23/javaScript的历史/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。 前面的html和css忘了一些不要紧，我们需要好好学习javaScript，因为前端工程师也可以叫做JS工程师，也就是说JS是前端最重要的，大家一起加油吧！ JS的发展史首先我要说一下javaScript的简称是js，而且js和java没有任何的关系，它俩是两个东西。现在介绍一下js的发展史吧！1994年4月，马克.安德森和Silicon Graphics（简称为SGI，中译为“视算科技”或“硅图”）公司的创始人吉姆·克拉克（Jim Clark）在美国加州设立了“Mosaic Communication Corporation”。Mosaic公司成立后，由于伊利诺伊大学拥有Mosaic的商标权，且伊利诺伊大学已将技术转让给Spy Glass公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为Netscape Navigator，公司名字于1994年11月改名为“Netscape Communication Corporation”，此后沿用至今，中译为“网景”。微软的Internet Explorer及Mozilla Firefox等，其早期版本皆以Mosaic为基础而开发。微软随后买下Spy Glass公司的技术开发出Internet Explorer浏览器，而Mozilla Firefox则是网景通讯家开放源代码后所衍生出的版本。 JavaScript作为Netscape Navigator浏览器的一部分首次出现在1996年。它最初的设计目标是改善网页的用户体验。初期JavaScript被命名为，LiveScript，后因和Sun公司合作，因市场宣传需要改名JavaScript。后来Sun公司被Oracle收购，JavaScript版权归Oracle所有。 浏览器组成浏览器分为shell部分和内核部分。内核部分又有渲染引擎（语法规则和渲染），和Js引擎以及其他模块。最出名的就是谷歌公司chrome的js引擎，就是著名的v8引擎。它的特点就是可以直接把js编译为机器码，所以这速度是最快的，后来许多浏览器也有了自己的js引擎。 js引擎的发展： 2001年发布ie6，首次实现对js引擎的优化。2008年Google发布最新浏览器Chrome，它是采用优化后的javascript引擎，引擎代号V8，因能把js代码直接转化为机械码来执行，进而以速度快而闻名。后Firefox也推出了具备强大功能的js引擎Firefox3.5 TraceMonkey（对频繁执行的代码做了路径优化）Firefox4.0 JeagerMonkey 同步和异步同步就是，同一时间只能干一件事情。异步就是，同一时间可以干多件事情。 单线程，同一时间，只能干一件事情。 多线程，同一时间，能干多个事情。 js的特点解释型语言计算机语言可以分为两种，第一种称为编译性语言，第二种称为解释性语言。 编译性语言：通篇翻译完，再执行一遍，然后生成一个编译文件，执行的是编译文件，优点是：比较快，缺点：跨平台差。典型的例子：C，C++等 解释型语言：翻译一行，执行一行，缺点就是：速度慢，优点是：可以跨平台。典型代表：PHP，Python，js。 注意比较常见的一种语言：Java，它属于两者之间，既不是编译型语言，也不是解释型语言。通过javac弄成.class文件，有兴趣的可以去百度一下。 js就是单线程的，同一时间只能干一件事。但我们可以让它看起来像多线程一样。举个例子，就像我们吃饭一样，吃一口饭，再吃一口菜，吃完之后，我们将这段时间快进快进，现在看碗里的饭和盘里的菜。我们可以看见饭和菜是同时慢慢减少的。这就是js的执行队列。 ECMA标注 — 为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格JavaScript兼容于ECMA标准，因此也称为ECMAScript。 开始学习JSJS分为三大部分，ECMAScript ， DOM，BOM。前两个最重要，ECMAScript是基础，DOM可以操作html和CSS。而BOM可以操作浏览器，那这样的话就权限太大了，在开发中是不允许。 JS的引入JS的引入方式和CSS类似，首先介绍第一种方式，就是页面级js，在head或者body中加入：&lt;script&gt;js的内容&lt;/sxript&gt;第二种方式就是外部js形式，一般在head标签里加：&lt;script src=&quot;lesson1.js&quot;&gt;&lt;/script&gt;为符合web的开发标准：结构html、样式css、行为js相分离，通常采用外部引入。 有一点需要注意的就是：JS文件加载的时候，它会把所有内容都阻塞了，所有东西都不能够进行操作，必须要等到JS加载完才能进行操作。所以我们最后一般将script标签放在body标签的底部。避免js文件阻塞html和CSS的运行。 js的基本语法JS中的变量（variable）一个变量，肯定首先需要对这个变量进行声明。var a;然后对变量进行赋值：123var a;a = 1;var a = 1; 前两句的效果和第三句的效果是一模一样的。当声明多个变量时，可以这样来写：12345var a,a,b,c,d;var a,//一般都这样来写 b, c, d; 变量的命名规则1、变量名必须以英文字母、_、$ 开头 2、变量名可以包括英文字母、_、$、数字 3、不可以用系统的关键字、保留字作为变量名 那js中有哪些关键字和保留字呢？看下面这张图： 这些我们并不需要去背。 js的基本语法数据类型数据的类型分为两大类，原始值和引用值。 原始值（栈数据） Number，数字类型。例如：1,2,3… String，字符串类型。例如：”123”,’123’。要用单引号或双引号包裹起来 Boolean，布尔类型，只有:true,false。 Undefined，未定义，只有一个，它自己本身undefined Null，空，也只有一个，null 引用值（堆数据）前期先介绍三类： Array，数组。例如：[1,2,3] Object，对象。例如：{name : “wang”,age : 20 } Function，函数，例如：function () {} 栈数据和对数据的区别栈（stack）数据，类似一个框，只有一个口。先进后出。first in last out。堆（heap）数据，指向的是堆的地址。 那我们来分析一下下面代码的情况： 12var a = 1;a = 2; 首先，js向系统索取了一个地址，假设为1000，来放a这个变量，然后赋值为1。然后当我们修改这个变量的时候，原来的1000地址的名字将不再为a，但是它的数据仍然存在。这个时候系统将另外取一个地址，假设为1001，这个地址将会命名为a，并且，值为2。它并不是真正意义上的删除，而是将原来的地址名字删掉，并重新赋值一个新地址而已。 js语法句的基本规则1、语句后面要用分号结束“；” 2、js语法错误会引发后续代码终止，但不会影响其它js代码块 3、书写格式要规范，“= + / -”两边都应该有空格 好了，今天的这篇blog就到这里结束了，谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"制作百度主页","slug":"制作百度主页","date":"2018-09-22T16:01:06.000Z","updated":"2018-09-22T15:50:26.150Z","comments":true,"path":"2018/09/23/制作百度主页/","link":"","permalink":"http://moreluckily.com/2018/09/23/制作百度主页/","excerpt":"","text":"新的blog，新的开始。今天我将带着大家一起制作百度主页。 百度主页的制作首先是html的框架：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;div class=&quot;navSection&quot;&gt; &lt;ul&gt; &lt;li class=&quot;more&quot;&gt; &lt;a href=&quot;#&quot;&gt;更多产品&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;light&quot;&gt; &lt;a href=&quot;#&quot;&gt;设置&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;light&quot;&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;视屏&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;地图&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;hao123&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;糯米&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;searchSection&quot;&gt; &lt;div class=&quot;logoSection&quot;&gt; &lt;img src=&quot;./src/img/bd.png&quot; alt=&quot;baidu&quot;&gt; &lt;/div&gt; &lt;div class=&quot;keywordSection&quot;&gt; &lt;form action=&quot;/&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;inputSection&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottonSection&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;infoSection&quot;&gt; &lt;div class=&quot;codeSection&quot;&gt; &lt;img src=&quot;./src/img/code.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;手机百度&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;messageSection&quot;&gt; &lt;p class=&quot;topP&quot;&gt; &lt;a href=&quot;#&quot;&gt;把百度设为主页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;关于百度&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;About Baidu&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百度推广&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;bottomP&quot;&gt; &lt;a href=&quot;#&quot;&gt; ©2017 Baidu 使用百度前必读 意见反馈 京ICP证030173号 &lt;/a&gt; &lt;span class=&quot;icon1&quot;&gt;&lt;/span&gt; &lt;a href=&quot;#&quot;&gt; 京公网安备11000002000001号 &lt;/a&gt; &lt;span class=&quot;icon2&quot;&gt;&lt;/span&gt; 然后就是css的内容来修饰这个框架了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151*&#123; margin: 0px; padding: 0px; list-style: none; font-family: arial;&#125;/* 导航区域css */ .navSection&#123; height: 60px;&#125;.navSection ul::after&#123; content: &quot;&quot;; display: block; clear: both;&#125;.navSection ul li&#123; height: 60px; line-height: 60px; float: right; margin-right: 15px;&#125;.navSection ul li a&#123; color: #333; font-size: 13px; font-weight: bold; /* text-decoration:none; */&#125;.navSection ul .light a&#123; font-weight: normal;&#125;.navSection ul .more &#123; margin-right: 30px;&#125;.navSection ul .more a&#123; color: #fff; background-color: #38f; padding: 6px 4px; text-decoration: none; font-weight: normal;&#125;/* 搜索区域css */.searchSection&#123; margin-top: 40px; text-align: center;&#125;.searchSection .logoSection &#123; /* text-align: center; */ margin-bottom: 20px;&#125;.searchSection .logoSection img&#123; width: 270px; height: 129px;&#125;.searchSection form div&#123; display: inline-block;&#125;.searchSection form .inputSection&#123; vertical-align: top; position: relative;&#125;.searchSection form .inputSection input&#123; width: 539px; height: 34px; padding-left: 15px;&#125;.searchSection form .inputSection span&#123; position: absolute; right: 10px; top: 50%; width: 18px; height: 16px; margin-top: -8px; background-image: url(../img/camera.png); background-position: 0px 0px; cursor: pointer;&#125;.searchSection form .inputSection span:hover &#123; background-position: 0px -20px;&#125;.searchSection form .bottonSection&#123; margin-left: -5px;&#125;.searchSection form .bottonSection input&#123; width: 100px; height: 38px; background-color: #3385ff; border: none; color: #fff; font-size: 15px;&#125;/* 信息展示区 */.infoSection &#123; text-align: center; margin-top: 270px;&#125;.infoSection .codeSection span &#123; display: block; font-size: 12px; font-weight: bold; color: #666;&#125;.infoSection .codeSection &#123; margin-bottom: 30px;&#125;.infoSection .messageSection p a&#123; color: #999; margin-right: 20px;&#125;.infoSection .messageSection .topP &#123; margin-bottom: 10px;&#125;.infoSection .messageSection .bottomP span &#123; display: inline-block; width: 14px; height: 17px; margin-left: -20px; margin-right: 20px; background-image: url(&apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/global/img/icons_5859e57.png&apos;);&#125;.infoSection .messageSection .bottomP .icon1 &#123; background-position: -600px -96px;&#125;.infoSection .messageSection .bottomP .icon2 &#123; background-position: -623px -96px;&#125; 这样一个百度主页就完成了，我们来看一下效果吧！ 看到这个效果，是不是特别开心和自豪呢？ 好了，今天到这就把前端的html和css告一段落，下篇blog将继续和大家一起学习javaScript，大家和我一起加油吧。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css -html","slug":"css-html","permalink":"http://moreluckily.com/tags/css-html/"}]},{"title":"css学习5","slug":"css学习5","date":"2018-09-22T14:07:33.000Z","updated":"2018-09-22T15:30:48.753Z","comments":true,"path":"2018/09/22/css学习5/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习5/","excerpt":"","text":"从小到大我们都在听着别人的声音给自己的人生划格子，左边的这条线是要学业有成，右边的这条线是一定要有一个安稳的好工作，上面的这条线是三十岁之前要结婚，下面的这条线就是你结了婚一定得生个孩子，好像只有在这个格子里面才是安全的，才被别人认为是幸福的。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 溢出打点溢出打点是什么？ 一上来我们肯定会有这样的问题。其实在百度的网页中，这是特别常见的。我们先来看一下： 在文字的结尾处，我们发现内容并没有显示的特别完整，文字的最后是以“…”的形式结束的，这个效果是怎么实现的呢？ 首先是单行打点的情况：在标签中，当文字快溢出容器的时候，它们是会自动换行的。但是一旦换行，我们就不会有那种打点的效果了。这时候，有一个属性： white-space:nowrap; 它会使文字失去换行的本领。 这时候，文字就不会自动换行了，但是又要怎样才能让它出现“…”的形式呢？这时候又有一个属性： txet-overflow:ellipsis; 这就是文字溢出之后是ellipsis（省略），也就得到了文字溢出打点的效果。 最后当然也需要将溢出的文字隐藏起来，这就实现了文字溢出打点的效果了。 这三个东西配合，也就是三件套配合，会得到溢出打点的效果。举个例子来看一下吧。 1234567891011&lt;div&gt;有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。&lt;/div&gt;div&#123; width:200px; height:60px; border:1px solid black; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; &#125; 它的效果特别明显了，如下图所示： 可以看到，文字省略的部分已经用了“…”来代替了。 这个是单行打点，如果是多行文字打点呢？鉴于兼容性，多行文字我们一般不做打点处理，一般做多行文字截断处理。 而且在百度中常见的多行文字打点是什么情况呢？我们检查一下里面的情况，我们可以发现如下情况： 通过该图片我们可以发现，直接用的就是“…”的形式，即没有用技术的手段是实现索航文字打点技术。 背景图片当引用一张图片的时候，这些图片就是当做背景图片来进行设定的。 首先我们来了解一下背景图片的几个属性 1234567background-image:url(adress);//图片地址background-repeat:no-repeat;//图片不重复,不允许平铺background-repeat:repeat-x;//图片向x轴平铺background-repeat:repeat-y;//图片向y轴平铺background-size:100px 100px;//图片大小background-position:50% 50%;//图片位置,放在正中间 background-position:center center;//图片位置,放在正中间 先说一下 background-repeat，如我们不设定这个属性，当引入一张图片的时候，如果图片大小不等于容器大小的话，它们会自动重复，直到铺满容器。 第二再说一下background-position,这里的50%直接就是居中到容器中心，不需要在调整margin。还可以设定left center表示左边居中，当然还有bottom值来进行设定，可以灵活运用进行图片的定位。当background-size设定为100%的时候，就是直接铺满整个容器。 background引入图片的时候，存在网络不好，这时候就只加载html，不加载css和javaScript，图片显示不出来的时候，我们需要想利用img标签那样给它添加文字，怎样做呢？这里有2中方法去实现。 1、第一种方法，先让文字溢出，然后强制不换行 1234567891011121314&lt;a href=&quot;#&quot;&gt;淘宝&lt;/a&gt;a&#123;display:block;text-decoration:none;width:142px;height:58px;border:1px solid balck;background-image:url(address); background-repeat:no-repeat;background-size:100% 100%; text-indent:150px;//缩进大于容器宽度 让文字出去 white-space:nowrap;//不换行overflow:hidden;&#125; 2、这个是重点，比较常用。利用padding来显示背景图。当css加载不出来的时候，显示文字。 12345678910111213&lt;a href=&quot;#&quot;&gt;淘宝&lt;/a&gt;a&#123;display:block;text-decoration:none;width:142px;height:0px;border:1px solid balck;background-image:url(address);back-repeat:no-repeat;background-size:100% 100%; overflow:hidden;//文字溢出隐藏padding-top:100px;//利用padding来放背景图。&#125; 比较常用的实战方法 inline-block元素或者block元素可以嵌套任何元素 行级元素可以嵌套行级元素 p标签里不能放块级元素 a标签里不能放a标签 父子关系别写太多，4层5层就行了，写多了就浪费效率 float浮动模型实战上一篇blog由于篇幅的影响，今天再来对其进行实战。来实现显示淘宝的标价和多少人付款。 123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;span class=&quot;price&quot;&gt;$1000&lt;/span&gt; &lt;span class=&quot;offer&quot;&gt;20人付款&lt;/span&gt;&lt;/div&gt; *&#123; margin:0; padding:0; font-family: arial;&#125;div&#123; width: 200px; border:1px solid black; *zoom:1;&#125;div::after&#123; content: &quot;&quot;; display:block; clear:both;&#125;.price&#123; float:left; color:#f40; font-weight: bold;&#125;.offer&#123; float:right; font-size: 12px; color:#999; margin-top: 2px;//可以调节&#125; 实现的效果图如下图所示： 通过这个例子，你是不是对其理解的更加深刻呢？是不是觉得WEB前端特别有意思。 好了，今天到这就把前端的基础和css讲完了，下篇blog将带着大家把百度的主页做出来，当然我们也可以做淘宝的静态主页了。淘宝的静态主页就不在blog中放出来了，大家可以加我微信一起交流，谢谢大家！","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习4","slug":"css学习4","date":"2018-09-22T13:01:39.000Z","updated":"2018-09-22T14:10:48.286Z","comments":true,"path":"2018/09/22/css学习4/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习4/","excerpt":"","text":"这个世界那么大、那么精彩，你什么都还没有看到过的时候就甘心的呆在一个格子里面，循规蹈矩安分守己地生活，这样的生活没有任何的风险，也不会被别人嘲笑，但是我总觉得一个没有把百酒都尝遍的人他是不大懂得清水之味的。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 两栏布局*这是一个经常考的一个问题，两栏布局问题也是一个特别重要的问题之一，它的题目是右侧固定，左侧自适应。也就是无论浏览怎么拉伸和收缩，右侧的一部分内容不会发生变化，而左侧的那部分内容进行自适应。123456789101112131415161718192021222324&lt;div class=&quot;left&quot;&gt;举个例子举个例子举 个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例子举个 例子举个例子举个例子&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;//写这么多字，让我们看起来更加的直观。*&#123; margin:0; padding:0;&#125;.left&#123; margin-right: 100px; (重点) height: 100px; background-color: green;&#125;.right&#123; position: absolute; top:0; right:0; width: 100px; height: 100px; background-color: red; opacity: 0.5;&#125; 会得到如下图所示的图形，由此我们知道，改变浏览器的宽度，不会使右侧的更改了透明度的红色正方形方块发生变化。 三栏布局*这是一个经常考的一个问题，三栏布局问题也是一个特别重要的问题之一，它的题目是右侧和左侧固定，中间部分自适应。也就是无论浏览怎么拉伸和收缩，右侧和左侧的一部分内容不会发生变化，而中间的那部分内容进行自适应。 123456789101112131415161718192021222324252627282930313233&lt;div class=&quot;middle&quot;&gt;举个例子举个例子举 个例子举个例子举个例子举个例子举个例子 举个例子举个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例子举个例子 举个例子&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;*&#123; margin:0; padding:0;&#125;.left,.right,.middle&#123; height: 100px;&#125;.left,.right&#123; position: absolute; width:100px; opacity: 0.5;&#125;.left&#123; top:0; left:0; background-color: red;&#125;.right&#123; top:0; right: 0; background-color: green;&#125;.middle&#123; margin:0 100px; background-color: blue;&#125; 会得到如下图所示的图形，由此我们知道，改变浏览器的宽度，中间自适应，两边的东西大小不会发生改变。 float浮动模型**float属性是一个古老的属性。它是用的最频繁的布局属性，以前它是专门为了实现文字环绕效果而设置的。就是用来为报纸设计的一个功能属性。但是对于响应式布局来说，float不具容错性比较差，容易出现比较严重的布局问题，而且他还可能带来一些其它问题，例如父元素塌陷，以及其它兼容性的问题。 文字环绕图片1234567891011&lt;img src=&quot;C:/Users/Administrator/Desktop/hg.jpg&quot; alt=&quot;这是胡歌&quot; class=&quot;left&quot;&gt;很多胡歌加油*&#123; margin: 0; padding: 0;&#125;.left&#123; width: 100px; float: left; margin-right: 1px; margin-bottom: 1px;&#125; 我们可以看到下图所示的样子：就像报纸一样，是不是特别有意思呢？哈哈哈。 float模型的特点float模型的feature（特点）：产生浮动流，只有块级元素（block）看不见浮动元素，所以块级元素会占据浮动元素原来的位置。文本（文字），文本类元素（inline,inline-block）,并且触发了bfc的元素都能看到浮动元素，并且会排列到浮动元素的后面。 clear加伪元素clear是用来对抗float的。而且只有块级元素才能用clear。通常，我们会使用到伪元素来进行clear。 伪元素又是什么呢？ 看下这个例子：123456789101112131415161718&lt;span&gt;加油&lt;/span&gt;*&#123; margin: 0; padding: 0;&#125;span&#123; background-color: red;&#125;span::before&#123; content: &quot;lucky&quot;; display: inline-block; width:60px; height: 20px; background-color: green;&#125;span::after&#123; content: &quot;Fighting&quot;; background-color:orange; 会得到如下的图形: 伪元素：（天生就存在），可以当元素使用，但是inline元素要改成display:inline-block。每个标签都有2个伪元素。 浮动的解决办法只有块级元素才可以清除浮动，这里有个标准。3+1标准：123456father&#123;*zoom：1；&#125;father::after&#123;//注意这里写的是两个冒号，主要的是跟伪类进行区分content:&quot;&quot;; //注意的是，即使content没有内容，也需要写display:block;clear:both;&#125; 实例讲解float浮动模型**这个例子就是淘宝的导航栏：我们使用float浮动模型来对它的一部分导航栏进行制作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;淘抢购&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;电器城&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;司法拍卖&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;*&#123; margin: 0; padding: 0; text-decoration: none; color: #424242; font-family: arial;&#125;.nav&#123; //3+1清除浮动 list-style: none; *zoom: 1;&#125;.nav::after&#123; content: &quot;&quot;; display: inline-block; clear:both;&#125;.nav .nav-item&#123; float: left; margin: 0 8px; height: 25px; line-height: 25px; font-weight: bold;&#125;.nav .nav-item a&#123; height: 25px; padding: 0 5px; display: block;&#125;.nav .nav-item a:hover&#123; border-radius: 15px; background-color: #f40; color:#fff;&#125; 得到的效果图就是如下图所示： 可以看到这个导航栏使用浮动模型来写的，基本和淘宝的导航栏是一样的。是不是特别有意思。鼠标放在哪个导航栏上，导航栏就会变色，你们可以去淘宝上看是不是这样的，哈哈。 这一篇blog就先讲到这里，下篇blog会更有意思。谢谢大家。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习3","slug":"css学习3","date":"2018-09-22T12:21:19.000Z","updated":"2018-09-22T14:06:07.550Z","comments":true,"path":"2018/09/22/css学习3/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习3/","excerpt":"","text":"你要相信，命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，这个故事关于独立，关于梦想，关于勇气，关于坚韧，它不是一个水到渠成的童话，没有一点点人间疾苦。这个故事是有志者，事竟成，破釜沉舟，百二秦关终属楚，这个故事是，苦心人，天不负，卧薪尝胆，三千越甲可吞吴。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 层模型*说起层模型这个名字，可能大家会想到我的上篇blog中的盒模型，但不是一个东西哈，它俩的区别还是挺大的。首先来介绍一下position这个属性，它有几个常见的值，常见的有三个值，static，absolute，relative。position：absolute；这个属性它的feature(特点）是：脱离原来位置进行定位，相对于最近的有定位的父级（bfc）进行定位，如果没有，那么相对于文档（document）（浏览器边框）进行定位。position：relative；保留原来位置，进行层定位。相对于自己（出生）原来的位置进行定位。我下面介绍一个例子去帮助大家去理解层模型。 1234567891011121314151617181920212223242526&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;*&#123; margin: 0; padding: 0;&#125;.demo&#123; position: absolute; width: 100px; height: 100px; background-color: red; opacity: 0.5;//透明度，更好观察 left: 100px; top: 100px; z-index: 5;//层的设定，大于下面的就行&#125;.demo2&#123; position: absolute; width: 150px; height: 150px; background-color: green; top: 10px; left: 10px; z-index: 1;&#125; 得到的结果如下图所示： 可以看见红的在上面，当设置的z-index比下面的小时，则green在上面。 接下来在介绍一下position：relative；它在进行定位的时候，元素首先会出现在自己的位置上，然后再根据left，top的值，以自己原来的位置进行定位。 最后提一下position：fixed，相对于可是窗口进行定位，典型的例子就是网页中的小广告，窗口无论怎样往下走，他都是固定的位置不动，在两边的固定位置不变。但IE6中没有fixed（注意）。 居中布局*12345678910111213141516&lt;div&gt;&lt;/div&gt;*&#123; margin: 0; padding: 0;&#125;div&#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 50%; top: 50%; margin-top: -50px; margin-left: -50px;&#125; 它的效果图不就不在这里给出了，因为图可能会比较大，我把现象和大家说一下吧，就是会有一个长宽都为100px的正方形红色的方块在整个浏览器的正中间居中了。 简单的居中五环*了解了居中的情况，我们就能写一个简单的居中的五环了，是不是很有趣呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div class=&quot;plat&quot;&gt; &lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle5&quot;&gt;&lt;/div&gt;&lt;/div&gt;*&#123; padding:0; margin:0;&#125;.plat&#123; position: absolute; left: 50%; top: 50%; margin-top: -95px; margin-left: -190px;&#125;.circle1,.circle2,.circle3,.circle4,.circle5&#123; position: absolute; width: 100px; height: 100px; border-width:10px; border-style: solid; border-radius: 50%;&#125;.circle1&#123; left: 0px; top: 0px; border-color: red;&#125;.circle2&#123; left: 130px; top: 0px; border-color: green;&#125;.circle3&#123; left: 260px; top: 0px; border-color: yellow;&#125;.circle4&#123; left: 65px; top: 70px; border-color: blue;&#125;.circle5&#123; left: 195px; top: 70px; border-color: orange;&#125; 会出现如下图所示的一个简单的五环，这个颜色是我随便取得，并不是真正的五环的颜色。 这一篇blog就先讲到这里，下篇blog特别重要。谢谢大家。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习2","slug":"css学习2","date":"2018-09-21T07:02:33.000Z","updated":"2018-09-22T12:17:05.893Z","comments":true,"path":"2018/09/21/css学习2/","link":"","permalink":"http://moreluckily.com/2018/09/21/css学习2/","excerpt":"","text":"年龄越大，越学会了顺其自然，以前总认为坚持会让人更强大，但是长大后才发现，让我们强大的是放下。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 css渲染机制section div ui li a em { }。计算机找这些标签的时候是从右向左找的，一步一步的过滤。这样找的时间最短，速度最快。这个就是css渲染机制，在上一篇blog中提到过这一点。 css属性*接下来说一下常见的css属性： 1、background-color：设定背景颜色 2、color：设定字体颜色 3、font-size：设定字体大小，默认字体大小为16px，这里设定的是字体的高，如果设定字体宽就会显得参差不齐。 4、font-weight：设定字体粗细，常用值为bold（加粗），normal（正常），lighter（细），一般只有bold和normal好使，这取决于浏览器的字体包是否有我们需要的字体。还可以通过integer这个属性来设置，100|200..|900 改变粗细，具体的写法是：font-weight:100,200…strong天生有这个属性。 5、font-style：italic，改变字体为斜体。em标签是天生就有这个属性。 6、font-family：字体，通用字体就是font-family: Arial。 这个字体是最好看的，最美观的。 颜色的三种表示方法1、直接形式英文的green，blue，yellow，red等，表示的是比较含糊的值。 2、颜色代码十六进制表示：光源三原色rgb，两位两位的十六进制数，0-ff，颜色饱和程度，0表示没有颜色混合； rgb 对应都是两位重复，则可以简写。 它的写法是：例如：#ffff00，可以简写为#ff0；#f0f0f0，就不能进行简写了。最常见的就是淘宝红#f40了。3、颜色函数rgb代表顺序Red(红色)、Green(绿色)和Blue(蓝色)。它的写法就是：rgb(255，255，255) 白色rgb(255，0， 0)代表红色rgb(0，255， 0)代表绿色rgb(0， 0，255)代表蓝色 css盒模型*首先来了解一下css盒模型的一些概念。 1、content：内容区，大小为width乘height。就是我们以前经常写的东西。2、padding：内边距，用来进行分隔边框和content，可以理解为缓冲位置。分上下左右四部分，设定的时候我们可以这样来写：123456padding:30px;//(表示上下左右全部为30px)padding:30px 20px 10px 20px;//(顺序为:上右下左，顺时针,进行设定内边距）padding:50px 20px 30px;//(顺序为:上 左右 下）padding:50px 30px;//(顺序为:上下 左右） 当然也可以通过padding-left，right，top，bottom分别来进行设置。 3、border：边框12345border-width:10px 20px 30px 40px;border-style:solid;border-color:balck;//边框的颜色border:1px solid black;//产生边框的形象，1px边框的粗细border-top-width:10px;//左边框的长度 style表示的是边框的样式为实线，color表示颜色为黑色，边框粗细为上右下左10px，20px，30px，40px像素，border设定粗细的时候顺序问题跟padding是一样的。上面是几种不同的设置方法，但最后都能得到我们想要的结果。 4、margin：外边距，设定盒子与盒子之间的距离。可以单独设置。但是margin不属于有色区域，计算盒子模型的大小的时候，不需要考虑其大小。5、盒模型图通过上面的介绍，其实我们得到一张盒模型的图：这个图就能特别清晰明了的知道了整个盒模型的基本情况。 6、远视图效果通过这些知识，我们就能写一个比较小的好玩的东西了，下面我就做了一个远视图效果的东西。123456789101112131415161718192021222324252627282930&lt;div class=&quot;wrapper1&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.box&#123; width: 20px; height: 20px; background-color: red;&#125;.content&#123; width: 20px; height: 20px; background-color: blue; padding: 20px;&#125;.wrapper&#123; width: 60px; height: 60px; background-color:red; padding: 20px;&#125;.wrapper1&#123; width: 100px; height: 100px; background-color:blue; padding: 20px;&#125; 得到的效果是如下图所示：当然还可以继续多加几层，是不是特别好玩呢？ margin塌陷问题先来看一下什么是margin塌陷：1234567891011121314&lt;div class=&apos;father&apos;&gt; &lt;div class=&apos;son&apos;&gt;&lt;/div&gt;&lt;/div&gt;.father&#123; width:200px; height:200px; background-color:red; &#125;.son&#123; margin-top:50px; width:100px; height:100px; background-color:green; &#125; 我们可以看到的现象是如下图所示： 子元素加上绿色，父元素为红色，理论上我们给子元素设置margin-top，绿色顶部应该跟黄色会产生一段距离，但是现在的问题就是，子元素带动父元素一起移动了50px，这就是margin塌陷问题。那怎么解决这个问题呢？就是让子元素离父元素的顶部50px，但父元素不移动。 margin塌陷解决1、第一种方法就是父级元素的顶部没了，塌陷了，那我给他加一个顶。border-top:10px solid black;这样虽然结决了这块的问题，但是在开发整个页面的时候是不行的，这个方法特别不靠谱，不能用这个方法。那就引出了下面的第二个方法了。 2、触发bfc机制，什么是bfc呢？bfc的全称是bfc-block format content。每一个盒模型都会有它们默认的一套渲染机制，就是我们平常用的都属于它们的默认渲染机制，在这套机制里面，会存在margin塌陷的问题，这时候，我们需要利用另一套渲染机制来进行渲染，这就叫做利用触发bfc了。那怎样触发bfc呢？ 在这里先只介绍三种方法： overflow:hidden; //溢出隐藏position：absolute;float浮动 当我们在父级father触发bfc即可得到我们想要的情况，操作方法如下。12345.father&#123; width:200px; height:200px; background-color:red; overflow:hidden; &#125; 操作完成之后，我们在重新进入以下页面，尽可以看见正常位置了，也就是我们想要得到的东西。 margin合并问题margin合并讨论的就不是父子结构了，而是兄弟结构。一个设定了margin-bottom,另外一个设定了margin-top，这两个取的是更大的一个，它们并不会产生更大的间距。这时候我们需要在其中一个兄弟元素中套上一个父级标签，对父级标签触发bfc即可解决这个问题。但是通常我们不会通过这种方法解决margin合并的问题，因为这样会带来其他的反效果。我们通常就直接取其中的最大值来用就行了。 好了，这篇blog到这里就结束了，希望大家喜欢。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习1","slug":"css学习1","date":"2018-09-21T03:58:39.000Z","updated":"2018-09-21T07:02:58.117Z","comments":true,"path":"2018/09/21/css学习1/","link":"","permalink":"http://moreluckily.com/2018/09/21/css学习1/","excerpt":"","text":"我根本不知道我将来想要过什么样的生活，我根本不知道我将来想过什么样的生活，去哪个城市，做什么工作，我只是知道自己不想要什么，我不想要那种循规蹈矩、安安分分的平平淡淡的日子，不想要一个一眼就可以看到死的生活。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 浏览器的一些必备知识浏览器是由2大部分组成的，shell外核部分和内核部分。外核相对比较好做，但内核才是一个浏览器的核心。目前来说世界上主流浏览器有:1、微软 IE浏览器，它的内核是：trident。2、谷歌 Chrome，它的内核是：blink/webkit。3、苹果 Safari，它的内核是：webkit。4、火狐 Firefox，它的内核是：gecko。5、欧朋 Opera，它的内核是：presto 。它的兼容性特别好，这个浏览器可以在Windows、Mac和Linux三个操作系统平台上运行。在这里补充一点：以前谷歌和苹果一起开发的内核webkit，后来谷歌单独开发了一个内核blink，所以chorme内核写了两个，但现在基本都说是blink内核。 在这里还是强调一下，html 负责框架，css 负责内容， javascript 负责行为css的引入方式css的全称是cascading style sheet，也就是层叠样式表，必须依赖于html来进行操作，用以负责网页的内容。 它在html中引入的方式有三种： 1、行间样式，在标签里直接进行设置。例如：&lt;div style=&#39;width:100px;height:100px;background:red;&#39;&gt;&lt;/div&gt;2、页面级css，直接在html文件中，添加一个style标签，在style标签中进行css的设置。例如：1234567&lt;style type=&quot;text/css&quot;&gt; &lt;div&gt; width:100px; height:100px; background:red; &lt;/div&gt;&lt;/style&gt; 3、外部引入的方式，利用link标签，进行引入。一般在head中放入。&lt;link rel=&#39;stylesheet&#39; href=&#39;相对地址或绝对地址&#39;&gt; css的加载机制当我们引入了css之后呢，要介绍一下，是怎样加载的css文件的，在这里我们就要理解一下异步和同步的概念了。 异步的，并行的；在计算机术语中，异步是并行的，多线程的；同步的，串行的；在计算机术语中，同步指的是串行的，单线程，一个时刻只能干一件事情。这块可能我说的有点问题，大家可以在网上进行相关资料查找。当浏览器加载html文件的时候，是加载一行执行一行，当读到link标签的时候，会另开一个线程加载css，即异步加载css，html继续加载，css也一起加载，成一种“你干你的，我干我的”情况，这就是css的异步加载机制，这个很重要。 css选择器***在引入了css之后，若想添加样式，css的选择器就登场了。什么是css选择器呢？就是通过选择器，来确定某个或某种元素，以供我们进行样式的设定。下面就给大家介绍一下具体有哪些选择器。 1、id选择器当在一个标签中添上一个id，就可以通过该id选择器，将html中的框架和css内容进行联系起来。例：123456&lt;div id=&quot;only&quot;&gt;&lt;/div&gt;//html中的框架#only&#123; width:100px; height:100px; background-color:red; &#125; //css中的内容 id选择器，使用“#”+id来选择出对应的框架，然后将这个框架中的内容用css来补充。id选择器是一对一的。 2、class选择器123456&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;.demo&#123; width:100px; height:100px; background-color:red; &#125; 和id类似，其主要的形式如上面的程序所示。class选择器是多对多的。 3、标签选择器123456&lt;div&gt;&lt;/div&gt;div&#123; width:100px; height:100px; background-color:red; &#125; 和上面的标签类似，我们能够特别简单的就能理解了。 4、通配符选择器123*&#123; background-color:red; &#125; 这里注意一下，通配符选择器是将全部的标签都进行选择，包括html，head，body等标签。这里是将整个页面都变成红色。 5、属性选择器1234567&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;[class]&#123; width:100px; height:100px; background-color:red; &#125; 这里就是有class的全被选择了,当然也可以将class=”demo”写全，那就只选择一个了。 css选择器优先级比较介绍了这么多的选择器，我们不禁要想，如果有两个或者多个的选择器都选择了同一个元素的时候，而且这些选择器中的内容都不一样，那这个元素应该设置成什么样的样式呢？应该听谁的呢？举几个例子：1234567891011&lt;div id=&apos;only&apos; class=&apos;demo&apos;&gt;d&lt;/div&gt; #only&#123; width:100px; height:100px; background-color:red; &#125; .demo&#123; width:100px; height:100px; background-color:green; &#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现红色。也就是说id选择器的优先级是高于class选择器的。 123456&lt;div id=&apos;only&apos; style=&apos;background-color:green;width:100px;height:100px;&apos;&gt;&lt;/div&gt;#only&#123; width:100px; height:100px; background-color:red;&#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现green。也就是说行间样式的优先级是高于id选择器的。 1234567891011&lt;div class=&apos;demo&apos;&gt;123&lt;/div&gt; [class]div &#123; width:100px; height:100px; background-color:green; &#125; .demo&#123; width:100px; height:100px; background-color:red; &#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现red，但当.demo和[class]互换一下位置，此时浏览器会出现green。也就是说class选择器的优先级是等于属性选择器的。 css选择器权重*在这里就引出了一个比较重要的知识了，css选择器的权重，可以将这些权重归纳为如下： ！important infinity行间样式 1,0,0,0id选择器 1,0,0class选择器&amp;属性选择器&amp;伪类选择器 1,0标签选择器&amp;伪元素选择器 1,通配符选择器 0 当然了，我们就可以得出结论，当多个选择器混合使用的时候，我们需要将选择器的权重相加，之后再看那个权重进行比较，谁高就听谁的。这里的1,0,0,0是256进制的，在部分IE浏览器中256个class选择器才会大于id选择器。这里稍微要注意一下。（并不是2进制或者10进制） 6、父子选择器1234567891011&lt;div&gt; &lt;em&gt; &lt;p class=&apos;demo&apos;&gt;12345&lt;/p&gt; &lt;/em&gt;&lt;/div&gt;div em p&#123;width:100px;height:100px; background-color:green;&#125; 在开发的时候需要写成这种多级关系，让结构等价清晰明了。 7、直接子元素选择器直接子元素选择器，真正的父子选择器。1234567891011&lt;div&gt; &lt;em&gt; &lt;p class=&apos;demo&apos;&gt;12345&lt;/p&gt; &lt;/em&gt;&lt;/div&gt;div &gt; em &gt; p&#123;width:100px;height:100px; background-color:green;&#125; 而且父子选择器和直接子元素选择器是可以混用的。但在这里如果有多个这种在一起的时候，比如：section div ui li a em { }。计算机找这些标签的时候是从右向左找的，一步一步的过滤。这样找的时间最短，速度最快。 8、并列选择器12345678&lt;div class=&apos;demo&apos;&gt;1&lt;/div&gt;&lt;p class=&apos;demo&apos;&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; // 此时若想单独让2变成红色，这时候就需要用到并列选择器p.demo&#123; width:100px; height:100px; background:red;&#125; 9、分组选择器1234567div,p,em&#123; width:100px; height:100px; background-color:green; &#125; 这样div、p、em标签里的东西就全部都变成绿色，宽高各100。 在这里这篇blog就先告一段落了，下一篇blog就开始讲继续为大家讲解css。谢谢大家！！！","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"html学习3","slug":"html学习3","date":"2018-09-20T16:16:31.000Z","updated":"2018-09-21T06:59:14.834Z","comments":true,"path":"2018/09/21/html学习3/","link":"","permalink":"http://moreluckily.com/2018/09/21/html学习3/","excerpt":"","text":"新的一天，每天都要元气满满哦。今天我将继续带着大家一起继续学习htnl中特别重要的一些标签的知识。 ol和li标签ol和li标签通常是一起出现的，是有序列表的意思，ol的全称就是order list，这2个标签能进行排序，例如：12345&lt;ol&gt; &lt;li&gt;第一点&lt;/li&gt; &lt;li&gt;第二点&lt;/li&gt; &lt;li&gt;第三点&lt;/li&gt;&lt;/ol&gt; 就会出现1.第一点2.第二点3.第三点，默认是用数字进行排序，当然也可以不用数字进行排序，例如：12345&lt;ol type=&quot;a&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;1&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;i&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;a&quot; reversed=&quot;reversed&quot;&gt;&lt;ol type=&quot;a&quot; start=&quot;2&quot;&gt; 第一行的意思就是用a,b,c等进行排序，当超过26个字母之后，就开始使用aa,ab,ac等等进行排序，type里也可以用A来进行排序，和a排序类似；第二行的意思就是用1,2,3等进行排序；第三行的意思就是用罗马数字进行排序，当然也可以用大写的罗马数字进行排序；第四行的意思就是用a,b,c等进行排序，但后面又加了一个属性reversed，reversed的中文意思是翻转,颠倒的。也就是反过来倒着排序；第五行的意思就是用a,b,c等进行排序，但后面又加了一个属性start，也就是从第2个值也就是b来进行排序。但要提的一点就是type里只能填5个值，也就是a,A,1,i,I这五个值。中特别重要的一些标签的知识。 ul和li标签*ul和li标签也是在一起出现的，ul的全称就是unorder list，是有序列表的意思。这个其实是用比较多的，ol反而基本上不怎么用。它的使用场景：大功能块，下面有很多功能子项 ，它们样式都一样，典型的例子就是网页的导航栏。即打个比方就是：ul相当于柜子，li相当于抽屉。li的全称是list item，ul也可以加type值来进行设置样式，属性值有三个，disc（实心圆 默认），square（方块），circle（空心圆）。 img标签*img标签的标准写法：&lt;img src=&#39;图片地址&#39; alt=&#39;文字&#39; title=&#39;图片内容&#39;&gt;img标签是用来显示图片的功能，img的全称就是image，就是图片，影像的意思，也就是将图片引入网页中。它是一个单标签，也可以将其写成一对标签的形式，即：&lt;img&gt;&lt;/img&gt;img标签中的src属性是图片的地址，这里有三种地址方式可以选择： 1、网络地址：就是网上的图片，网上的url,就是带http什么什么的。 2、相对路径，如果如果网页程序文件和图片文件是在同一文件夹下，这时候就可以写相对地址，相对路径就是一个大的范围。 3、绝对路径，如果网页文件和图片文件不在同一文件夹下，就需要使用绝对地址，绝对路径是一个特别绝对的地方，需要将路径写的特别清晰，位置要特别的清楚不能出错。 第二个属性就是alt属性，这是一个工业级别的属性，当我们网络比较差的时候，或者图片地址出错的时候，就会在图片位置显示出alt属性中的文字。其实这是一种容错手段，一级容错，将错误降到最低。也就是当图片不能正常显示的时候，文字就会被显示出来，这样用户体验更加好，尽管看不到图，但是至少知道图的内容是什么。这个也叫图片占位符。第三个属性就是title属性，这也是一个工业级的属性，当鼠标移动到图片位置的时候，就会在鼠标点处显示出title里的值。这个也叫图片提示符。 注释*html中注释的快捷键是“Ctrl加？”，具体的形式如下所示：&lt;!-- 注释内容 --&gt;注释能够找错，可以一个模块一个模块的注释，然后找到错误出在了哪个模块，然后再在这个模块里去寻找出错的位置。 a标签**a标签的写法如下所示：&lt;a href=&quot;http://www.baidu.com&quot;&gt; www.baidu.com&lt;/a&gt;a标签就是超文本引用，它是由anchor得来的，这个单词的意思是抛锚，锚。a标签的功能是：1、网页链接功能，即在href里写上一个地址，我在上面写了一个百度的地址，当点击这个地址的时候，网页就会自动跳转到该地。2、锚点功能，同样的在href处写一个id，当点击a标签的时候，会自动调到带有id的标签处，典型的例子就是我们常常看到的“一键置顶”的功能。3、打电话功能和发邮件，Tel属性可以填入一个电话号码。我们常常在美团外卖，饿了么等app中看到，他们都有一个给商家致电的功能，就是用这个写的，当点击a标签的时候，就会自动给Tel中的电话号码致电。发邮件和他类似。4、协议限定符，在恶意网站中，我们常常点击了一个东西，于是网页就自动跳出很多弹窗，而且退出不了，必须把浏览器关了。可以利用a标签这样写，其实就是里面写了一个死循环。 table标签table标签可以实现嵌套，能实现表格的功能。具体的写法如下图所示：1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; tr就是表格的行，td就是表格的列，table标签在以前是用来布局的，以前布局都用它，但是现在不用了，只需知道为什么不用它进行布局就ok。我们正常的程序是下载一行执行一行，并不会阻塞下面的代码，但是table必须是等待它里面的内容全部下载完才会进行渲染。这样的体验效果是极差的，所以不用table来进行布局。 form标签*form标签，能实现通信功能，也就是当前端与后端进行数据交换的时候，就会使用from表单进行数据的传输。form标签的写法是：&lt;form method=&quot;get/post&quot; action=&quot;&quot;&gt; action=&quot;http://www...&quot;&lt;/form&gt;这里面的属性就是：1、method:get或者post，发送数据的方式。2、action:目标接收地址，就是数据发送的地方。发送的信息要有信息的名和信息的值。 input标签*input标签是单标签：写法如下所示：&lt;input type=&quot;text password radio/checkbox sumbit&quot; name=&quot;&quot; value=&quot;&quot; value=&#39;默认值&#39; checked=&#39;chechked&#39;&gt;第一个属性type，可以通过type属性的值来显示不同类型的input。1、text，文本框，输入用户名之类的。 2、password，密码框输入密码。 3、radio，checkbox，单选框，多选框。 4、submit，提交数据。 在第三条radio和checkbox，当type为radio的时候，input作为单选框，这时候需要利用name属性，所有选项的name属性必须都相等，表示他们属于同一单选框，这样才可以实现单选功能。当type属性为checkbox的时候，就是作为多选框，这时候，各选项的name属性不一样。 还有我们可以改善用户体验，举个例子，当使用input调查性别的时候，只有两个选项，男女，这时候，我们可以设置一个默认选项，假如默认是男性，我们可以在男性的input里添加一个属性：checked=”checked”，表示，男性为默认选项。这样就可以减少用户操作，提升用户体验。就是每一个选项不用我们都去点，而只需要进行对默认的选项进行肯定或者是否定，肯定就不需要用户去操作了，这样就让用户的体验改善了。 标签的分类**html标签可以分为三类，第一类称之为块级元素，第二类称之为行级元素，第三类就是行级块元素。 1、块级元素：占满整行，可以改变宽高。“display=block”， 可以通过CSS样式设置宽高。典型的标签： div p ul ol li address form h1 - h6等等2、行级元素：不占满整行， 元素所占空间完全由内容所控制。不可以通过CSS样式设置宽高。“dispaly=inline”， 典型的标签： span a em strong select br3、行级块元素 “display=inline-block”，这种标签是既不属于行级元素，也不属于块级元素。根据自身内容大小决定其所占据的空间，可以通过CSS样式设置宽高。典型的标签：img input。 在这里html就告一段落了，下一篇blog就开始讲css了。谢谢大家！！！","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"html学习2","slug":"html学习2","date":"2018-09-19T15:58:27.000Z","updated":"2018-09-20T16:13:58.205Z","comments":true,"path":"2018/09/19/html学习2/","link":"","permalink":"http://moreluckily.com/2018/09/19/html学习2/","excerpt":"","text":"新的一天，每天都要元气满满哦。今天我将带着大家一起继续学习htnl标签的一些知识。 P标签p标签，也叫段落标签，它能使写在其里面的内容成段落展示。标准写法就是如下所示：&lt;p&gt;内容&lt;/p&gt;p标签的p就是paragraph的缩写，是html中比较常用的标签之一。 h1-h6标签h1-h6标签能呈现越来越小的趋势标题的功能，h1标签的字号最大，h6标签的字号最小，它们的特点就是就是独占一行，改变大小，加粗文字。它们的基本写法如下所示： 123&lt;h1&gt;1级标题&lt;/h1&gt;...&lt;h6&gt;6级标题&lt;/h6&gt; strong标签&lt;strong&gt;加粗文字&lt;/strong&gt;这个标签就是起到加粗的作用，但是在之前用的都是b标签，即：&lt;b&gt;加粗文字&lt;/b&gt;熟悉WORD软件的朋友可能对其不陌生，对的，可以在WORD中用来加粗文字，但现在strong标签更加语义化，让我们更能理解他的意义。 em标签&lt;em&gt;斜体&lt;/em&gt;这个标签就是起到使文字变成斜体的作用，在之前用的都是 i标签，即：&lt;i&gt;斜体&lt;/i&gt;和b标签一样，都是从WORD中引用过来的，但现在基本不会使用i标签了，基本都会使用em标签。 del标签&lt;del&gt;￥80元&lt;/del&gt;这个标签会在文字中间加一条横线，得到的效果图如下图所示：这个效果是不是在很多地方都见过呢？没错，在淘宝或者京东里见过许多次，但是根据开发根据开发标准，del标签是不能使用的，因为，这个可以利用css进行设置，因为直接对其样式进行了修改，而html主要负责的是页面的框架架，这个标签在使用的时候，那么css和html的功能有重合的部分，所以不能使用这个这个标签，也即是这个标签不重要，可以将其忽略。在这里也介绍几个不重要的标签，单标签br和hr。1&lt;br&gt;2&lt;hr&gt;3br标签是换行，hr标签是加一条横线的效果，都不经常使用。在这里还是强调一点，html只负责结构和框架，css才能负责样式，javascript负责行为。 特别重要的2个标签*&lt;div&gt;容器&lt;/div&gt;&lt;span&gt;容器&lt;/span&gt;这两个标签没有任何的作用，不像上面讲的那几个标签，可以出现一些效果，但是这两个标签最大的特点就是没有任何特点。举个例子，我们可以将其当做一个书桌中的一个抽屉，我们可以将这些抽屉进行交换，而里面的东西，随着这些抽屉一起移动。使这些功能更加结构化，结构合理，分布较好，可以当成容器来使用，而容器的作用就是结构化和集中化操作。 文字分隔符12345&lt;p&gt;aa&lt;/p&gt;&lt;p&gt;a a&lt;/p&gt;&lt;p&gt;a a&lt;/p&gt;&lt;p&gt;a&amp;nbsp;a&lt;/p&gt;&lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;a&lt;/p&gt; 在浏览器中，默认将空格当成一个文字分隔符，但是不管空多少，它都只认为是一个文字分隔符。我们来看看效果：当我们需要较多的空时，就需要文字分隔符来帮忙了。还有就是当我们需要在浏览器中显示&lt;div&gt;时，我们发现我们不能在浏览器中显示出来，因为它是关键字，这个时候就需要“&lt;”和“&gt;”上场了，在html中，&gt;&amp;lt;就表示“&lt;”，它就是less than的缩写，也就是小于号。而:&gt;&amp;gt;就代表“&gt;”，它就是great than的缩写，也就是大于号的意思。 好了，今天的这篇 blog就到这里结束了，谢谢大家的观看。*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上！","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"html学习1","slug":"html学习1","date":"2018-09-19T13:21:28.000Z","updated":"2018-09-19T15:59:06.809Z","comments":true,"path":"2018/09/19/html学习1/","link":"","permalink":"http://moreluckily.com/2018/09/19/html学习1/","excerpt":"","text":"html是什么html css javaScript 并称WEB前端的三剑客，那它们具体的作用是什么呢？用比较专业的词汇说就是html负责结构，css负责样式，javaScript（缩写为js，以后都用缩写来对其进行介绍）负责行为。进行开发首先需要下载编程工具，在这里我推荐使用Sublime2或者Sublime3 或者Visual Studio Code（简称VS Code），在这里博主使用的是VS Code。html是WEB前端的基础，也是最简单的，html的全称是htperText markup language!!!中文翻译就是超文本链接语言，它是由一对一对的标签组成的。例如：&lt;html&gt; &lt;/html&gt;html标签就是根标签它的框架就是：1234&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这里面的head标签是给浏览器看的，就是这里面的内容是对浏览器进行一些定义什么的，而body标签是给用户看的，即这里面写的一些东西就是整个页面的框架。那我们现在就开始写代码，在head标签写以下代码：&lt;title&gt;百度一下&lt;/title&gt;然后点击保存（Ctrl+S），接下来点击鼠标右键，再然后点击Open In Default Browser选项（或者直接使用快捷键A/t+B），就会在自己电脑上默认的浏览器中打开一个网页（在这里我推荐使用Google Chrome 浏览器），但在这时我们会发现出现乱码的现象。这是因为外国的浏览器不能识别中文，这时我们就需要在 head标签里加一个另一个标签了，就是设置浏览器属性，让浏览器能够识别中文，需要加的标签是meta标签，这是一个单标签。&lt;meta charset=&quot;UTF-8&quot;&gt;charset代表了一定的属性，里面可以写比较多的东西，例如：可以在里面加gb2312，它代表的是国家标准，但其只能识别简体字，不能识别繁体字；在其基础上就有了gbk，它既能识别简体字也能识别繁体字；在之后就有了unicode，一般将它称为万国码，但utf-8是它的升级版本，于是我们在这里就使用utf-8了。&lt;html lang=&quot;en&quot;&gt;也就是language=”english”的缩写，这句话的意思也就是告诉搜索引擎爬虫，我们的网站是关于什么内容的。当然这里的en可以用”zh”和“de”等代替，”zh”就是zhongwen的缩写，”de”就是德语的缩写，还要在head标签里写的内容就是：&lt;meta name=&quot;keywords&quot; content=&quot;关键字&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot;&gt;这些信息就是告诉搜索引擎爬虫我们写的浏览器是关于什么内容的，让搜索这些关键字的人能快速的找到我们浏览器并打开它。 我们可以直接在VS Code中输入html:5然后按下Tab键，就可以生成一些基本的信息内容了。就会出现以下的一些基本内容：1234567891011&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这些虽然可以直接生成，但我们需要知道他是怎么来的，不能不求甚解。 好了，今天的blog内容就是这些了，我明天就会向大家介绍html中常见的标签名称和作用。大家晚安，希望大家都不要活成自己讨厌的样子。good night,have a sweet dream.","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"WEB前端介绍","slug":"WEB前端介绍","date":"2018-09-19T12:51:01.000Z","updated":"2018-09-19T15:44:12.248Z","comments":true,"path":"2018/09/19/WEB前端介绍/","link":"","permalink":"http://moreluckily.com/2018/09/19/WEB前端介绍/","excerpt":"","text":"WEB前端介绍首先我们需要知道WEB前端技术能做什么？它能做的东西还是蛮多的，下面我就对其进行一些简单的介绍。 公司官网（在PC通过浏览器来访问公司网站） 移动端网页（在手机上来浏览公司信息、小游戏等） 移动端APP界面（例如：淘宝、去哪儿旅游、携程等） 微信小程序（微信推出的功能，随用随装，不占用手机空间）WEB前端需要掌握的一些技能，其核心要求掌握： 语言技术：JS基础和核心、HTML5、CSS3 框架技术：JQuery、ajax、Bootstrap、AngularJS, React, React Native, Cordova, Hadoop 通讯协议技术：HTTP协议、服务端开发技术, NodeJS 客户端技术：微信开发技术、JS、SDK开发、Web App开发技术下面的blog我将开始对其各个部分进行详细的介绍与教学，OK，这篇blog就先介绍到这里了。期待大家对我接下来blog的支持与喜爱，谢谢大家。","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"大学三年总结","slug":"大学三年总结","date":"2018-09-19T11:46:12.000Z","updated":"2018-09-19T13:18:38.539Z","comments":true,"path":"2018/09/19/大学三年总结/","link":"","permalink":"http://moreluckily.com/2018/09/19/大学三年总结/","excerpt":"","text":"三年的一些感受时光如白驹过隙，稍纵即逝，一晃大学三年就过去了。在这三年中，努力过，奋斗过，笑过，也哭过，成功过，失败过，喜悦过，悲伤过，徘徊过，疯狂过，失落过。在前几天，参加学校的保研面试，但是很难受的是，没有得到学校的保研名额。其中的情况有自己的一部分原因，也用一些学校老师的情况。在这里真的不想说什么了，同时自己确实是挺难过的，努力了三年，最后得到了这个结果无论是谁都会都会有一段低潮期，在失败之后呢？不禁要想自己的未来在哪里呢？找工作或者考研？我的学校并不是985也不是211学校，只是一个普通的一本院校。考上研究生之后呢？我一直在思考这个问题。毕竟大学的出身还是挺重要的，找工作是找本专业的工作还是跨专业找呢？前几天我跑了我们学校的宣讲会，我这个专业说白了就是自动化分出来的一个旁支，对口的工作特别少，要么就是工资太低了，而一些比较好进的国企工资也低，热门的国企又不好进，而且录取的时间特别晚，等它出结果黄花菜都凉了。同时我发现这些公司有一大半都是来自互联网公司，而像我这样的非计算机专业的学生想直接进入这些公司还是太难了。经过了几天的思考，我决定还是进入互联网公司，毕竟这些公司是不看你的出身的，只看你的想法和实力。回顾过去，自己仍然有不少缺点，如创新潜力还不够强，有时候不懂得坚持，但我会尽可能地在以后的学习和生活中着重提高这些方面的潜力，人的一生就是在不断地学习、实践中得到提高、完善的。 大四的计划时光已逝，良晨难在，获取超于失去，何乐而不为，憧憬，是因为新的梦想在开启斗士的豪情！保研失败并不是结束，只是为下一个阶段学习的开始打下基础。此刻，我将重新整装，确定新的目标，迎接下一个阶段的学习。未来之路就在眼前，遥远，需要不断求索。那么就让我们屏弃所有的恐惧，和我一齐上路，为我以后的学习和工作继续创造自己的辉煌。特别喜欢超级演说家刘媛媛的演讲，“人生那么短，我就选择做那种又盲目又热情的傻瓜。永远年轻；永远热泪盈眶；永远相信梦想；相信努力的意义；相信遗憾会比失败更可怕。因为不成功的人生，它只是不完美，但是它完整。”我觉得我应该振作起来，继续努力的开始去学习，去不断的让自己没有时间去思考为什么自己没有保上研，毕竟中国是个人情社会，别人可能没你优秀，但别人在选择老师的实验室选择的好呀。也确实自己还是挺倒霉的，参加的一些比较重要的比赛都没有取得好成绩。在这里还是特别感谢我宝哥，鼓励我激励我，上帝给你关了一道门，可能是想告诉你，孩子啊！我在为你留了一扇窗呢。接下来的日子里，我将会与WEB前端结缘，拿起曾经丢下的一项能在这个社会上立足的技能，为自己的未来再次奋斗杨帆起航。长风破浪会有时，直挂云帆济苍海 。自己肯定能在明年的春招中收获自己胜利的果实，到那时，必定春风得意马蹄疾，一日看尽长安花。","categories":[{"name":"总结","slug":"总结","permalink":"http://moreluckily.com/categories/总结/"}],"tags":[{"name":"-总结","slug":"总结","permalink":"http://moreluckily.com/tags/总结/"}]}]}