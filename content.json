{"meta":{"title":"Mr.Wang's blog","subtitle":null,"description":null,"author":"moreluckily","url":"http://moreluckily.com"},"pages":[{"title":"关于博主","date":"2018-09-19T04:46:53.000Z","updated":"2018-10-23T02:43:15.662Z","comments":true,"path":"about/index.html","permalink":"http://moreluckily.com/about/index.html","excerpt":"","text":"关于博主我是Mr.Wang，来自于江西省，景德镇市，在哈尔滨理工大学测通学院测控技术与仪器专业就读大四，在2018年9月19号，正式开始更新自己的blog。言归正传，其实做这个blog的主要目的是，记录自己的生活，分享自己平时学习生活中遇到的问题及经验，同时也当做一种复习。希望以后可以跟大家一起学习交流，共同成长。这就是blog存在的原因，希望能记录、分享我在生活中遇到的难题和我认为比较精彩的内容。包括技术类问题以及为人处事，也希望能帮助一些人解决他们遇到的难题，同时提高自己的表达和总结能力。生活中总是有些东西从别人口中说出来，自己都会觉得很容易，也就那么点东西，没什么值得骄傲，但其实知道一些东西不容易，讲给别人并使其听懂更不容易。 喜欢的句子 Cease to struggle and you cease to live.生命不止，奋斗不息。 You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.你不能改变你的过去，但你可以让你的未来变得更美好。一旦时间浪费了，生命就浪费了。 The harder you work, the luckier you will.越努力越幸运 有志者事竟成，破釜沉舟，百二秦关终属楚；苦心人天不负，卧薪尝胆，三千越甲可吞吴。 超级演说家命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，这个故事关于独立，关于梦想，关于勇气，关于坚忍。 人生那么短，我就选择做那种又盲目又热情的傻瓜。永远年轻；永远热泪盈眶；永远相信梦想；相信努力的意义；相信遗憾会比失败更可怕。因为不成功的人生，它只是不完美，但是它完整。 联系博主 博客：www.moreluckily.com 微信号：Wang13677983456 QQ:1328440709"},{"title":"标签","date":"2018-09-19T04:41:56.000Z","updated":"2018-10-23T02:43:15.708Z","comments":true,"path":"tags/index.html","permalink":"http://moreluckily.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-19T04:44:42.000Z","updated":"2018-10-23T02:43:15.662Z","comments":true,"path":"categories/index.html","permalink":"http://moreluckily.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6之Class学习","slug":"ES6之Class学习","date":"2018-10-23T02:55:19.000Z","updated":"2018-10-23T02:55:19.720Z","comments":true,"path":"2018/10/23/ES6之Class学习/","link":"","permalink":"http://moreluckily.com/2018/10/23/ES6之Class学习/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ES6函数扩展","slug":"ES6函数扩展","date":"2018-10-22T15:55:11.000Z","updated":"2018-10-23T02:43:15.474Z","comments":true,"path":"2018/10/22/ES6函数扩展/","link":"","permalink":"http://moreluckily.com/2018/10/22/ES6函数扩展/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ES6对象扩展","slug":"ES6对象扩展","date":"2018-10-22T15:12:36.000Z","updated":"2018-10-23T02:43:15.474Z","comments":true,"path":"2018/10/22/ES6对象扩展/","link":"","permalink":"http://moreluckily.com/2018/10/22/ES6对象扩展/","excerpt":"","text":"","categories":[{"name":"ES6","slug":"ES6","permalink":"http://moreluckily.com/categories/ES6/"}],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://moreluckily.com/tags/ES6/"}]},{"title":"ES6数组扩展","slug":"ES6数组扩展","date":"2018-10-22T15:12:17.000Z","updated":"2018-10-23T02:43:15.490Z","comments":true,"path":"2018/10/22/ES6数组扩展/","link":"","permalink":"http://moreluckily.com/2018/10/22/ES6数组扩展/","excerpt":"","text":"新的blog，新的开始。今天进入一个新的开始，继续一起来学习一下ES6。今天要学习就是ES6中数组的扩展。 通过Array.xxx调用的Array.from这个方法可以将两种对象转化为真正的数组：类数组，（必须有length属性）；可以遍历的对象（ES6新增的数据结构Set和Map）。 Array.from方法可以将数组的空位转化为undefined，也就是说，这个方法不会忽略空位。下面是一个将类数组转为真正数组的例子： 12345678910var obj = &#123; 0 : &apos;a&apos;, 1 : &apos;b&apos;, length : 2, splice : Array.prototype.splice&#125;console.log(obj);//[&quot;a&quot;, &quot;b&quot;, splice: ƒ]//类数组变成一个数组var arr = Array.from(obj);console.log(arr); //[&quot;a&quot;, &quot;b&quot;] 当然ES5也有一个方法： 12// ES5的写法var arr1 = [].slice.call(obj); // [&apos;a&apos;, &apos;b&apos;] 上面这两种方法可能会在面试中考到，面试官可能会问，用两种方法实现类数组转化为数组这样的。 最常见的产生类数组的地方就是DOM操作中，我们通过getElementsBy，，，这样的带s的都是类数组，还有一个就是arguments形参列表。利用Array.from()都可以对他们转变为真正的数组。 123456let div = docuement.getElementsByTagName(&apos;div&apos;);let aa = Array.from(div);aa.push(123);function foo()&#123; var args = Array.from(arguments);&#125; 这样就可以正常调用数组的方法了。 如果参数是一个数组，那么会返回一个一模一样的新数组（浅拷贝） 1234var arr1 = [1,2,3];var arr2 = Array.from(arr1);console.log(arr2 == arr1);//false//说明得到的arr2和arr1是不一样的 来看一下是深拷贝还是浅拷贝。 1234567var arr1 = [[4,5,6],2,3];var arr2 = Array.from(arr1);arr1[0].push(5);console.log(arr2);//[[4,5,6],2,3]//是一个浅拷贝//深拷贝和浅拷贝的区别：当B复制了A，当A改变的时候，//B也发生改变，就是浅拷贝 直接把引用值给了arr2.属于浅拷贝。 Array.from 还可以接受第二个参数 ，作用类似于数组的map方法（第一参数是数组的每一项，第二个参数是下标索引） 用来对每个元素进行处理然后放入返回的数组之中。 123456789101112var obj = &#123; 0 : &apos;a&apos;, 1 : &apos;b&apos;, length : 2, splice : Array.prototype.splice&#125;console.log(obj);//[&quot;a&quot;, &quot;b&quot;, splice: ƒ]//类数组变成一个数组var arr = Array.from(obj, function (item,index,arr) &#123; return item + 10;&#125;);//相当于forEachconsole.log(arr); //[&quot;a10&quot;, &quot;b10&quot;] 应用： 1.判断实参类型。 1234567function typesof()&#123; return Array.from(arguments,function value()&#123; return typeof value; &#125;&#125;typesof(null,[],NaN)//[&apos;object&apos;, &apos;object&apos;, &apos;number&apos;] 2.字符串转为数组，然后返回字符串的长度因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。 ES5中： 12var arr = new Array(10)arr // [undefined * 10] 这个时候，我们使用Array.of的话就可以产生一些差异。 1234var arr = Array.of(10)arr // [10]Array() // []Array(3) // [, , ,] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 通过数组直接调用的copyWithin()上面的两个方法是定义在数组得构造函数上的，这个copyWithin是定义在数组得原型链上面的。 它可以在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 有三个参数： 1、target（必需）：从该位置开始替换数据。 2、start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 3、end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 123// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12345var arr = [1,5,10,15]; var num = arr.find(function(value,index,arr) &#123; return value &gt; 9; &#125;); //arr = 10; 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 1234 var index = arr.findIndex(function (value, index, arr) &#123; return value &gt; 9; &#125;)//index = 2 数组实例的fill()fill方法使用给定值，填充一个数组。 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。 数组实例的 includes()检测数组中的是否有includes()的参数值。返回一个布尔值。 1[1,2,3].includes(2) //true 这个有个强大的地方就是可以判断是否为NaN。 1arr[NaN].includes(NaN) //true 其他实例方法数组实例的 entries()，keys() 和 values() 用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 扩展运算符扩展运算符，这个在之前的数组的解构赋值里面稍微提了一下，没深讲。现在展开讲讲。 扩展运算符（spread）是三个点（…）。它可以将一个数组转为用逗号分隔的参数序列。 12[...document.getElementsByTagName(&apos;div&apos;)]//[&lt;div&gt;,&lt;div&gt;,&lt;div&gt;] 这个运算符主要用于函数的调用。例如：自定义一个push方法。 12345678910function push(array,...items)&#123; array.push(...items);&#125;//传入一个数组，和另一个被push的数组function add(x,y)&#123; return x + y;&#125;var number = [4,36]add(...numbers) // 42//将数组拆分之后当做x y 传进去。 替代数组的apply方法回忆一下，call和apply这两个方法都是可以改变this指向的，它们的主要区别在于传参形式不同。apply传的是数组的形式。这里可以使用数组的扩展运算符来进行替代。 123456789101112// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法 function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 例子二： 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2) 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 扩展运算符的运用合并数组12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = [&apos;a&apos;, &apos;b&apos;];var arr2 = [&apos;c&apos;];var arr3 = [&apos;d&apos;, &apos;e&apos;];// ES5的合并数组arr1.concat(arr2, arr3);// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 与解构赋值结合1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 函数的返回值JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。 12var dateFields = readDateFields(database);var d = new Date(...dateFields 上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 将字符串转化为数组12[...&apos;hello&apos;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 5.实现了 Iterator 接口的对象 6.Map 和 Set 结构，Generator 函数 5和6还没讲到，所以先放一下，讲到了再带一下。 好吧，那么关于ES6的数组扩展部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://moreluckily.com/categories/ES6/"}],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://moreluckily.com/tags/ES6/"}]},{"title":"ES6学习2","slug":"ES6学习2","date":"2018-10-18T02:22:58.000Z","updated":"2018-10-23T02:43:15.474Z","comments":true,"path":"2018/10/18/ES6学习2/","link":"","permalink":"http://moreluckily.com/2018/10/18/ES6学习2/","excerpt":"","text":"新的blog，新的开始。今天进入一个新的开始，继续一起来学习一下ES6。 复习上节课来个例子： 1234567891011121314&lt;div&gt;0&lt;/div&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;var oDiv = document.getElementsByTagName(&apos;div&apos;);for(var i = 0; i &lt; 5; i++) &#123; (function (j) &#123; oDiv[j].onclick = function () &#123; alert(j); &#125; &#125;(i))&#125;//用立即执行函数解决了闭包问题 其实就是相当于： 而ES的写法： 12345678910//es6的写法var oDiv = document.getElementsByTagName(&apos;div&apos;);for(let i = 0; i &lt; 5; i++) &#123; let i = i; oDiv[i].onclick = function () &#123; alert(i); &#125;&#125;//for循环对let的一个处理,//块级作用域了//不用立即执行函数再写一个作用域了 解构赋值ES6中，可以从对象，数组等一些引用值当中，按照一定的模式，从其中提取值，对变量进行赋值。这被称作为结构。 举个例子，利用数组来进行解构赋值。 12let [a,b,c] = [1,2,3]//a = 1, b = 2, c = 3; 等价于： 1let a = 1; let b = 2; c = 3; 只要等式两端的“模式匹配”，左边的变量就会被赋值给右边对应的变量。例如： 123//结构失败var [a,b,c] = [1,2];console.log(a,b,c);//1,2,undefined 12let [foo,[[bar],baz]] = [1,[[2],3]];//foo = 1,bar = 2 baz = 3;let [head,...tail] = [1,2,3,4] // head = 1 ,tail = [2,3,4] 注意，如果是想给数组解构的话，需要使用”…“来进行引用。如上面的第二个例子。 12let [x,y,...z] = [&apos;a&apos;]// x = &apos;a&apos;,y = undefined ,z = [ ] ;let [a,[b],d] = [1,[2,3],4] // 注意这个是对应的模式才能对上 解构不成功（左边变量右边没有对应值），变量的值就等于undefined。如果右边不是数组（跟Iterator接口有关），那么将会报错。以下全部都会报错： 12345let [foo] = 1;let [foo] = false;let [foo] = NaN ;let [foo] = undefined;let [foo] = &#123; &#125;; 事实上只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。以后会介绍为什么会报错。 默认赋值我们还能够给它们附一个默认值。如果解构不成功就会使用默认值。例如： 12let [foo = true] = [];foo // true 123456var [a = 10 , b = 20, c = 30] = [];console.log(a,b,c)//10,20,30//就是a后面为undefined时，可以这样默认赋值var [a = 10 , b = 20, c = 30] = [1,2,3];console.log(a,b,c)//1,2,3//后面不是undefined的时候，就直接用后面的值 要注意的是，ES6，内部使用严格相等运算符（“===”）来判断一个未知是否有值。所以，如果一组成员不严格等于undefined，默认值是不会生效的。 1234let [x = 1] = [undefined];x // 1let [x = 1] = [null];// x = null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。这里要注意的是，空跟undefined是两回事。 12345var arr = new Array(3);// arr = [undefined * 3]var arr2 = new Array(3)arr2[1] = undefined;//arr2 = [undefined*1 , undefined,undefined*1] 用乘号表示的的undefined其实表示的是这个位置是空，但是手动加上的undefined，是占有实际位置的。这个注意下。 一个数组里面都是从左向右解析的，这个要注意一下。 123456var [a = 1, b = a] = [];//从左到右解析console.log(a,b) //1,1var [a = b, b = 1] = [];console.log(a,b) //undefined,1 再举个例子： 123456let [a = b, b = 1] = [];console.log(a,b)//b is not defined//相当于：let a = b;let b = 1;//不会变量提升，b没有被定义 如果默认值是一个表达式，那么这个表达式是惰性求值，即只有在用到的时候，才会求值。例如： 1234function f() &#123; console.log(&apos;aaa&apos;);&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。其实等价于下面的代码： 123456let x;if([1][0] === undefined)&#123; x = f();&#125;else&#123; x = [1][0];&#125;//所以走的是else 还有要注意的地方就是，默认值在解构赋值给其他变量的时候，变量必须要是已经声明的。 12let [x = 1,y = x] = []; // x = 1 y = 1let [x = y,y = 1] = [];//RefernceError ,因为这个时候，默认值y还没有声明 对象的解构赋值举几个例子： 12345678910var &#123;a,b&#125; = &#123;a : 1,b : 2&#125;;console.log(a,b);//1,2var &#123;foo : bar&#125; = &#123;foo : 1&#125;;console.log(bar); //1console.log(foo,bar); //foo is not definedvar x;(&#123;x&#125; = &#123;x:1&#125;);console.log(x);//用表达式的方式，1 对象的结构域数组有一个重要的不同，就是数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1234let &#123;bar,foo.baz&#125; = &#123;foo:&apos;aaa&apos;,bar:&quot;bbb&quot;&#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;baz //undefined 如果变量名与属性名是不一致的，必须写称一下形式： 123456var &#123;foo : baz &#125; = &#123; foo : &quot;aaa&quot;,bar : &quot;bbb&quot;&quot;&#125;;baz // &quot;aaa&quot;let obj = &#123; first : &quot;hello&quot; ,last: &quot;world&quot;&#125;;let &#123; first : f, last : 1 &#125; = obj;f // &quot;hello&quot;l // &quot;world&quot; 这实际上说明，对象的解构赋值是这样的： 12let &#123;foo : baz , bar : ddd&#125; = &#123;foo : &quot;aaa&quot; ,bar : &quot;bbb&quot;&#125;;//baz = “aaa” ddd = &quot;bbb&quot; 真正被赋值的，是左边表达式中的属性值，在上式中，foo并没有被赋值，而是它后面的属性值被赋值。foo是匹配模式，baz才是变量，真正被赋值的是baz而不是foo。 先找到同名属性，然后再赋给对应的变量。 对象解构赋值的嵌套123456789let obj = &#123; p: [ &quot;hello&quot;, &#123;y : &apos;world&apos; &#125; ]&#125;;let &#123; p : [x,&#123;y&#125;] &#125; = obj;x // &quot;hello&quot;y // &quot;world&quot; 来一个复杂一点的例子： 123456789101112var node = &#123; loc : &#123; start : &#123; line : 1, colomn : 5 &#125; &#125;&#125;;var &#123; loc, loc: &#123;start &#125;,loc: &#123;start:&#123;line&#125; &#125; &#125; &#125; = node;line //1loc //Object &#123; start: Object&#125;start //Object &#123; line : 1,colum: 5&#125; 这个例子，主要是找准那个是匹配模式，哪个才是真正的变量，就可以解决问题。 第一个是对loc这个变量进行解构赋值，接着是start，接着是line。然后再找对应的属性名即可，loc对应的是一个对象，start也是一个对象，line则对应的是1. 对象也有默认值，也能利用对象属性进行嵌套。就不一一举例了。 12345let obj = &#123; &#125;;let arr = [];(&#123;foo : obj.prop,bar : arr[0] &#125; = &#123; foo : 123, bar : true &#125; );obj // &#123; prop : 123 &#125;arr //[true] 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;; //TypeError : Cannot match against &apos;undefined&apos; or &apos;null&apos;. 因为这个时候的foo是undefined，undefined再取自属性自然是报错。 还有一个就是： 123456let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 因为 JavaScript 引擎会将&#123;x&#125;理解成一个代码块，我们需要将它变为表达式。let x;(&#123; x &#125; = &#123; x : 1 &#125;); 原始值的解构赋值原始值的解构赋值，都会先转化为对象，然后再结构。 1234567891011121314151617181.const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; //字符串的结构2.let &#123;length : len&#125; = &apos;hello&apos;;len // 5 类数组中的length解构3.let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 第三个代码块中，数值和布尔值得包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数的解构赋值1234function add([x,y])&#123; return x + y;&#125;add([1,2]); //3 但在传入参数的那一刻，数组参数就被解构成变量x和y。 来两个例题： 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y]; &#125; move(&#123;x: 3, y: 8&#125;); // [3, 8] move(&#123;x: 3&#125;); // [3, 0] move(&#123;&#125;); // [0, 0] move(); // [0, 0] 换个写法： 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined会触发函数参数的默认值。 1[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);// [ 1, &apos;yes&apos;, 3 ] 好吧，那么关于ES6的第二部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://moreluckily.com/categories/ES6/"}],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://moreluckily.com/tags/ES6/"}]},{"title":"ES6学习1","slug":"ES6学习1","date":"2018-10-18T02:22:29.000Z","updated":"2018-10-23T02:43:15.474Z","comments":true,"path":"2018/10/18/ES6学习1/","link":"","permalink":"http://moreluckily.com/2018/10/18/ES6学习1/","excerpt":"","text":"新的blog，新的开始。今天进入一个新的开始，开始一起来学习一下ES6。 什么是ES6首先，ES6的全称是ECMAScript6，因为实在2015年发布的，所以也可以叫它ES2015，我的理解其实就是ES5的基础上加了一些特殊语句，这些特殊的语句是ES5中的基础上加一些算法来更加简单的去实现对浏览器的操作。 ECMAscript 和JavaScript的关系JavaScript的创造者Netscape公司将JavaScript提交给国际标准化组织ECMA，希望该语言成为国际标准，于是ECMA就规定了JavaScript为浏览器的脚本语言的标准，并将其命名为ECMAscript。 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 let 命令今天开始讲一下ES6中新加的一个命令，let命令。 ES6新增了let命令，用来声明变量，它的用法类似于var,但是所声明的变量，跟var声明的变量有很大的区别。 基本用法首先它是ES6中的语法，为了让浏览器具有更好的兼容性，首先需要遵守”one javascript”，意思就是新加的一些功能，但之前的语法还是可以用的。即不会像python一样，python3语法不能用在python2中。 在非严格模式下，let不是关键字。 我们可以利用let采取以下方式来进行声明变量。 123&#123; let a = 30;&#125;//这里有个块级作用域的概念，下节课再说块级作用域的概念 然后，究竟var和let有什么区别呢？别着急，来看一下这个例子。 1234567&#123; let a = 30; var b = 20; console.log(a);//30&#125;console.log(a) // a is not defined;console.log(b) // 20 看到这里，大家应该都知道它们的第一个区别了，利用let声明的变量，就像是一个局部作用域(就是后面要讲的块级作用域)，只能在其内部才能访问，而利用var声明的，就可以提到全局里面。就是这样的，利用let声明的变量，只在它自己的代码块里面有效。之后，别忘了，这里的代码块是需要利用{}，进行包含的。后面会讲到这一点。 利用let来进行变量声明，有一点好处，就是减少全局变量的污染。 12for (let i = 0; i &lt; 10 ; i ++)&#123; .........&#125;//handle functionconsole.log(i); // i is not defined; 这时候，要是我们利用var来进行i的生命的时候，如果for循环都是利用i，那么就可能会出现问题。但是利用let就不会，因为它只在自己的代码块里才能被访问。 我们再来看一个例子： 123456789101112131415var a = [ ] ;for ( var i = 0; i &lt; 10 ; i++) &#123;a [ i ] = function () &#123;console.log(i)&#125;&#125;;a[ 6 ](); // 10 var a = [ ] ;for ( let i = 0; i &lt; 10 ; i++) &#123;a [ i ] = function () &#123;console.log(i)&#125;&#125;;a[ 6 ](); // 6 为什么会出现这种情况呢，因为，let声明的i，只在该轮循环有效，所以每一次循环的i其实都是一个新的变量，JavaScript内部会记住上一轮循环的值，初始化本轮的变量的时候，就在上一轮循环的基础上进行计算。 体现let内部作用域机制在一个地方显示的更加明显，也是循环这里： 123456789for(let = 0; i &lt; 3; i++)&#123; let i = &quot;abc&quot;; console.log(i);// 3*abc &#125;for(let = 0; i &lt; 3; i++)&#123; console.log(i);// i is not define; let i = &quot;abc&quot;; &#125; 我们看到代码块1，打印出的是3个abc，但是交换了声明和打印顺序，却爆出了错误，说明了，循环用的i变量和子域中的i变量不是同一个i，即使他们的名字相同，也是不可以的。它们有各自的作用域。 let不存在变量提升这是let声明和var声明的一个重要区别，let声明的变量不存在变量提升。let所声明的变量，如果在声明之前就使用，就会报错。报的是引用错误(referenceError)； 1234567// use var to declareconsole.log(foo);//undefined,会有一个预编译环节var foo = 5;//use let to declareconsole.log(foo); // foo is not definelet foo = 5; 现在说一下，为什么会出现这种情况。 首先我们要知道，一个变量的正式生成需要有三个阶段：声明阶段，初始化阶段，赋值阶段； 利用var进行声明的变量，当JavaScript解析器进入该代码块，该变量的声明阶段和初始化阶段就被立即执行了，这时候，变量的值就是undefined，就是我们平常所熟知的变量提升。最后在赋值阶段正式赋值。 对于let进行声明的变量，当JavaScript解析器进入了该代码块，声明阶段和初始化阶段，并不是一起就被立即执行的，而是先执行了声明阶段，但是，初始化阶段是要在解析到let语句的时候才被初始化的。这时候，我们要引入了一个新名词——————暂时失效区(暂时性死区)。我将会在接下来介绍，先略过。所有，变量还没有初始化就被使用，就会报错。 那什么是暂时失效区呢？就是，当一个变量进入了暂时失效区（暂时性死区），只要访问了该变量就会报错。我们都知道，在ES6之前，利用typeof来判断一个未经声明的变量是不会报错的，但是对于ES6，因为let的存在，就不一样了。如果利用let进行声明变量，当解析器没有读到let语句的时候，你就是用了typeof，此时的变量在暂时失效区，所以系统将会报错。 所以，为了保证平稳的变量声明，有些技巧需要采取： 声明，初始化变量之后在使用变量，万能解决方法。 尽可能的减少变量数，暴露变量越少，代码月稳定 不允许重复声明let不允许重复在相同作用域内重复声明一个变量。 1234567891011121314151617181920function ()&#123; let a = 10; var a = 1 ; &#125;//报错function()&#123; let a = 10; let a = 30; &#125;//报错 不能在函数内部重新声明参数。function(arg)&#123; let arg = 35;//报错 &#125;function(arg)&#123; &#123; let arg = 93; &#125;//不报错&#125; const 命令基本用法const声明一个只读变量，相信很多学过C或者C++的同学都应该听说过，在很多语言当中，它都是用来声明常量的。 注意const声明的是一个只读的常量，常量的值是不能够修改的。例如： 1234const PI = 3.14;PI // 3.14;PI = 3;// TypeError: ASsignment to constant variable 类型错误： 赋值给了一个常量 还有一种情况就是，如果声明了一个常量，但是没有赋值的话也还是会报错的。 12const foo;// SyntaxError: Missing initializer in const declaration 声明的常量当中没有初始化 const的作用域与let命令是基本相同的。 12345只在声明所在的块级作用域内有效。没有声明提升存在临时死区只能在声明的位置后面使用。不能重复声明； 看一下代码： 1234567891011if(true)&#123; console.log(MAX); //ReferenceError 引用错误 const MAX = 5;&#125;var message = &quot; hello &quot;;let age = 25;// those two code will Report errorsconst message = &quot;Goodbye&quot;;const age = 30; //Uncaught SyntaxError: Identifier &apos;message&apos; has already been declared. 已经声明过 const本质const实际上保证的并不是变量的值不能改动，而是变量指向的那个内存地址不得改动。对于简单的原始值，值就保存在那个内存地址，因此等同于常量。但对于引用值，变量指向的内存地址保存的只会是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的就是完全不能控制了。因此，将一个对象声明为常量需要小心出漏洞。 12345const foo = &#123; &#125;;foo.prop = 123;foo.prop = 123;//make the foo point to another Objectfoo = &#123; &#125; //TypeError ： &quot;foo&quot; is read-only 只读，满足增删改查，但是不能改变foo的指向。 拓展：如果想将对象冻结，可以使用Object.freeze方法。这样它就变成了只能查，增删改都是不能实现的，即是新增了，马上会被还原。 顶层对象的属性这节课稍微提了一下global对象，这个是个顶层对象。在浏览器中，指的是window对象。顶层对象的属性是跟全局变量挂钩的，这个是被认为JavaScript语言中最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有在运行的时候才能知道（污染全局变量）；其次，很容易在全局中声明了一个变量，这样，就会导致有很多的全局变量，最后顶层对象的属性到处都是可以读写的，这样既不利于模块化编程，也不利于多人开发，容易产生变量冲突。另一方面，window对象是有实体含义的，指的是浏览器的窗口对象，这样也是不合适的。 在ES6中，为了改变这一点，一方面规定，let和const和class命令声明全局变量的时候，不属于顶层对象属性，而且当他们重复声明的时候，将会报错，这就很方便我们知道什么时候我们重复声明一个变量，提高开发效率。为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性； 1234var a = 1; window.a // 1var b = 2;window.b //undefined ES6 块级作用域ES5里，以function来划分作用域，大括号{}却限定不了var的作用域，我们把它叫做函数作用域。 ES6里增加了let，const, 声明在{}, -&gt; “function,if ,for等语句” 的变量作用域被限制在块级。（严格模式下 function 变量属于块级作用域） let的出现实际上为JavaScript新增了块级作用域。例如： 1234567function f4() &#123; let n = 5; if(true)&#123; let n = 10; &#125; console.log(n); // 5&#125; 虽然都是声明变量n，但是外层的代码不受内层代码的影响，所以就是5；如果说变量是利用var声明的话，那么最后输出就是10； 另外，块级作用域是可以进行任意嵌套的。内层作用域可以定义外层作用域的同名变量。块级作用域的出现实际上使广泛应用的立即执行函数表达式不在必要了。 123456789101112131415var a = [ ] ;for ( var i = 0; i &lt; 10 ; i++) &#123; a [ i ] = function () &#123; console.log(i) &#125;&#125;;a[ 6 ](); // 10，闭包 var a = [ ] ;for ( let i = 0; i &lt; 10 ; i++) &#123; a [ i ] = function () &#123; console.log(i) &#125;&#125;;a[ 6 ](); // 6 这个要注意的是，使用let变量声明的这个i在for循环代码块里跟花括号里面的是不一样的，但是在内部通过转换是的a数组可以获取的。这样我们可以很方便就解决了闭包问题。 块级作用域和函数声明ES5中规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明。 123456789if(true)&#123; function f()&#123;&#125;&#125;//情况2 try &#123; function f()&#123;&#125;&#125; catch(e)&#123; ...&#125; 上面两种情况都是不允许的。但是在浏览器中，为了兼容以前的代码，还是支持块级作用域之中声明函数，因此上面两种情况都是不会报错的。 ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 1234567891011function f() &#123; console.log(&apos;I am outside&apos;);&#125;(function () &#123; if(true)&#123; function f()&#123; console.log(&quot;i am inside&quot;)&apos; &#125; &#125; f();&#125;()) 这部分其实每个浏览器都可能有自己的制定情况，在Chrome中会打印出outside。（严格模式），如果在非严格模式下，是会打印出inside。。。 还有一个例子： 123456789101112function f() &#123; console.log(321);&#125;(function () &#123; f(); if(1)&#123;// 变量提升 function f()&#123; console.log(123); &#125; &#125;&#125;()) 在严格模式下打印出321，在非严格模式中报错：Uncaught TypeError: f is not a function，实际操作的代码相当于是这样的： 123456789101112function f() &#123; console.log(321);&#125;(function ()&#123; var f = undefined; if(false)&#123; function f() &#123; console.log(123); &#125; &#125; f();&#125;()); 所以就报错not a function。 反正，避免以上所有坑，就不要再if语句里面定义function就OK。 好吧，那么关于ES6的第一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://moreluckily.com/categories/ES6/"}],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://moreluckily.com/tags/ES6/"}]},{"title":"Webpack之模块化","slug":"Webpack之模块化","date":"2018-10-16T17:53:26.000Z","updated":"2018-10-23T02:43:15.537Z","comments":true,"path":"2018/10/17/Webpack之模块化/","link":"","permalink":"http://moreluckily.com/2018/10/17/Webpack之模块化/","excerpt":"","text":"新的blog，新的开始。今天讲一下前端模块化 模块化简介具有相同属性和行为的事物的集合。在前端中，将一些属性比较类似和行为比较类似的内容放在同一个js文件里面，把这个js文件称为模块，为了每个js文件只关注与自身有关的事情，让每个js文件各行其职。 模块要有几个特点： 独立、完整、依赖关系 在最开始的阶段，Js并没有这些模块机制，各种Js到处飞，也就是你们现在的野生代码，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是CommonJs和AMD。 模块化实现函数对象写法匿名函数、返回对象依赖传入实参 以上缺点依赖关系不好处理，需要按顺序加载，会阻塞页面 在最开始的阶段，Js并没有这些模块机制，各种Js到处飞，也就是你们现在的野生代码，得不到有效妥善的管理。后来前端圈开始制定规范，最开始是commonjs，nodejs就是基于commonjs规范的产物。但是由于commonjs同步加载更适合服务端，所以迫切需要最客户端的规范，即又出现了很多客户端规范，耳熟能详的AMD。 CommonJs根据CommonJs规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。 该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。 CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口 12345678910//index.jsvar module = require(&apos;module.js&apos;)module.aa(&apos;hello&apos;);//module.jsmodule.exports = &#123; aa: function (str) &#123; console.log(str); &#125;&#125;//但是直接这样写的话是不好使得 浏览器不兼容CommonJs，原因是浏览器缺少module、exports、require、global四个环境变量。如要使用需要工具转换 CommonJS采用同步加载不同模块文件，适用于服务器端的。因为模块文件都存放在服务器的各个硬盘上，读取加载时间快，适合服务器端，不适应浏览器。 AMDCommonJs为服务器端而生，采用的同步加载方式。因此不适用浏览器。因为浏览器需要到服务器加载文件，请求时间远大于本机读取的时间，倘若文件较多，网络迟缓就会导致页面瘫痪，所以浏览器更希望能够时间异步加载的方式。 AMD规范则是异步加载模块，允许指定回调函数。等模块异步加载完成后即可调用回调函数。AMD得意的产出就是require.js AMD的核心思想就是通过define来定义一个模块，然后使用require来加载一个模块。 123456789//main.jsrequire([&apos;jquery&apos;,&apos;math&apos;], function($, math) &#123; //...&#125;)//math.jsdefine(function () &#123; // ...&#125;) 使用require.js，提前加载所有依赖，方可使用 例如： CMDCMD异步加载，跟AMD的主要区别在于，AMD依赖前置，提前加载依赖。而CMD就近加载，按需加载。 产物seaJs，跟requireJs使用有些相似。 CMD的核心思想就是通过define来定义一个模块，然后使用require来加载一个模块。 例如： ES6ES6自带模块化，可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 使用 import 关键字引入模块，通过 export 关键字导出模块 好吧，那么关于模块化的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://moreluckily.com/categories/webpack/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://moreluckily.com/tags/webpack/"}]},{"title":"Webpack之less","slug":"Webpack之less","date":"2018-10-16T16:53:02.000Z","updated":"2018-10-23T02:43:15.537Z","comments":true,"path":"2018/10/17/Webpack之less/","link":"","permalink":"http://moreluckily.com/2018/10/17/Webpack之less/","excerpt":"","text":"新的blog，新的开始。今天继续讲Webpack经常会用到的一个东西，less。 lessLess Css是一种动态样式语言，属于css预处理语言的一种,它使用类似css的语法为CSS的赋予了动态的特性，如变量，继承，运算，函数等，更方便css的编写和维护实现css模块化 ,less css可以在多种语言，环境中使用，包括浏览器端，桌面客户端，服务端。 less 语法首先还是要先配置一下less，在webpack里进行配置。 12&#123;test: /.less$/, loader: [‘style-loader’,’css-loader’,’less-loader’]&#125;,//把之前配置好的css给删除 然后就可以使用了。 less，很有特点，他拥有类似于html的结构。 可以嵌套编写：例如： 1234567891011121314151617181920body&#123; width: 500px; height: 500px; background: red; #demo1&#123; width: 100px; height:100px; background: blue; &#125; #demo2&#123; width:100px; height:100px; background: green; #demo3&#123; width:50px; heigth:50px; background: yellow; &#125; &#125;&#125; 这样写结构很清晰，一目了然。。。。。。结构化。。。 注释：//不会被编译，/**/这样的注释会被编译。 声明变量 使用变量： 12345678910@w: 100px;@a: 300px;@borderRed: red;@bgred: #f40;#demo&#123; width:@w; height:@a; background: @bgred;&#125; 还可以自定义一些传参格式,类似于函数： 123456789.border(@border-width,,@border-style,@border-color)&#123; border: @border-width @border-style @border-color;&#125;#demo1&#123; width:@w; height:200px; .border(200px;solid,red);&#125;//画三角形 也可以混合传参，例如，规定border-style：dashed，然后剩下的自定义。 匹配模式画多个三角形，之后通过选择特定的名字，来选不同的样式。例如，选择不同方向的三角形：123456789101112131415161718192021222324252627.triangle(@_ ,@border-width, @border-style, @border-color)&#123;//@_表示基础样式都为下面的样式 width:0; height:0; border-width: @border-width; border-style: @border-style; border-color: @border-color; &#125;.triangle(bottom, @border-width, @border-style, @border-color)&#123; border-right-color: transparent; border-bottom-color: transparent; border-left-color: transparent; &#125;.triangle(left, @border-width, @border-style, @border-color)&#123; border-top-color: transparent; border-bottom-color: transparent; border-left-color: transparent; &#125;.triangle(top, @border-width, @border-style, @border-color)&#123; border-right-color: transparent; border-top-color: transparent; border-left-color: transparent; &#125;.triangle(right, @border-width, @border-style, @border-color)&#123; border-right-color: transparent; border-bottom-color: transparent; border-top-color: transparent; &#125; 通过模式匹配，输入right或者left或者top或者bottom就能选出特定的三角形。 属性值计算可以在样式中进行计算例如： 12width:100px + @w;height: @w + 50%; 也能使用calc来使用： 12width:calc(100px - 30%); //70pxheight: calc(200px + 50%) //240px，240和50之间要有空格 但是有时候不准确，我们可以使用“~”,表示供给浏览器进行编译。称之为避免编译，但是这个有个严格语法，就是两边需要有空格，指的两边需要有空格。 最后需要使用import来引入公共模块,就是css引入样式表，公共样式表，利用import引入，跟引入JavaScript差不多。 1@imoport &quot;./base.less&quot; 其实还有一个sass，和less差不多，也挺简单的，看一下就能明白了。 好吧，那么关于less的这一部分的知识就讲到这，希望大家能有所收获。有不会的就去官网多看看。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://moreluckily.com/categories/webpack/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://moreluckily.com/tags/webpack/"}]},{"title":"Webpack学习3","slug":"Webpack学习3","date":"2018-10-16T16:05:37.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/10/17/Webpack学习3/","link":"","permalink":"http://moreluckily.com/2018/10/17/Webpack学习3/","excerpt":"","text":"新的blog，新的开始。今天继续讲Webpack。 多文件打包在一个业务中，会有很多个页面，我们需要对它们都进行打包，而且每个页面都会有单独的js文件，这个时候，我们就需要对多个文件进行打包了。例如现在有两个文件，分别是index1.html和index2.html，它们每个都有个js文件，分别是entry.js和entry2.js，这个时候，我们需要配置一下webpack.config.js文件。 123456789101112131415moduele.exports = &#123; entry: &#123;index: &apos;.src/js/entry.js&apos;,index1: &apos;./src/js/entry1.js&apos;&#125;,//以键值对的方式进行打包 output: &#123; filename: &apos;[name].js&apos;,//会出现index.js。。。 path: __dirname + &apos;out&apos;, publicPath: __dirname + &apos;/out&apos; &#125;, module: &#123; rules: [ &#123;test: /.(png|jpg|svg|jpeg)$/,loader:[&apos;url-loader?limit=892&amp;name=./[name].[ext]&apos;]&#125; &#123;test: /.js$/, loader: &apos;babel-loader&apos;&#125;, &#123;test: /.css$/, loader: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125; ] &#125;&#125; 这里要注意的是，导出之后的文件是以entry中的键值来命名的，例如entry.js对应的是index，那么它打包之后的文件名就是index.js，记住是以键值来确定的。 插件代码压缩插件：注意：单独下载 npm install webpack，跟之前下载的全局webpack不一样。代码压缩需要再次安装一个webpack包。 之后在配置文件中引入： 1234var webpack = require(&apos;webpack&apos;);var var uglifyPlugin = new webpack.optimize.UglifyJsPlugin(&#123;minimize: true&#125;);//跟module同级的引入plugins: [uglifyPlugin] 多次引用模块 提取当然 webpack 也考虑到了 公共模块的利用 ，我们利用 插件就可以 只能提取公共部分，以提供我们浏览器的缓存复用。我们只需在webpack.config.js 添加下面的代码即可。 123456var CommonsChunkPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common&apos;); // 修改添加，webpack.config.js var webpack = require(&apos;webpack&apos;); module.exports = &#123; // ....省略各种代码 plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common&apos;) ] &#125; 要注意的是，当引入公共模块之后，需要在页面中进行新模块的引入。 特别注意：这些方法都是webpack3中的一些方法，现在都是webpack4了，方法改变了一些，我们因该去官网好好研究一下那些有改变的情况。 css独立打包如果我们希望样式通过link 的方式引入 123456var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);$ npm install extract-text-webpack-plugin --save-dev//现在后面的可以改为 -D``` 安装完插件就要配置 webpack.config.js 了。我们添加以下代码 var ExtractTextPlugin = require(“extract-text-webpack-plugin”);plugins: [new ExtractTextPlugin(“[name].css”)]1234为了区分开用 链接和用插件也支持所有独立样式打包成一个css文件。增加多一个参数即可。 new ExtractTextPlugin(‘style.css’,{allChunks:true});12345678npm init 初始化项目，生成初始化文件，默认问文件夹的名字作为项目名称，生成一个package.json文件，以后初始化的时候，可以直接获得项目使用的加载器。## webpack 服务器当我们需要打包多个图片，并且原地址是不一样的时候，我们需要将它们打包在服务器中。在全局中下载插件： npm install webpack-dev-server -g12之后，我们想把文件打包在服务器中，于是我们需要一个指令： webpack-dev-server1234这个指令可以打包文件到服务器中，并且实时监听文件，如果退出了，会把服务器也退出也不实时监听。另外，我们需要把输出文件放在服务器下面，需要在配置文件module.exports的output中输入： publice-path:”http://localhost:8080/out&#39;12345这样就可以把文件都打包到服务器中了。## 挂在全局库下载：npm install jquery，把jQuery挂载到全局，可以使用providePlugin插件。在配置文件中适用下面这段代码： var providePlugin = new webpack.ProvidePlugin({$: ‘jquery’, jQuery: ‘jquery’, ‘window.jQuery’: ‘jquery’});` 然后重新打包，这样就可以在全局中使用jQuery了。 好吧，那么关于webpack打包的这一部分的知识就讲到这，希望大家能有所收获。有不会的就去官网多看看。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://moreluckily.com/categories/webpack/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://moreluckily.com/tags/webpack/"}]},{"title":"Webpack学习2","slug":"Webpack学习2","date":"2018-10-16T02:55:01.000Z","updated":"2018-10-23T02:43:15.552Z","comments":true,"path":"2018/10/16/Webpack学习2/","link":"","permalink":"http://moreluckily.com/2018/10/16/Webpack学习2/","excerpt":"","text":"新的blog，新的开始。今天正式开始来讲Webpack。 前端工程化现在的前端发展，已经不是以前的所谓网页设计了，现在更多的是由以WebPage模式为主转变为以WebApp模式为主了。业务逻辑一复杂，就会出现一系列的问题，，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？… 前端工程化，就是要解决以上的问题的，帮助业务团队更好地完成需求，工程化会预测一些常碰到的问题，将之扼杀在摇篮，而这种路径是可重用的，是具有可持续性的，比如第一个优化去除冗余，是在多次去除冗余代码，思考冗余出现的原因而最终思考得出的一个避免冗余的方案。 自动化构建工具日新月异的前端技术已经让前端代码的逻辑和交互效果越来越复杂，更加的不易于管理，模块化开发和预处理框架把项目分成若干个小模块，增加了最后发布的困难，没有一个统一的标准，让前端的项目结构千奇百怪。前端自动化构建在整个项目开发中越来越重要。 构建工具就是用来让我们不再做机械重复的事情，解放我们的双手的。 要完成前端工程化，少不了工程化工具，requireJS与grunt的出现，改变了业界前端代码的编写习惯，同时他们也是推动前端工程化的一个基础。 requireJS是一伟大的模块加载器，他的出现让javascript制作多人维护的大型项目变成了事实；grunt是一款javascript构建工具，主要完成编译、压缩、合并等一系列工作，后续又出了yeoman、Gulp、webpack等构建工具。 Webpack具有Grunt、Gulp对于静态资源自动化构建的能力，但更重要的是，Webpack弥补了requireJS在模块化方面的缺陷，同时兼容AMD与CMD的模块加载规范，具有更强大的JS模块化的功能。 自动构建工具的两种模式开发模式开发模式比较简单，主要就是监听文件变化，自动进行打包、合并的操作。 生产模式参考我们的技术栈与需求，我们的静态文件都要发布到cdn上，而且必须有md5版本号，方便快速发布(cdn更新极其缓慢，所以更新必须使用新的文件名) 生产模式主要增加了文件压缩、文件md5名修改、替换html等操作 这样的好处就是上线非常方便，一个命令即可更新线上，而且不存在缓存问题。 CDNCDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理： 1.用户向浏览器输入www.web.com这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求； 2.网站的DNS域名解析器设置了CNAME，指向了www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统； 3.智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户； 4.用户向该IP节点（CDN服务器）发出请求； 5.由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容； 6.请求结果发给用户 webpack前端需要模块化：JS模块化不仅仅为了提高代码复用性，多人协作开发项目，更是为了让资源文件更合理地进行缓存。 如上图，有一点不知道大家是否注意到：Webpack处理后，输出的静态文件只剩下js与png，而css、less、jade其他的文件都合并到了js中。 在Webpack当中，所有资源的都是模块，模块都需要通过AMD或者CMD规范加载，就像css样式文件，不再在HTML中以标签加载。 CommonJs与AMD在一开始，我们先讲一下它和以往我们所用的模块管理工具有什么不一样。在最开始的阶段，Js并没有这些模块机制，各种Js到处飞，也就是你们现在的野生代码，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是CommonJs和AMD和CMD。 CommonJsCommonJs是应用在NodeJs，是一种同步的模块机制。采用同步的require方法来加载依赖并返回导出的接口。一个模块可以通过往exports对象上添加属性或者设置module.exports的值来确定导出哪些接口。它的写法大致如下： 12345var firstModule = require(&quot;firstModule&quot;);//your code...module.export = anotherModule //导出模块，以供调用 优点：123服务端的模块可以被复用已经有很多模块供使用了（npm）很容易上手使用 缺点：12阻塞式的调用不能适用于网络请求，因为网络请求是异步的无法同步require多个模块 AMD:异步require之前提到的模块系统只能同步require，而AMD则采用异步的实现形式。 1234require([&quot;module&quot;,&quot;../file.js&quot;],function(module,file)&#123;/*...*/&#125;);define(&quot;mymodule&quot;,[&quot;dep1&quot;,&quot;dep2&quot;],function(d1,d2)&#123; return someExportValue;&#125;); 优点能满足网络请求的异步需求 能同步加载多个模块 缺点：代码复杂，更难写也更难读 似乎是一种绕路的笨办法 webpack功能特性我们来看看webpack支持哪些功能特性： 12345支持CommonJs和AMD模块，意思也就是我们基本可以无痛迁移旧项目。支持模块加载器和插件机制，可对模块灵活定制。特别是我最爱的babel-loader，有效支持ES6。可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。将样式文件和图片等静态资源也可视为模块进行打包。配合loader加载器，可以支持sass，less等CSS预处理器。内置有source map，即使打包在一起依旧方便调试 简单来说，任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过webpack对模块进行处理后，可以打包成我们想要的静态资源。 webpack 基本操作首先我们需要创建一个文件夹，用来存放我们的项目，全路径不含中文，而且不能称作webpack，因为后期会产生冲突。然后创建一个文件夹为src，里面在创建三个文件夹，分别叫做，css，js，image。此外，在src同级路径下创建一个webpack配置文件，叫做“webpack.config.js”,里面是存放webpack的配置信息的。 另外，我们需要利用node的npm包管理，进行下载webpack，利用这个指令 123npm install webpack-cli -g//这个现在要安装，和webpack3的区别npm intall webpack -g //将webpack下载到全局 之后，我们需要编写配置文件。 1234567module.exports = &#123; entry: &apos;./src/js/entry.js&apos;, //是页面的入口函数，将要打包的文件 output: &#123; filename: &apos;index.js&apos;, //打包之后的文件名 path: __dirname + ./src/js/out, //打包之后的文件存放路径，如果没有文件，将会新建一个。 &#125;&#125; 在命令行中输入webpack，表示打包。之后，我们就可以在src中看见新建的一个out文件夹里面有index.js文件了。 如果需要多次更新的时候，我们每次更改完都需要重新打包的，于是我们需要这个 “webpack -w”，表示实时更新，自动打包。 当我们需要更改webpack的时候，需要使用“ctrl+c”退出实时监测。 多模块打包如果我们需要有很多文件需要打包，这个时候我们需要使用entry来作为一个入口函数，把需要打包的模块引入到entry.js文件中，对entry实施打包即可。 loader 加载器这些加载器主要做一些预处理的工作：比如 sass less 。这里我们以Less 和 babel 编译ES2015 为例子。 12当一个loader的时候可以写成loader：‘babel-loader’，或者use: [&apos;babel-loader&apos;]当多个loader的时候只能写成use: [&apos;babel-loader] 我们第一步就是先要安装好各个必须的loader，我们直接看看需要通过npm安装什么。 12npm install babel-loader babel babel-core css-loader style-loader url-loader file-loader less-loader less --save-dev //babel-loader 是依赖babel-core和babel-core 然后把配置文件改一下： 1234567891011121314module.exports = &#123; entry: &apos;./src/js/entry.js&apos;, //是页面的入口函数，将要打包的文件 output: &#123; filename: &apos;index.js&apos;, //打包之后的文件名 path: __dirname + ./src/js/out, //打包之后的文件存放路径，如果没有文件，将会新建一个。 &#125; module: &#123; rules: [//注意使用数组 &#123;test: /.js$/, loader: &apos;babel-loader&apos;&#125;。 &#123;test: /.css$/, loader: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125; ] &#125;&#125; 这样就可以编译出css和ES6的语法了。下面我们来写一下具体的一个小例子：利用webpack打包一个entry文件，该入口文件里面有个三个文件，分别是demo.js，,demo.css,最好实现一个功能，点击红色方块，该方块变成绿色。 demo.js里面： 1234567891011121314var obj = &#123; init : function()&#123; this.bindEvent(); &#125;, bindEvent: function () &#123; this.Dom = document.getElementById(&apos;id&apos;); this.Dom.onclick = this.changeStyle; &#125;, changeStyle: function ()&#123; this.style.backgroundColor = &quot;green&quot;; &#125;&#125;module.exports = obj;// 给出一个接口 demo.css里面: 12345#id&#123; width:100px; height: 100px; background:red; &#125; html中： 12&lt;div id=&quot;id&quot;&gt;&lt;/div&gt;&lt;script src=&quot;out/index.js&quot;&gt;&lt;/script&gt; 配置文件：webpack.config.js 1234567891011121314module.exports = &#123; entry: &apos;./src/js/entry.js&apos;, output: &#123; filename: &apos;index.js&apos;, path: __dirname + &apos;/out&apos;, publicPath: __dirname + &apos;out&apos; &#125;, module:&#123; rules: [ &#123;test: /.js$/, loader: &apos;babel-loader&apos;&#125;, &#123;test: /.css$/, loader: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125; ] &#125;&#125; 被打包的入口文件：entry.js 123require(&apos;./demo.js&apos;);require(&apos;../css/demo.css&apos;);demo.init(); 这就是webpack的一个例子，现在可能看不出有什么优点，他主要是体验在多人开发的时候的。 打包图片对图片进行引出。，我们也可以使用模块化方式： 在入口函数中： 123var img = new Image();img.src = require(&apos;../a1.png&apos;);document.body.appendChild(img); 在配置文件中： 1&#123;test: /.(png|jpg|svg|jpeg)$/,loader:[&apos;url-loader?limit=892&amp;name=./[name].[ext]&apos;]&#125; 需要使用加载器。其中limit表示，如果是大于这个大小的，将会以该文件的名字命名，创建一个图片。 好吧，那么关于webpack中的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://moreluckily.com/categories/webpack/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://moreluckily.com/tags/webpack/"}]},{"title":"Webpack学习1","slug":"Webpack学习1","date":"2018-10-16T02:16:35.000Z","updated":"2018-10-23T02:43:15.552Z","comments":true,"path":"2018/10/16/Webpack学习1/","link":"","permalink":"http://moreluckily.com/2018/10/16/Webpack学习1/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习webpack。 今天首先介绍一下MVC模式。 MVCMVC全名是Model View Controller，是模型（model）- 视图（view）-控制器（controller）的缩写，MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式，是一种软件设计典范，指的是用一种业务逻辑，数据，界面分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进个性化定制界面以及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入，处理和输出功能在一个逻辑的图形化用户界面的结构中。 模型 Model模型代表了业务数据和业务逻辑； 当数据发生改变时，它要负责通知控制器调用视图部分；多个模型能为多个视图提供数据。由于同一个模型可以被多个视图重用，所以提高了应用的可重用性。 Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。 视图 （view）视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理。通常是一句模型数据创建的。 控制器 （controller）它通过View来接受用户的输入，之后利用Model来处理用户的数据，最后把结果返回给View。Controll就是View和Model之间的一个协调者。是应用程序中处理用户交互的部分。 下面举个例子：单击Web页面中的超链接和发送HTML表单时： 1、视图将超链接和表单发送给控制器 2、控制器接收请求并决定调用哪个模型构件去处理请求。控制器本身不输出任何东西和做任何处理。 3、模型开始分析处理数据。经过模型处理后返回数据给控制器。 4、然后再由控制器确定用哪个视图来显示返回的数据。 优缺点优点1.耦合性地；视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。 2.重用性高；。MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。 3.生命周期成本低；MVC使开发和维和用户接口的技术含量降低。 4.部署快，利于软件工程化管理。 5.可维护性高，分离视图层和业务逻辑层也是的web应用更易于维护和修改。 缺点1.定义不明确，使用MVC需要精心计划，内部原理复杂，很耗时间。模型和视图严格分离，给调试应用程序带来困难。每个构件都需要彻底测试。 2.不适合中小型应用程序，研究MVC的时间，对于中小型应用程序，得不偿失。 3.增加了系统的结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 4.试图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。 涉及到H5技术一、Local storage &amp; Session storage 键值对存储数据 经常改的就需要用这个 二、Application Cache 本地缓存应用所需的文件 如果基本不改变就用这个 三、Web SQL 关系数据库 web存储web存储在之前的HTML5中的客户端存储中介绍过了。这里简单提一下。 1.localStorage方法，没有时间限制。 2.sessionStorage方法，针对一个session的数据存储。临时的存储的，当窗口关闭就会删除。 操作方式： 12345localStorage.firstname=&quot;Sun&quot;;document.write(localStorage.lastname);sessionStorage.lastname=&quot;Smith&quot;;document.write(sessionStorage.lastname); Application CacheHTML5引入了应用程序缓存技术，意味着web应用可进行缓存，并在没有网络的情况下使用，通过创建cache manifest文件，可以轻松的创建离线应用。 Application Cache的尺寸限制统一在5M。 应用程序缓存优势离线浏览 - 用户可在应用离线时使用它们；速度 - 已缓存资源加载得更快；减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 使用方法如果我们需要在页面中使用Cache缓存的话，需要在html标签中加一个属性。 1&lt;html manifest=&quot;demo.cache&quot;&gt;&lt;/html&gt;//规定文档的缓存 manifest 的位置 其中Manifest分为三部分： 1、CACHE MANIFEST - 在首次下载后进行缓存 2、NETWORK - 需要与服务器连接，且不会被缓存 3、FALLBACK - 当页面无法访问时的回退页面（比如 404 页面） 这个时候，服务器端需要维护一个manifest清单，我们利用PHP来举例子： 123456789&lt;?phpheader(&apos;Content-Type: text/cache-manifest&apos;)?&gt;CACHE MANIFEST# 2017-04-23 v1.0.0 //版本号，小版本更新，低位改变，大版本更新高位改变。一旦改变，清单所有都要变。./source/jquery.min.js //需要缓存的文件NETWORK:* 通常我们使用缓存的对象是很少发生改变的，或者更新频率比较低的文件，例如jquery之类的。如果是经常发生改变的，例如图片。 配置正确的MIME-typeMIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置，不同的服务器不一样。 WEB SQLWeb Sql Database，中文翻译作“本地数据库”，是随着HTML5规范加入的在浏览器端运行的轻量级数据库。在这其中，一项非常重要的功能就是数据库的本地存储功能。在HTML5中内置了一个可以通过SQL语言来访问的数据库。在HTML4中，数据库只能放在服务器端，只能通过服务器来访问数据库，但是在HTML5中，可以就像访问本地文件那样轻松的对内置的数据库进行直接访问。本地数据库通过Javascript脚本来进行对数据库的操作. 1.openDatabase：使用现有数据库或新建数据库来创建数据库对象。 1234567openDatabase(&quot;APP&quot;,&quot;1.0&quot;,&quot;Not the FT Web App&quot;,(5 * 1024 * 1024));参数：1、数据库名称2、数据库版本号3、对数据库的描述4、数据库存储大小5、回调函数（可选） transaction：这个方法允许我们根据情况控制事务提交或回滚 123456smallDatabase.transaction(querysql,errorCallback,successCallback);参数：1、包含事务内容的一个方法（querysql中的任何一句sql语句出错，都会回滚）2、执行成功回调函数（可选）3、回调函数（可选） executeSql：用于执行SQL 查询 12345tx.executeSql(query, data[ ], innerSuccessCallback, errorCallback);1、表示查询的字符串，使用的SQL语言是SQLite 3.6.19。（必选）2、插入到查询中问号所在处的字符串数据。（可选）3、成功时执行的回调函数。返回两个参数：tx和执行的结果（可选）4、一个失败时执行的回调函数。（可选） 好吧，那么关于Webpack中的预习部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://moreluckily.com/categories/webpack/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://moreluckily.com/tags/webpack/"}]},{"title":"HTML5学习6","slug":"HTML5学习6","date":"2018-10-16T02:16:01.000Z","updated":"2018-10-23T02:43:15.537Z","comments":true,"path":"2018/10/16/HTML5学习6/","link":"","permalink":"http://moreluckily.com/2018/10/16/HTML5学习6/","excerpt":"","text":"新的blog，新的开始。HTML最后一讲，上次写完了，忘记保存了。。。。。。 drag 和 drop初始对象和目标对象在我们鼠标点击的开始位置的元素，我们称之为，初始对象；我们最后把初始对象拖动到达的区域叫做目标对象。 事件详解当用户在支持HTML5中的浏览器开始拖放的时候，会触发一系列事件，接下来就介绍这些事件。 一开始我们先获取一下拖动元素： 12&lt;div id=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;var odiv = documentgetElementById(&apos;drag&apos;); 1.dragstart,用户拖拽页面的某个元素是，会触发dragstart事件。这个事件很有意思，因为它是唯一一个支持dataTransfer通过setData调用来设置数据的事件。这意味着在dragStart事件处理器中，必须设置可能使用的数据类型，以便在放置结束时能够查询到之前设置的数据类型。 2.dragenter，被拖拽的元素进入到目标对象的时候触发这个事件，绑定在目标对象上面，即使目标对象不在同一个页面，只要绑定了这个事件，就能触发。 3.dragleave，与dragenter事件对应，用户鼠标移出之前调用的dragenter的元素时，浏览器会触发dragleave事件。绑定在目标元素上面。 4.dragover，拖拽元素在目标元素上面移动就会触发这个事件。与之类似的还有一个drag事件，但是这个事件是绑定在拖动元素上面的，而dragover是绑定在目标元素上的。 5.drop，这个很重要，它是当拖拽元素在目标元素上，并且释放鼠标的时候，触发的事件，这个事件可以getData，后面会讲到。如果想绑定drop事件，需要在同样的元素上面，先阻止默认事件，然后才能绑定这个drop元素。 6.dragend， 绑定在拖拽元素上，当拖拽完成的时候触发这个事件。 dataTransfer 对象DragTransfer对象是我们绑定拖拽事件的时候返回给我们的一个对象，里面有一个dataTransfer对象，主要是用这个对象来操作。 dataTransfer对象用于获取和设置实际的放置数据。利用以下几个函数和属性： setData(format,data): 利用这个函数，可以设定一个数据，format就是我们要设定数据的名字，data为值。 getData(format): 获取setData设定的值。接下来写一个小demo，实现以下功能: 1231.拖动上面的长条进去下面的矩形，长条消失。2.拖动哪一个，哪一个消失。并且打印出对应的内容。3.不同条状物之间可以相互调换顺序。 12345678910111213141516171819202122ul li&#123; width: 200px; height: 50px; background: deepskyblue; list-style: none; text-align: center; line-height: 50px; margin-top: 50px;&#125;.box&#123; width: 300px; height: 200px; background: red;&#125;&lt;ul&gt; &lt;li draggable = &quot;true&quot;&gt;1&lt;/li&gt; &lt;li draggable = &quot;true&quot;&gt;2&lt;/li&gt; &lt;li draggable = &quot;true&quot;&gt;3&lt;/li&gt; &lt;li draggable = &quot;true&quot;&gt;4&lt;/li&gt; &lt;li draggable = &quot;true&quot;&gt;5&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829303132333435363738var oLi = document.getElementsByTagName(&apos;li&apos;),oUl = document.getElementsByTagName(&apos;ul&apos;)[0],oBox = document.getElementsByClassName(&apos;box&apos;)[0];function bindEvent()&#123; for(var i = 0;i&lt;oLi.length;i++)&#123; oLi[i].addEventListener(&apos;dragstart&apos;,function(e)&#123; var j = getIndex(oLi,this); e.dataTransfer.setData(&apos;num&apos;,j); &#125;) oLi[i].addEventListener(&apos;dragover&apos;,function(e)&#123; e.preventDefault(); &#125;) oLi[i].addEventListener(&apos;drop&apos;,function(e)&#123; var num = e.dataTransfer.getData(&apos;num&apos;); oUl.insertBefore(oLi[num],this); &#125;) &#125;&#125;function removeList()&#123; oBox.addEventListener(&apos;dragover&apos;,function(e)&#123; e.preventDefault(); &#125;) oBox.addEventListener(&apos;drop&apos;,function(e)&#123; var num = e.dataTransfer.getData(&apos;num&apos;); oLi[num].remove(); &#125;)&#125;function getIndex (list,item)&#123; for(var i = 0;i&lt;list.length;i++)&#123; if(list[i] == item)&#123; return i; &#125; &#125;&#125;bindEvent();removeList(); 这里有个问题需要注意的就是，每次拖动，改变了顺序，这个顺序跟一开始的那个索引是一一对应的，但是如果以这个索引来删除节点的话，时会发生逻辑性错误的。例如，如果我们将第一个长条移到第五的位置，然后将它拖进矩形。这个时候，remove的参数是0，所以会删掉第一个位置的长条，为了解决这个错误，需要在每次拖动的时候，都获取一下索引即可。 利用拖拽上传文件file API具有强大的功能，它能够在网页异步读取文件，将文件上传到服务器并跟踪上传状态，还可以将文件转换为页面元素。 同样的，在DragEvent里面的dataTransfer有一个FileList对象，里面有个File对象，它里面有关于我们所上传的文件信息。例如文件名字，文件大小，文件最后一次修改的时间戳等。 如果拖拽文件到目标元素，需要阻止默认事件，因为如果是文件的话，drop事件会默认打开文件。 Filereader这个方法可以用来读取文件的各种信息。 onloadstart 读取开始时触发 onprogress 读取中 onloadend 读取完成触发，无论成功或失败 onload 文件读取成功完成时触发 onabort 中断时触发 onerror 出错时触发 这个知识，需要使用代码来进行说明，但是代码稍长，在这里不方便展示 websocket 通信websockets是html5中最强大的通信功能，它定义了一个全双工通信信道，仅通过web上的一个socket即可进行通信。 WebSocket 对象提供了一组 API，用于创建和管理 WebSocket 连接, 以及通过连接发送和接收数据. Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已.借用了HTTP的协议来完成握手 产生原因：在 HTTP/1.0 中,大多实现为每个请求/响应交换使用新的连接 在 HTTP/1.1 中,一个连接可用于一次或多次请求/响应交换 HTTP协议中，服务端不能主动联系客户端，只能有客户端发起。这就有一个明显的缺点，多数情况下，如股票价格，新闻报道，交通状况等，当内容呈现到页面的时候，可能已经没有时效性了，我们需要不断刷新页面来获取最新信息，这明显是很麻烦的。而websocket就可以解决这个问题了。 webSoket服务器和客户端均可主动发送数据 建立连接的握手当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。 1、Browser与WebSocket服务器通过TCP握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。 2、在TCP建立连接成功后，Browser通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。 3、WebSocket服务器收到Browser发送来的请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。 4、Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口向服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。 要注意的是，如果要使用websocket来进行通信，客户端和服务端都必须支持websocket协议才可以。另外，它们两个请求头和响应头都是有区别的。一个connection是keep-alive，一个是upgrade。 websocket API使用首先第一个步，我们要先创建一个新的websocket对象。 1var socket = new WebSocket(url,&quot;protocol&apos;/[&apos;proto1&apos;,&apos;proto2&apos;); 该构造函数能传两个参数，第一个就是传输的服务器端口（必须支持websocket），另一个参数可以是字符串或者是字符串数组，它们是为了确保客户端和服务器发送与接收双方都能理解的消息，它们必须使用相同的协议。WebSocket构造函数允许你定义客户端用于与服务器通信的协议。服务器反过来选择使用的协议（在客户端和服务器之间只能使用一种协议）。 然后有几个事件： socket.onopen：当建立socket连接时候触发这个事件，这个时候可以使用一个方法就是： 1socket.send(data); 这个方法可以用来发送信息，发送的数据会挂在socket的事件对象上面。 socket.onclose:客户端从服务器接收数据时触发，这里我们可以吧连接断开，使用socket.close()，终止任何现有的连接。 socket.onmessage: 当收到消息是触发message事件，这时候，我们可以获取一下之前发送的信息： 123socket.onmessage = function (e) &#123; console.log(e.data);&#125; socket.onerror:当连接失败的时候触发这个事件 实例： 1234567891011121314151617var socket = new WebSocket(&apos;ws://echo.websocket.org/&apos;);socket.onopen = function () &#123; socket.send(&apos;hello&apos;);//向服务端发送信息&#125;socket.onmessage = function (e) &#123; console.log(&apos;message&apos;); console.log(e); console.log(e.data); socket.close();&#125;socket.onclose = function (e) &#123; console.log(&apos;close&apos;); console.log(e);&#125;socket.onerror = function () &#123; console.log(&apos;error&apos;);&#125; websocket 的优点客户端与服务器都可以主动传送数据给对方;（实现实时更新） 不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源; 好吧，那么关于HTML5中的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://moreluckily.com/categories/HTML5/"}],"tags":[{"name":"-HTML5","slug":"HTML5","permalink":"http://moreluckily.com/tags/HTML5/"}]},{"title":"HTML5学习5","slug":"HTML5学习5","date":"2018-10-15T00:59:21.000Z","updated":"2018-10-23T02:43:15.521Z","comments":true,"path":"2018/10/15/HTML5学习5/","link":"","permalink":"http://moreluckily.com/2018/10/15/HTML5学习5/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习HTML5。 今天继续介绍一下HTML5中多媒体应用的相关知识。 audio和video APIaudio（音频）和video（视频），它可以使我们不需要采用插件就能播放音频和视频，而且还有完整的API，通用的，可脚本化控制的API。 首先，这两个元素是浏览器自带的原生支持的功能新的audio元素和video元素都无需安装，以前使用flash插件的，再也不用担心插件不更新而看不到视频音频了。但是这两个元素还有些注意的地方就是，不同浏览器自己的解码器不完全相同，这意味着，有些视频格式有些浏览器可以看，有些却不可以。 另外，在我们使用这两个标签的时候，需要做一个兼容性的检测。 1var hasVideo = !!(document.createElement(&apos;video&apos;).canPlayType); 这段脚本动态创建一个video元素，然后检查canPlayType()是否存在，通过非非来转换为布尔值。如果不兼容，就没办法了，又要跟flash闹腾了。flash通常是使用object包裹的，这里就不展开讲了，请看下图： flash: h5 中的video： 操作引入这两个标签 12&lt;audio id=&quot;audio&quot; src=&quot;./成都.mp3&quot;&gt;&lt;/audio&gt;&lt;video id=&quot;video&quot; src=&quot;./成都.mp4&quot;&gt;&lt;/video&gt; 它们的属性都是通用的，以下是一些可以使用脚本化来控制的属性 1.autoplay，表示自动播放，如果设定了这个属性，那么打开页面就会自动播放了。默认的是不自动播放。另外在，这个属性要慎用，因为没有人想突然冒出来一段音乐，把自己吓一跳，除非，是来制造背景氛围的。有些情况，例如，我们经常遇到的，打开一个网页的时候，突然弹出来一个广告，并且还很大声，这就是用了autoplay这个属性。而且，这个属性iOS是不兼容的。通常情况，我们需要是用别的方法，来控制音频视频的播放。 2.controls，设置控件，设定了这个值，就相当于告诉浏览器显示通用的用户控件，例如，调整声音大小 ，暂停，跳播等，方便我们操作，但是一般样式不太好看，需要后期调整。 1&lt;audio src=&quot;source.mp3&quot; autoplay controls&gt;&lt;/audio&gt; 3.preload(none/metadata/auto)预加载 说一下这几个属性值分别代表什么意思： 1234none， 不需要加载数据，当我们使用audio和video会先预加载，如果是none就直接不加载metadata 获取元数据，诸如时长、比特率、帧大小这样的原数据而不是媒体内容需要加载的，不获取每一帧的内容。auto 浏览器应当加载它认为适量的媒体内容（多数情况下使用，根据网络情况来使用不同加载方式&lt;audio src=&quot;&quot; preload=&quot;auto&quot;&gt; 4、loop 是否循环播放音/视频, 5.poster (video 独有),当视频不可用时，使用一张图片替代，否则是空白。可以用来做视屏的封面 1&lt;video src=&quot;成都.mp4&quot; poster=&quot;封面.jpg&quot; controls&gt;&lt;/video&gt; 6.muted,为音频文件设置静音或者消除静音，或者检测当前是否为静音， 7.autobuffer,通知播放器在媒体文件开始播放前，是否进行缓冲加载，如果媒体文件已设置为autoplay，则忽略此属性 8.volume，在0到1之间设置音频音量或者查询当前音量的相对值 123456789101112oDown.onclick = function () &#123; var num = Math.floor(oAudio.volume * 10); if(num &gt; 0 )&#123; console.log(num); oAudio.volume -= 0.1; &#125;else&#123; oAudio.volume = 0; &#125;&#125;oUp.onclick = function ()&#123; oAudio.volume -= 1;&#125; 使用点击事件控制音量增加减小。注意的是，0-1之间闭区间，并且，JavaScript计算浮点值不准确，需要向下取整， 多类型资源根据浏览器支持格式，来选择适合的资源。 1234&lt;audio id=&quot;music&quot;&gt; &lt;source src=&quot;成都.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;成都.ogg&quot; type=&apos;audio/ogg&quot;&apos;&gt;&lt;/audio&gt;//用mp3 或者 用ogg格式，按照顺序获取，第一种匹配，就不用第二种，如此类推。 脚本化标签获取标签var audio = document.getElementById(‘audio’); var audio = new Audio(‘./laojie.mp3’); var audio = document.createElement(‘video’); 增加属性controls/loop/preload/autoplay属性 1234audio.controls = true;audio.loop = &apos;loop&apos;;audio.preload = &apos;auto&apos;;audio.autoplay = true; 要注意的是，currentSrc 表示的是资源链接，媒体数据的url地址，当我们想获取到这个资源连接的时候，必须要等到它加载完在进行操作。 这个时候，我们需要使用一个事件，loadedmetadata。 123456789var oAudio = new Audio(&apos;url&apos;);document.body.append(oaudio);oAudio.controls = &apos;controls&apos;;oAudio.onloadeddata = function ()&#123; console.log(oAudio.currentSrc);&#125;oAudio.onloadedmetadata = function () &#123; console.log(123);&#125;;//先打印出出123 ，在打印出地址 还要注意的是，audio没有load事件 事件play：开始播放，触发该事件 pause：暂停播放的时候，触发该事件 loadedmetadata：浏览获取完整媒体的元数据触发 loaddeddata：浏览器已经加载完当前帧数据，准备播放时触发 ended： 当前播放结束后触发 error: 在音频或视频加载发生错误的时候触发 还有很多事件，这里就提了主要的几个，读者有兴趣可查阅相关资料。 控制函数1.load(),加载音频，为播放做准备，通常情况下不需要调用，除非是动态生成的元素，用来在播放前预加载，或者重新加载视频，音频元素。 2.play()，播放音频或视频 3.pause()，暂停处于播放状态的视频或音频文件 4.canPlayType()，判断获取的资源是否可以播放 1234if(a.canPlayType(&apos;audio/mp3&quot;))&#123;//a是一段audio a.src = &quot;url&quot;; a.play();&#125; 5.palybackRate，调整播放速率。默认为一，加上一个负值就变慢，加上一个正值，就变快。但是现在兼容性有待加强，尽量不要使用。 只读的属性1.duration: 整个媒体文件的播放时长返回秒数，如果无法获取，就是返回Nan。 2.paused，如果媒体文件已经被暂停，则放回true，如果还没播放，默认返回true。 1234567oUp.onclick = function () &#123; if(oAudio.paused)&#123; oAudio.play(); &#125;else&#123; oAudio.pause(); &#125;&#125;//使用一个属性，实现播放暂停功能。 3.ended，如果媒体文件已经播放完毕，则返回true 4.seeking,如果是true，表示播放器正在调到一个新的播放点 5.startTime,返回最早播放的起始时间，一般是0.0，除非是缓冲过的媒体文件，并且一部分已经不在缓冲器。 6.currentTime，获取播放到该位置的时间。 7.currentSrc，以字符串形式返回当前正在播放或已加载的文件。对应于使用source中选择的文件。 8.每次音频加载状态也会出发一个readyStage值的改变。 9.networkState属性返回音频当前网络状态 TimeRanges 对象这个对象有几个属性比较有意思。 played: 返回已经播放（看过）的时间段 buffered：返回当前已经缓冲的时间段 seekable：返回用户可以跳转的时间段 以上的属性都有start()方法和end()方法，length属性表示当前的一个时间段，start()与end()分别返回当前时间段的起始时间点和结束时间点，单位是秒，其实参数是0. 1var percent_loaded = Math.floor(song.buffered.end(0) / song.duration * 100);//获取当前缓存内容的百分比 video额外的特性poster: 在视频加载完成之前，代表视频内容的图片的URL地址，可读可修改，方便更换图片。 width,height ： 读取或设置显示尺寸，如果设置的宽度与食品本身大小不匹配，可能导致居中显示，上下或作用可能出现黑色条状区域。 videoWidth，vudeiHeight ：返回视频的固有或自适应的宽度和高度。只读。 好吧，那么关于HTML5中的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://moreluckily.com/categories/HTML5/"}],"tags":[{"name":"-HTML5","slug":"HTML5","permalink":"http://moreluckily.com/tags/HTML5/"}]},{"title":"HTML5学习4","slug":"HTML5学习4","date":"2018-10-14T08:05:16.000Z","updated":"2018-10-23T02:43:15.521Z","comments":true,"path":"2018/10/14/HTML5学习4/","link":"","permalink":"http://moreluckily.com/2018/10/14/HTML5学习4/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习HTML5。 今天继续介绍一下HTML5中的知识。 Geolocation（对象）API 地理位置API，这个API应用很广泛，最常见的就是外卖系统，定位之后给我们推送最近的食店，第二个就是计算步数，计算路程的软件，第三个就是基于GPS导航的应用社交网络应用，可以看到好友的方位等。 位置信息html5 获取位置信息，需要先发送一个请求，用户同意，浏览器会返回一个位置信息，该位置信息是通过支持html5定位功能的底层设备（手机，笔记本电脑等）提供给浏览器的。位置信息一般由纬度，经度坐标和其他一些其他元数据组成的。如果获取不了数据通常会有三个情况，可以通过返回的PositionError,里面的code来判断具体信息： 123用户拒绝 code = 1获取不到 code = 2连接超时 code = 3 另外Geoposition对象有一些属性:（如果不存在就是null） 1234567latitude 纬度(距离赤道以北或以南)longitude 经度（英国格林威治以东或以西的数值表示）altitude 海拔accuracy 定位精准度，单位maltitudeAccuracy 海拔精准度，单位mheading 方向speed 速度 另外给大家扩展一下知识，定位信息有几种来源 IP地址获取地理位置数据，过去只能用这个方式，但是这种方式很不靠谱，通常只能定位到地级市。如果用户第IP地址是与ISP提供的话，那么这个位置通常是由服务供应商的物理地址决定的，该地址可能距离用户数千米远。 GPS定位，精确，但是定位时间长，室内效果不好，用户耗电大。 WiFi定位：通过三角距离计算出，指的是用户当前位置到已知的多个WiFi接入点的距离，这个也很精确，但是在农村效果不太好。 手机定位：相当准确，指的是用用户到一些基站的三角距离确定的。但是需要能够访问手机或者其modem的设备，现在一般都能内置了 用户自定义地理位置，这个是不能再准确的了，自己设定的，能不准确么？ 配置参数通常我们把参数放在一个对象里面。 enableHighAccuracy 是否需要高精度位置默认false timeout 单位ms 请求超时时间 默认infinity maximumAge 单位ms，位置信息过期时间，例如设定为5000，表示5秒就过期了，设置为0就无条件获取新的地理位置信息 默认0 12345var options = &#123; enableHighAccuracy : true, timeout : 30, maximumAge : 33333&#125; 其他事件1、getCurrentPosition(s,e,p) // 获取当前的位置信息 success回调函数，必须参数；当收到位置信息之后处理的地方。来写一个： 12345678910function success (position)&#123; var latitude = position.coords.latitude, longitude = position.coords.longitude, accuracy = position.coords.accurcy, timestamp = position.coords.timestamp; console.log(latidude); console.log(longitude); console.log(accuracy); console.log(timestamp);&#125; error回调函数，可选参数；如果出错了，就回调这个函数。建议使用。 options参数，可选； 2、watchPosition() // 监视位置变化，和1参数一样 var id = geolocation.watchPosition() 用于注册监听器，在设备的地理位置发生改变的时候自动被调用。 参数与 getCurrentPosition 相同 clearWatch(id) 使用 clearWatch 清除监听 3、clearWatch() // 清除位置监视 ,需要传worker的名字。 Devicemotion 事件这个事件可以监控到设备上面的加速，如果存在加速，例如摇一摇，手机速度等就会触发这个事件。首先我们需要在window上面绑定一个devicemotion事件。 123window.addEventListener(&apos;devicemotion&apos;,function(e)&#123; console.log(e);&#125;);// DeviceMotionEvent&#123;&#125; 返回一个对象 这里面有些属性挺有用的， 1.accelerationIncludingGravity （包括重心引力）重力加速度 2.acceleration 重力加速度（需要陀螺仪支持） 3.rotationRate(alpha, beta, gamma)旋转速率 4.interval // 获取的时间间隔 上述所有属性均为只读属性。然后我们来获取一下各个方向的加速度。 123456var c = document.getElementById(&apos;container&apos;);window.addEventListener(&apos;devicemotion&apos;,function(e)&#123; console.log(e); var h = c.innerHTHL + e.accelerationIncludingGravity.x + &apos; - &apos; + e.accelerationIncludingGravity.y + &apos;-&apos; + e.accelerationIncludingGravity.z + &apos;&lt;/br&gt;&apos;; c.innerHTML = h;&#125;) 然后挂在手机上面就有这种效果了： 这个事件还可以用来监控手机上的摇一摇动作。 123456789101112131415161718192021222324252627var shake_threshold = 800;//设定最佳用户体var last_update = 0;//获取上一次时间，与上次位置的做对比var x, y,z , //当前坐标参数 last_x = 0, last_y = 0, last_z = 0;function deviceMotionHeadler(eventData)&#123; var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime();// 获取一个时间戳 if((curTime - last_update) &gt; 300)&#123; //大于3秒在进行操作 var diffTime = curTime - last_update; //取一个时间差 last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z;//获取对应的加速度 var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; // 算出来一个动作的速度 if(speed &gt; shake_threshold)&#123;//如果小于800 不看做是摇一摇的动作 认为一个抖动之类的 alert(&apos;shake~!&apos;); var div = document.createElement(&apos;div&apos;); &#125; last_x = x; last_y = y; last_z = z; &#125;&#125;window.addEventListener(&apos;devicemotion&apos;,deviceMotionHeadler,false); deviceorientation能监听设备在方向上的变化 123window.addEventListener(deviceorientation, function(event)&#123; console.log(event);&#125;); deviceorientation事件所包含的属性： 1.alpha 表示设备沿z轴上的旋转角度，范围为0~360。2.beta 表示设备在x轴上的旋转角度，范围为-180~180。它描述的是设备由前向后旋转的情况。3.gamma 表示设备在y轴上的旋转角度，范围为-90~90。它描述的是设备由左向右旋转的情况。 4、webkitCompassHeading：与正北方向的角度差值。正北为0度，正东为90度，正南为180度，正西为270度。因为0度是正北，所以叫指北针。 5、webkitCompassAccuracy：指北针的精确度，表示偏差为正负多少度。一般是10。 好吧，那么关于HTML5中的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://moreluckily.com/categories/HTML5/"}],"tags":[{"name":"-HTML5","slug":"HTML5","permalink":"http://moreluckily.com/tags/HTML5/"}]},{"title":"HTML5学习3","slug":"HTML5学习3","date":"2018-10-14T08:04:57.000Z","updated":"2018-10-23T02:43:15.506Z","comments":true,"path":"2018/10/14/HTML5学习3/","link":"","permalink":"http://moreluckily.com/2018/10/14/HTML5学习3/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习HTML5。 今天介绍一下HTML5中的4个API。 requestAnimationFrame先引一个例子，如果我们想将一个方块，从左到右开始移动，到一定位置就停止。有几种方式： 1.css3使用animation，操作动画，或者使用过度动画，transition。 2.利用js，setInterval定时器。对于这种方式，有个缺点就是，计时器时间不准确，因为每个计时器操作的时候，是使用任务时间片的形式，每次推一个时间片执行，要等到任务一完成才能执行任务二，所以导致不准确。 有时候，利用定时器进行操作动画的时候，例如，我们这里有两个定时器（16.7ms最小值，因为屏幕每秒刷新60次，每次大约16.66秒），他们在操作的时候，每次会创建一个任务时间片然后往线程上面放，如果有任务一操作时间过长，使得任务二操作被推迟，那么，下次轮到任务二执行的时候，它会从原始任务点，直接去到应该执行到的位置。所以，做动画我们通常不用定时器进行。通常就是使用我们接下来讲的requestAnimationFrame。 它的特点： 1、页面刷新前执行一次 不需要我们设定时间，只有页面刷新才会触发这个函数。 2、1000ms 60fps -&gt; 16ms 3、cancelAnimationFrame，利用这个可以实现类似于clearInterval的效果。取消计时器。 4、用法和 setTimeout类似 5、兼容性，处理IE浏览器，其他的都兼容的比较好，如下图，通过can I use 来查找兼容性。 我们来测试一下 123456789101112131415161718192021222324div&#123; position: absoulute;//获取left的时候需要使用 left: 0; top: 0; width: 200px; height: 200px;&#125;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var demo = document.getElementById(&apos;demo&apos;); var fun = function () &#123; var ispeed = 0, end = 500, frame; demo.style.left = ispeed + &apos;px&apos;; ispeed += 10; if(ispeed &lt;= end)&#123; frame = requestAniamationFrame(fun);//如果left小于500，执行requestAniamationFrame(fun),把函数传进去，每次屏幕刷新都会执行fun函数。 &#125;else&#123;//如果大于end值，就cancel计数器 cancelAnimationFrame(frame); demo.style.left = end + &apos;px&apos;;//如果速度不是整数，就可能没到500点，于是我们需要直接让它等于500； &#125; &#125; fun() 但是这个还是不能完全替代计时器，如果没有使用动画效果，其他情况还是可以使用计时器的。针对效果才使用它。 接下来我们对兼容性来讨论一下。 12345678window.requestAnimFrame = (function()&#123;return window.requestAnimationFrame ||//查看该浏览器下的每个window对象是否存在对应的方法（谷歌，IE，欧朋等） window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback )&#123; window.setTimeout(callback, 1000 / 60); &#125;;&#125;)(); 客户端存储storage;先回顾一下cookie 12345document.cookie = &quot;name=haha;max-age=10000(ms)&quot;//设定cookie，有效期是10000毫秒，使用的是格林威治时间var oDate = new Date();oDate.setDate(20);document.cookie = &quot;expires=&apos; + oDate ;//利用expires设定日期，精确地。//取cookie, doucument.coolie 1.localstorage : 本地存储，不清楚就一直在，不需要设定有效时间。 123localStorage.age = &quot;20&quot;;//直接设定存储localStorage.duyi = JSON.Stringfy(&#123;&apos;xiaozhang&apos; : &apos;old deng&apos;&#125;);//传一个字符串形式的对象，必须要是字符串。localStorage.age = ...//直接取出来，因为localStorage本来就是一个对象，Storage。 2.sessionstorage : 临时存储，关闭窗口即被删除。刷新但不关闭窗口也会存在，只有删除窗口才会消失。 作用域1.localStorage和sessionStrage都是必须满足同源策略才能访问到Storage，例如，我在页面a设定了一个Storage，然后关闭。打开页面b，如果它们是同源的页面b就能访问到页面a设定的storage，如果不是就不行。 2.sessionStorage，还有窗口的限制，一但换了一个窗口，就访问不了之前的storage了。 API1、localStroage.setItem(‘name’,val) 设置属性值 name是属性名，val是属性值 2、localStroage.getItem(name) 获得属性值 3、localStroage.removeItem(name) 移除属性 4、clear() 清除属性,所有清空 cookie（简单的提一下）详情可以看之前网络的内容，这里简单提一下。 coolkie可以存储信息到用户的设备上，数据量较小，通常用来存放账户密码之类的小信息。 利用navigator.cookieEnabled 检测是否启用了cookie，封装一个方法来获取cookie 12345678910function getCookie(name) &#123; var name = name + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0)==&apos; &apos;) c = c.substring(1); if (c.indexOf(name) != -1) return c.substring(name.length, c.length); &#125; return &quot;&quot;;&#125;//获取cookie 对比storage和cookie区别 用处当我们离线的时候，可以使用以前缓存下来的东西，如果上线就可以检查缓存是否更新，更新就用新的。 简单总结一下：它可以提供一种在Cookie之外存储会话数据的途径，并且提供一种存储大量可以跨会话存在的数据的机制。 history在网页中，我们常常可以看到一些按钮，它可以实现往后退一页或者是往前进一页，并且页面不会刷新，现在我们就来讲一下这个是怎样实现的。 通过修改hash和hashchange事件来实现历史记录管理 1、pushState history.pushState(state, title, url); 添加一条历史记录，在URL中填写你需要跳转的页面，添加之后，现在就有两条历史记录，并不会刷新旧页面。 12345var obj = &#123; name : &apos;fafa&apos;,&#125;history.pushState(obj,null,&apos;./index1.html&apos;);//第一个传一个当前页面的状态，第三个传的是将要跳转的页面 pushState，一般我们不会填写页面，一般填写一个hash值，利用hashChange事件判断它是否发生改变，就获取这个hash值，并在页面中把对应的内容改变一下。 2、replaceState history.replaceState(state, title, url); 替换当前的历史记录。 参数详解state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null。 title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。 事件1、popstate 事件 历史记录发生改变时触发，但是要注意一点就是，调用history.pushState()或者history.replaceState()不会触发popstate事件。 2、hashchange事件 当页面的hash值改变的时候触发，常用于构建单页面应用 Worker理解为一个工人，当我们设定一个计算量非常大的时候，我们可以分配一个worker来进行处理。 worker与主线程之间的通信1、postMessage(n)方法，我们需要处理的参数 2、message事件 ，当worker接收到传参信号之后，它会触发message事件，然后把n获取。例如： 1234567891011121314&lt;scripte src=&quot;worker.js&quot;&gt;//引入&lt;/script&gt;&lt;script&gt;var worker = new Worker(&apos;worker.js&apos;);worker.onmessage = function (e)&#123; console.log(e.data);&#125;worker.postMessage(10);//触发worker里面的message事件&lt;/script&gt;worker里面的代码(worker.js)onmessage = function(e)&#123; var num = e.data; postMessage(num * 10);&#125; 方法close() 在worker作用域中调用close.(worker.js),相当于工人自己不干了 terminate() 在worker对象上调用(主进程的worker对象上 worker.terminat()）)相当于被老板fire了 通常用terminate来实现控制。worker一旦被终止，不能重新启动，但是可以使用同样的URL来建立一个新的worker。 其他特性1、importScripts(‘./math1.js’,’./math2.js’) 当我们利用多个JavaScript文件来进行执行的时候，worker没有访问document的权限，所有，要利用importScript来实现引入，worker只是window的子集，只能实现部分功能，不能获取到window, document，所以这里不要引juery zepto。可以引入一些计算类的库。 2、作用域 globalWorkerScope 可以继续生成worker对象 (理论上可以，但是暂时还不支持)， 123navigatorXMLHttpRequest（阿贾克斯对象）setTimeout/serInterval（计时器） 例子：利用这个worker，对图片进行高斯模糊处理。 好吧，那么关于HTML5中的API的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://moreluckily.com/categories/HTML5/"}],"tags":[{"name":"-HTML5","slug":"HTML5","permalink":"http://moreluckily.com/tags/HTML5/"}]},{"title":"算法学习2","slug":"算法学习2","date":"2018-10-13T16:38:55.000Z","updated":"2018-10-23T02:43:15.662Z","comments":true,"path":"2018/10/14/算法学习2/","link":"","permalink":"http://moreluckily.com/2018/10/14/算法学习2/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习HTML5。 今天介绍一下HTML5中的svg。 新的blog，新的开始。今天我将和大家一起继续学习一下算法方面的知识。 还原二叉树举个小例子吧： 这个二叉树的前序是：1,2,4,5,3,6。 这个二叉树的中序是：4,2,5,1,6,3。 这个二叉树的后序是：4,5,2,6,3,1。 1、那首先选前序和中序来还原整个二叉树。 首先可以选出根节点，前序的第一个就是根节点，然后再中序中可以得到这棵树的左子树和右子树。 对于前序来说：左子树：2，4，5；对于中序来说，左子树：4,2,5则可以得到左子树的根节点是2，左孩子是4，右孩子是5. 那对于前序来说：右子树：3,6；对于中序来说，右子树是：6,3.则可以得到右子树的根节点是3，左孩子是6. 这样我们就能还原整个二叉树了，其实就是每一个子树都满足相同的规律。每一层都慢慢的递归下去。 2、选后序和中序来还原整个二叉树 从后面找根节点，这就是和前序的一点区别。 3、选前序和后序能找到二叉树吗？ 首先能得到根节点1，前序中后面的所有数设为有n个数，即前序从后面开始找，后序也重后面开始找。 当n-x=2或者n-x=5时，这个方程有解。即能得到二叉树。 再继续思考，当n-x=5时，前序：2,4,5,3,6。后序：4,5,2,6,3。其根节点是不一样的。故可以舍去这个解。 即n-x=2是唯一解，也能得到最初的二叉树，但是太麻烦了。而且也太难了。 二叉排序树根节点的选择，最好是中位数，就是中间的数据。这样会使整个二叉树的层数最少。一个平衡的二叉排序树，如果数能找到，则1小于等于x小于等于层数。x为需要找多少次。 如果数不能找到，则层数减一小于等于x小于等于层数。 排序排序有许多种方法，大约有20多种，但常见的也就那么几种。那我先来分一下类： 1、冒泡，选择 2、快排，归并。它们都用到了递归的思想。 3、堆排，插入 4、计数 冒泡排序首先我们JS中有一个方法sort( )，它其实用到的方法就是冒泡排序，返回1或者-1来进行比较大小。最后能排序。 排序其实就是比较，只是比较之后的交换方式不同（本质），交换方式不同，就得到不同的算法。 首先写一个交换的函数， 12345function exchange(arr, a, b) &#123; var temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125;//就是将数组中的arr[a]和arr[b]进行交换了 那接下来就写一个第一重的循环。 1234567var arr = [3,2,1,5,7,6];//从小到大排序for(var j = 0;j &lt; arr.length - 1; j++) &#123;//一次循环解决一个数 if(arr[j] &lt; arr[j + 1]) &#123; continue; &#125;else &#123; exchange(arr, j , j + 1); &#125; 其实就是相邻的2个数进行比较，小的就排在前面，大的就排在后面。 那来一个总的： 12345678910111213141516171819202122232425var arr = [3,2,1,5,7,6];function exchange(arr, a, b) &#123; var temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125;function compare(a, b) &#123;//加分项 return a &lt; b ? true : false; &#125;//冒泡排序function mySort(arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; //能排出n个数 for(var j = 0;j &lt; arr.length - 1 - i; j++) &#123;//一重循环解决一个数 //减i让它的性能最大， if(arr[j] &lt; arr[j + 1]) &#123; //compare(arr[j] &lt; arr[j + 1]),加分项，效果会更好 continue; &#125;else &#123; exchange(arr, j , j + 1); &#125; &#125; &#125;&#125;mySort(arr);console.log(arr); 选择排序它的意思就是选出一个最大或者最小的值，放在最后或者最前 1234567891011121314function mySort2(arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; var min = i; for(var j = i;j &lt; arr.length; j++) &#123;//主要看里面的循环 if(arr[j] &lt; arr[min]) &#123; //compare(arr[j], arr[min])//改成这样，加分项 min = j; &#125; &#125; exchange(arr, min, i); &#125;&#125;mySort2(arr);console.log(arr); 冒泡排序和选择排序比较：冒泡其实就是边比较边交换，选择排序就是找最值 选择排序的交换次数是最稳定的。 当数组的顺序刚开始是比较好的时候，用冒泡快，当原数组顺序比较乱的时候，用选择排序。 快排首先讲一下人和计算机的一点小区别。 人简单计算比较慢，而计算机的简单计算比较快。 我们利用这一点，就可以得到一个算法，傻子排序。 首先选组长，然后建2个小组，左小右大。循环重复。当最后只剩下一个数的时候，将数组拼接起来， 12345678910111213141516171819202122232425function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; //选组长 var leader = arr[0]; //建立两个小组 var left = []; var right = []; //小左，大右 for (var i = 1 ; i &lt; arr.length ; i ++) &#123; if (compare(arr[i], leader)) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; //重复第一步 left = quickSort(left); right = quickSort(right); //重复完之后拼接返回 left.push(leader); return left.concat(right);&#125; 这里定义了其他两个数组，当然我们也可以不用定义数组，就是在一个数组中进行比较。 123456789101112131415161718192021222324252627282930313233343536function quickSort2(arr, begin, end) &#123; if (begin &gt;= end) &#123; return; &#125; //选组长 var leader = arr[begin]; var left = begin; var right = end; while(left &lt; right) &#123; //首先右边和leader比，因为leader的位置空出来了 while (left &lt; right) &#123; if (arr[right] &lt; leader) &#123; arr[left] = arr[right]; left += 1; break; &#125; else &#123; right -= 1; &#125; &#125; while (left &lt; right) &#123; if (arr[left] &gt; leader) &#123; arr[right] = arr[left]; right -= 1; break; &#125; else &#123; left += 1; &#125; &#125; &#125; arr[left] = leader; quickSort2(arr, begin, left - 1); quickSort2(arr, left + 1, end);&#125;quickSort2(arr, 0, arr.length - 1);console.log(arr); 最小生成树这里有2个方法，普里姆法（加点法），克鲁斯卡尔法（加边法） 首先来一个图： 普里姆法（加点法）其实它就是第一人称的视角的方法，首先随便选一个点，加入选C点，找最小的线，也就是1，和A相连了。 再找A,C中的最小线，就是3，连接了AD。 再找A,C,D中的最小线，就是2，连接了DF。 一步步的最后得到下图： 克鲁斯卡尔法（加边法）就是全局观的方法。 还是找C，最近的是A，A,C连接起来了。 再找到了D，A,C,D。 但不能形成回路（欧拉回路），就找到了F，再是B。 慢慢的就得到了和上面一样的图。同样的结果。 好吧，那么关于算法学习的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"算法","slug":"算法","permalink":"http://moreluckily.com/categories/算法/"}],"tags":[{"name":"-算法","slug":"算法","permalink":"http://moreluckily.com/tags/算法/"}]},{"title":"HTML5之svg","slug":"HTML5之svg","date":"2018-10-13T05:04:52.000Z","updated":"2018-10-23T02:43:15.506Z","comments":true,"path":"2018/10/13/HTML5之svg/","link":"","permalink":"http://moreluckily.com/2018/10/13/HTML5之svg/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习HTML5。 今天介绍一下HTML5中的svg。 SVG首先svg这个标签有什么用呢？ svg的全称是Scalable Vector Graphics —— 可缩放矢量图形。 我们之前介绍的html5中的canvas是一个位图，当它放大的时候，是会出现失真的，它也称作为栅格图形。 而svg就不一样了，它可以实现缩放的时候不失真，图形质量不会下降，称之为矢量图形。 canvas和svg失真与否的根本原因： 放大、旋转或者用其他手段变换svg内容的时候，渲染程序会立即重绘构成图像的线条。缩放svg不会导致其质量下降，svg文档在呈现时会保留构成它的矢量信息。这与位图截然不同，放大canvas和图像这样的位图后，图像变得模糊，是in为图像由像素组成，且只能在更高的分辨率下重新采样，它的机制“基础信息——构成图像和路径——在图像完成绘制之后便丢失”，所以canvas会失真。 场景：图表，图标icon，动效，矢量图； 在这里介绍一个小图标的网站，flagicon网站。 由于，svg是使用标签进行绘制的，标签太多会影响页面质量。所以，只用在要求较高的高精度场景，或者简单的，不复杂的小icon。 svg的基本操作首先创建一个svg标签; 12345678910111213141516 &lt;svg width=500 height=500&gt;&lt;/svg&gt;1. 直线&lt;line x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;200&quot; y2=”100”&gt;&lt;/line&gt;，起始位置，结束位置的坐标2. 矩形&lt;rect x=&quot;50&quot; y=&quot;50&quot; width=&quot;100&quot; height=&quot;100&quot; rx=&quot;10&quot;ry=&quot;20&quot;&gt;&lt;/rect&gt; 起笔点，宽高，长度,圆角3. 圆形&lt;circle r=&quot;50&quot; cx=&quot;220&quot; cy=&quot;100&quot;&gt;&lt;/circle&gt;，cx和cy是圆心4. 椭圆&lt;ellipse rx=&quot;100&quot; ry=&quot;50&quot; cx=&quot;100&quot; cy=&quot;200&quot;&gt;&lt;/ellipse&gt; 长轴，短轴（X方向，y方向），圆心5. 折线&lt;polyline points=&quot;60 50, 75 35, 100 50, 125 35, 150 50,175 35, 190 50&quot;&gt;&lt;/polyline&gt;,折线每个点的坐标6. 多边形&lt;polygon points=&quot;125 125,130 140,120 140&quot;&gt;&lt;/polygon&gt;7. ⽂本&lt;text x=&quot;125&quot; y=&quot;220&quot;&gt;hello,world&lt;/text&gt; 之后要给他们添加css属性才可以看到效果。 1234fill：填充，默认填充黑色，如果不想要颜色，可以填transparent。stroke：描边，默认黑色边。stroke-width：边框宽度stroke-opacity/fill-opacity：边框/内容透明度 那我们来举个例子吧，画下面这个图： 1234567891011&lt;svg width = &quot;500px&quot; height = &quot;500px&quot;style = &quot;border:1px solid black&quot;&gt; &lt;polyline points=&quot;160 50, 175 35, 200 50, 225 35, 250 50,275 35, 290 50&quot;&gt;&lt;/polyline&gt; &lt;rect x=&quot;150&quot; y=&quot;50&quot; width=&quot;150&quot; height=&quot;150&quot; rx=&quot;10&quot;ry=&quot;10&quot; style = &quot;fill:transparent;stroke:black;stroke-width:2;&quot;&gt;&lt;/rect&gt; &lt;circle r=&quot;15&quot; cx=&quot;190&quot; cy=&quot;100&quot;style = &quot;fill:transparent;stroke:black;stroke-width:2;&quot;&gt;&lt;/circle&gt;; &lt;circle r=&quot;15&quot; cx=&quot;260&quot; cy=&quot;100&quot;style = &quot;fill:transparent;stroke:black;stroke-width:2;&quot;&gt;&lt;/circle&gt;; &lt;circle r=&quot;5&quot; cx=&quot;195&quot; cy=&quot;105&quot;&gt;&lt;/circle&gt; &lt;circle r=&quot;5&quot; cx=&quot;265&quot; cy=&quot;105&quot;&gt;&lt;/circle&gt; &lt;polygon points=&quot;225 120,230 140,220 140&quot;style = &quot;fill:transparent;stroke:black;stroke-width:2;&quot;&gt;&lt;/polygon&gt; &lt;ellipse rx=&quot;30&quot; ry=&quot;10&quot; cx=&quot;225&quot; cy=&quot;160&quot;style = &quot;fill:transparent;stroke:black;stroke-width:2;&quot;&gt;&lt;/ellipse&gt; &lt;text x=&quot;200&quot; y=&quot;220&quot;style =&quot;fill:transparent;stroke:deepskyblue;stroke-width:2;font-size:10px;&quot;&gt;hello,world&lt;/text&gt;&lt;/svg&gt; path标签这个是svg中的路径标签，类似于canvas的beginpath一类的属性和方法。svg有个属性d（data缩写）下面介绍一下它的命令。 1、M指令和L指令 M相当于moveTo L相当于lineTo; 2、m指令和l指令 1&lt;path d = &quot;m 10 10 l （相对于第一个点）20 10&quot; /&gt; M和m的区别 绝对坐标和相对坐标 3、H和V命令 （H高 V宽） 1&lt;path d=&quot;M 100 100 H 200 V 200&quot;/&gt; 4、Z命令，闭合路径。 1&lt;path d=&quot;M 100 100 H 200 V 200 z&quot;/&gt; 注：Z不区分大小写 5、A命令（用来画圆弧） A命令，用来获取圆弧。七个参数（rx ry x-axis-rotation large-arc-flag sweep-flag x y） • rx ry 圆弧的x轴半径和y轴半径 • x-axis-rotation 圆弧相对x轴的旋转角度，默认是顺时针，可以 设置负值 • large-arc-flag 表示圆弧路路径是大圆弧还是小圆弧 1大圆弧 • sweep-flag 表示从起点到终点是顺时针还是逆时针，1表示顺 时针，0表示逆时针 • x y 表示终点坐标，绝对或相对。 由图可得，每个组合能获取4个弧度，通过大弧小弧，顺时针逆时针来进行获取确定的一段弧。 1&lt;path d=&quot;M 100 100 A 70 70 90 1 1 150 200&quot;&gt;&lt;/path&gt; 圆心为70，70，旋转角的为90度，选的是大圆弧，顺时针，另一个圆是150,200为圆心的圆。 当然这里还有贝塞尔曲线的方法，在这里就不多介绍了。 SVG渐变svg中有个defs标签，用预定义留待将来使用的内容，其中又有use元素用于连接到defs元素定义的内容。借助这两个元素，可以重复用同一个元素，减少代码冗余。例如： 1234567891011&lt;svg width=&apos;200&apos; height=&apos;200&apos;&gt; &lt;defs&gt; &lt;g id=&quot;shapeGroup&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot;style=&quot;fill:url(#bg1)&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;80&quot; r=&quot;40&quot; stroke=&quot;aaa&quot; fill=&quot;none&quot; stroke-width=&quot;8&quot;/&gt; &lt;/g&gt; &lt;/defs&gt; &lt;use xlink:href=&quot;#shakeGroup&quot; transform=&quot;translate(60,0) scale(0.5)&quot;/&gt; &lt;use xlink:href=&quot;#shakeGroup&quot; transform=&quot;translate(160,80) scale(0.5)&quot;/&gt; &lt;use xlink:href=&quot;#shakeGroup&quot; transform=&quot;translate(20,60) scale(0.25)&quot;/&gt;&lt;/svg&gt; 这样就相当高于复制三次，但是定义组不可见，所以页面展示为三个图形。 线性渐变linearGradient ：线性渐变，其中有个stop标签，其中有offset属性表示变到这个位置的百分数。style为颜色的变化。 1234567&lt;defs&gt; &lt;linearGradient id=&quot;bg1&quot; x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;0&quot; y2=&quot;100%&quot;&gt;//使用id来直接修改 &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,0);&quot;/&gt;//表示0的位置的颜色为（255,255,0） &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(255,0,0);&quot;/&gt;//表示100的位置颜色为（255,0,0） &lt;/linearGradient&gt;&lt;/defs&gt;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot;style=&quot;fill:url(#bg1)&quot;/&gt;//style 修改渐变样式 径向渐变radialGradient，这个是圆的渐变，格式都跟上面的差不多。 1234567&lt;defs&gt; &lt;radialGradient id=&quot;bg2&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; r=&quot;50%&quot; fx=&quot;50%&quot; fy=&quot;50%&quot;&gt; &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:green;&quot;/&gt; &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:red;&quot;/&gt; &lt;/radialGradient&gt;&lt;/defs&gt;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot; style=“fill:url(#bg2)&quot;/&gt; 滤镜效果高斯滤镜123456&lt;defs&gt; &lt;filter id=&quot;Gaussian_Blur&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;20&quot;/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;500&quot; height=&quot;500&quot; fill=”yellow” style=&quot;filter:url(#Gaussian_Blur)&quot;/&gt; 其他滤镜1http://www.w3school.com.cn/svg/svg_filters_intro.asp svg 路径动画1、stroke-dasharray：这个是用来设置虚线的，例如： 123stroke-dasharray: 100px //虚线 和间隔都是100pxstroke-dasharray: 100px 50px // 虚线100 间隔 50 stroke-dasharray: 100px 50px 30px //虚线100 间隔50 虚线30 间隔100 。。。一直循环下去 2、stroke-dashoffset: X轴偏移，第一部分。 通常两个属性结合使用，如果整条线为200px，然后，我们把stroke-dasharray为200，然后又让stroke-dashoffset为200；那么效果就是白色的，因为，一开始是全部黑色，然后设定了dashoffset之后，黑色部分往x轴负方向移动200px。于是就消失了。于是我们可以做一个动态效果。 123456789101112131415161718192021svg&#123; border:1px solid #000;&#125;path&#123; stroke-width:10px; stroke:#000; fill:transparent; stroke-dasharray:500px; stroke-dashoffset:500px; animation:move 1s linear infinite alternate;&#125;@keyframes move&#123; 0%&#123; stroke-dashoffset: 500px; &#125; 100%&#123; stroke-dashoffset: 0px;&#125;&lt;svg width=500 height=500&gt; &lt;path d=&quot;M 0 100 L 500 100&quot;&gt;&lt;/path&gt;&lt;/svg&gt; 这个就是抽风的路径，就是一根线和另一根白色的线在循环移动。 1.getTotalLength:获取路径总长度 2.getPointAtLength(x) :获取路径上距离起始点距离x的点的坐标.例如： 1path.getPointAtLength(100)//获取path路径上距离起笔点为100的左边。 要注意的是，严格来说上面两方法只适用于path元素，但各个浏览器实现起来都会有一点区别。例如谷歌浏览器也能获取到line元素的路径长度。 写一个例子1234567891011121314151617181920&lt;style&gt;svg&#123; border: 1px solid #000;&#125;#innder&#123;stroke-width:10px;fill: transparent;stroke: #000;stroke-dasharray: 1000px;stroke-dashoffset: 1000px;stroke-linecap: round;transition: all 1s linear;&#125;#bg&#123;stroke-width:30px;fill: transparent;stroke: rgba(255, 0, 0, 0.5);stroke-linecap: round;&#125;&lt;/style&gt; 1234567891011121314151617 &lt;input id=&quot;put&quot; type=&quot;text&quot;&gt;&lt;svg width=500 height=500&gt; &lt;path id=&quot;bg&quot; d=&quot;M 200 300 A 100 100 0 1 1 300 300&quot;&gt;&lt;/path&gt; &lt;path id=&quot;innder&quot; d=&quot;M 200 300 A 100 100 0 1 1 300 300&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;script&gt;var oInput = document.getElementById(&apos;put&apos;);var oPath = document.getElementById(&apos;innder&apos;);var allLen = oPath.getTotalLength();oInput.onblur = function () &#123; var num = oInput.value; oPath.style.strokeDashoffset = 1000 - allLen*num/100;&#125;&lt;/script&gt; 得到下面这个图的效果，就是有一个仪表盘，输入多少，转化为百分数，在仪表盘中显示对应的百分条。 ViewBoxview设定一个视野区。 123&lt;svg width=&quot;400&quot; height=&quot;300&quot; viewBox=&quot;0,0,40,30&quot; &gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;50&quot; height=&quot;50&quot; rx=&quot;10&quot;ry=&quot;20&quot;&gt;&lt;/rect&gt;//充满矩形区域，&lt;/svg&gt; 2、preserveAspectRatio 123xMin xMid xMax -&gt; x轴 左中右对齐yMin yMid yMax -&gt; y轴 左中右对齐meet/slice/none -&gt; 设置填充方式，按比例撑开/截断 可以通过，svg.setAttribute(“preserveAspectRatio”, “xMinYMin meet”);来设定属性。 js生成svg元素1、创建SVG元素需要指定命名空间，命名空间声明由xmlns属性提供。此属性表示svg标记及其子标记属于的名称空间为 ： 1&quot;http://www.w3.org/2000/svg&quot; （XML方言，） 当然，它是SVG。注意，命名空间声明只需要在根标记上提供一次。声明定义了默认命名空间，因此用户代理知道所有svg标签的后代标签也属于同一命名空间。用户代理检查他们是否属于同一个命名空间，如果是的话才去如何处理命名空间下的标签标记。 注意，命名空间名称只是字符串，尽管SVG命名空间名称看起来像URI，但这并不重要。URI通常被使用，因为它们是唯一的，目的不是“链接”某处。（事实上​​，URI经常使用，通常使用术语“命名空间URI”而不是“命名空间名称”。） 2、SVG元素对象一般通过调用setAttribute()方法来设定属性值 1234567891011121314var char = “http://www.w3.org/2000/svg”; svg = document.createElementNS(char,&apos;svg&apos;);svg.setAttribute(&apos;width&apos;,500);svg.setAttribute(&apos;height&apos;,500); svg.setAttribute(&apos;viewBox&apos;,&apos;0 0 500 500&apos;);var rect = document.createElementNS(char,&apos;rect&apos;);rect.setAttribute(&apos;x&apos;,100);rect.setAttribute(&apos;y&apos;,100);rect.setAttribute(&apos;width&apos;,500);rect.setAttribute(&apos;height&apos;,500);rect.setAttribute(&apos;fill&apos;,&quot;#fc&quot;);svg.appendChild(rect);document.body.appendChild(svg); 画一个叮当猫1234567891011121314151617181920212223242526272829&lt;svg width = &quot;500px&quot; height = &quot;500px&quot; style = &quot;border:1px solid black&quot;&gt; &lt;path d = &quot;M 200 200 A 100 100 0 1 1 300 200&quot;style = &quot;fill:deepskyblue;stroke:gray&quot;&gt;&lt;/path&gt; &lt;ellipse rx=&quot;80&quot; ry=&quot;75&quot; cx=&quot;250&quot; cy=&quot;135&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;line x1 = &quot;200&quot; y1 = &quot;205&quot; x2 = &quot;300&quot; y2 = &quot;205&quot;style = &quot;stroke:red;stroke-width:14px;stroke-linecap:round&quot;&gt;&lt;/line&gt; &lt;polygon points=&quot;195 212, 155 192, 145 215,193 237,193 307,240 307,250 300,260 307,307 307,307 237,355 259,365 236,307 212&quot;style = &quot;fill:deepskyblue;stroke:gray;&quot;&gt;&lt;/polygon&gt; &lt;circle r=&quot;20&quot; cx=&quot;140&quot; cy=&quot;200&quot;style = &quot;fill:white;stroke:gray;&quot;&gt;&lt;/circle&gt; &lt;circle r=&quot;20&quot; cx=&quot;370&quot; cy=&quot;250&quot;style = &quot;fill:white;stroke:gray;&quot;&gt;&lt;/circle&gt; &lt;ellipse rx=&quot;32&quot; ry=&quot;10&quot; cx=&quot;283&quot; cy=&quot;310&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;ellipse rx=&quot;32&quot; ry=&quot;10&quot; cx=&quot;217&quot; cy=&quot;310&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;path d = &quot;M 210 212 A 50 50 0 1 0 290 212&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/path&gt; &lt;path d = &quot;M 215 245 A 30 30 0 1 0 285 245&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/path&gt; &lt;line x1 = &quot;215&quot; y1 = &quot;245&quot; x2 = &quot;285&quot; y2 = &quot;245&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;circle r=&quot;10&quot; cx=&quot;250&quot; cy=&quot;215&quot;style = &quot;fill:yellow;stroke:gray;&quot;&gt;&lt;/circle&gt; &lt;circle r=&quot;3&quot; cx=&quot;250&quot; cy=&quot;220&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/circle&gt; &lt;ellipse rx=&quot;22&quot; ry=&quot;28&quot; cx=&quot;228&quot; cy=&quot;68&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;ellipse rx=&quot;22&quot; ry=&quot;28&quot; cx=&quot;272&quot; cy=&quot;68&quot;style = &quot;fill:white;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;ellipse rx=&quot;3&quot; ry=&quot;5&quot; cx=&quot;238&quot; cy=&quot;75&quot;style = &quot;;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;ellipse rx=&quot;3&quot; ry=&quot;5&quot; cx=&quot;262&quot; cy=&quot;75&quot;style = &quot;stroke:gray&quot;&gt;&lt;/ellipse&gt; &lt;circle r=&quot;9&quot; cx=&quot;250&quot; cy=&quot;95&quot;style = &quot;fill:red;stroke:gray;&quot;&gt;&lt;/circle&gt; &lt;path d = &quot;M 200 160 A 80 80 0 0 0 300 160&quot;style = &quot;fill:transparent;stroke:gray&quot;&gt;&lt;/path&gt; &lt;line x1 = &quot;230&quot; y1 = &quot;130&quot; x2 = &quot;180&quot; y2 = &quot;130&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;270&quot; y1 = &quot;130&quot; x2 = &quot;320&quot; y2 = &quot;130&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;230&quot; y1 = &quot;120&quot; x2 = &quot;185&quot; y2 = &quot;110&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;230&quot; y1 = &quot;140&quot; x2 = &quot;185&quot; y2 = &quot;150&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;270&quot; y1 = &quot;120&quot; x2 = &quot;325&quot; y2 = &quot;110&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;270&quot; y1 = &quot;140&quot; x2 = &quot;325&quot; y2 = &quot;150&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;215&quot; y1 = &quot;245&quot; x2 = &quot;285&quot; y2 = &quot;245&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt; &lt;line x1 = &quot;250&quot; y1 = &quot;104&quot; x2 = &quot;250&quot; y2 = &quot;178&quot;style = &quot;stroke:gray;&quot;&gt;&lt;/line&gt;&lt;/svg&gt; 动态的签名首先是在editor.method.ac网站上面写下想要的签名，然后得到svg代码。 12345678910111213141516171819202122232425262728293031body &#123; text-align: center;&#125;@keyframes show &#123; to &#123; stroke-dashoffset: 0; &#125;&#125;@-webkit-keyframes show &#123; to &#123; stroke-dashoffset: 0; &#125;&#125;pre &#123; font-size: 20px; color: #999; background: #000; text-align: left;&#125;var pathList = document.getElementsByTagName(&apos;path&apos;);var l = pathList.length;var delay = 0;for(var i = 0; i &lt; l; i++) &#123; var curLen = Math.round(pathList[i].getTotalLength()); pathList[i].style.strokeDasharray = curLen; pathList[i].style.strokeDashoffset = curLen; pathList[i].style.webkitAnimation = &apos;show &apos; + 4 * curLen + &apos;ms linear &apos; + delay + &apos;ms forwards&apos;; delay += 4 * curLen;&#125; 这样就能得到一个动态的签名。 好吧，那么关于HTML5中的svg的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://moreluckily.com/categories/HTML5/"}],"tags":[{"name":"-HTML5","slug":"HTML5","permalink":"http://moreluckily.com/tags/HTML5/"}]},{"title":"HTML5之canvas","slug":"HTML5之canvas","date":"2018-10-12T15:33:05.000Z","updated":"2018-10-23T02:43:15.490Z","comments":true,"path":"2018/10/12/HTML5之canvas/","link":"","permalink":"http://moreluckily.com/2018/10/12/HTML5之canvas/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习HTML5。 首先介绍一下HTML5的新功能。 HTML5新功能新的DOCTYPE和字符集以前写DOCTYPE的时候，要写一长串内容，现在只需要写&lt;!DOCTYPE&gt;即可，还有字符集： 12&lt;meta http-equiv=&quot;Content-Type: content=&quot;text/html&quot;;charset=&quot;utf-8&quot;&gt;//过去的写法&lt;meta charset=&quot;utf-8&quot;&gt;//现在的写法 新的元素内嵌元素：audio、video、canvas等 语义化元素： 1&lt;article&gt;、&lt;header&gt;、&lt;title&gt;、&lt;footer&gt;、&lt;nav&gt; 还有其他一些强大的操作，以后会介绍到。 Canvashtml5中的一个很强大的功能就是canvas，我们称它为画布，它主要应用在有些，图标，动画等。在网页中使用canvas元素的时候它会创建出一块矩形区域，默认宽为300像素，高为150像素。 它能用来做： 1、游戏的场景 2、图表，散点图，柱状图，扇形图等等。例如：echarts 官网, 百度自己封装的。 3、动画的效果，例如：codepen 网站。搜canvas , 用canvas画的很多小demo。 1&lt;canvas&gt;&lt;/canvas&gt; 这样就创建出一个画布了，之后，我们需要使用JavaScript来控制它，如果要做后续的操作还需要获取它的上下文(相当于获取该画布的画笔），之后才可以在其中添加图片线条文字等。 123456789canvas&#123; border: 1px solid #000;&#125;&lt;canvas id=&quot;myCanvas&quot; width=500 height=500&gt;&lt;/canvas&gt;//js中的代码var canvas = document.getElementById(&apos;myCanvas&apos;);var ctx = canvas.getContext(&apos;2d&apos;);//没有3d的参数，如果要画3d图要穿webgl。 操作获取了画笔之后，我们就可以真正的开始操作了。 添加线段，描边，填充: 12345ctx.moveTo(100,100);//起笔位置ctx.lineTo(100,100);ctx.lineTo(200,200);//划线，但是没有描边，就看不到ctx.stroke(); //描边，之后就能看出来了ctx.fill(); //填充，首尾连接进行填充颜色，闭合。 来介绍几个属性值： 123ctx.lineWidth = 20 ;//线宽ctx.strokeStyle = &apos;red&apos;; //描边的颜色ctx.stroke() // 闭合路径 这里有个要注意的点就是，填充颜色是从边框的中间开始计算的，例如下图： 看上图，三角形左边的顶点，是从中间开始的，左边顶点是100,100，换过来说，就是stroke的左边中间就是100,100.同理可以得到就是下边顶点也是一样的，从中间开始。这里也有一个问题就是，当利用三条边进行描边的时候，会出现缺口的情况，如下图： 这个就是由于，当闭合路径的时候，两边都是从中间的点开始闭合，这样就会出现一个缺口。这样可以使用另一个属性: 1ctx.closePath(); 它表示从初始点到结束点闭合，这样就不会出现这个情况了。这个图形会闭合。 注意无论是fill和stroke方法都是作用在当前的所有子路径，例如： 12345678910ctx.moveTo(100,100);ctx.lineTo(100,100);ctx.lineTo(200,200);ctx.strokeWidth = &quot;red&quot;; //第一个三角形为红色ctx.moveTo(300,100);ctx.lineTo(400,100);ctx.lineTo(400,200);ctx.closePath();ctx.strokeStyoe = &quot;green&quot;; //第二个三角形为绿色ctx.stroke(); 最后发现最后两个都是绿色的，后面的stroke把前面的覆盖了，更官方的就是，下面的strokeStyle，和fill都是作用在同一个路径下的，它们会使用同一个stroke和fill，所以就是都是绿色的。 于是，我们需要将它们变成不一样的路径，从新开辟一个路径： 1ctx.beginPath() ; 在下一个操作之前，开一个新的路径，就可以了，为了养成良好的编程习惯，每次操作之前，都需要开一个新的路径。 矩形，圆形等1、iObject.rect(起始点x，起始点y，矩形宽度，矩形长度)，最后要使用闭合stroke。 2.iObject.fillRect(起始点x，起始点y，矩形宽度，矩形长度)// 实心的 不用stroke 3.iObject.strokeRect(起始点x，起始点y，矩形宽度，矩形长度y) //空心的 不用stroke 另外还有一点就是，利用fillRect和strokeRect画出来的自带新路径，即与之前的路径都是不一样的。 擦除当前区域1.使用iObject.clearRect(开始清除x,开始清除y,要清除的宽度,要清除的长度) 如果想擦除整个画布，那么就可以以画布的开始点，然后以画布的长宽为参数，那么就可以实现清除画布了。 实现一个矩形落地的效果。画布长宽都是500。 12345678910111213141516171819var canvas = document.getElementById(&apos;mycanvas&apos;);var ctx = canvas.getContext(&apos;2d&apos;);var w = canvas.width, h = canvas.height; var y = 100; ctx.fillStyle = &quot;#f40&quot;;function move(y)&#123; ctx.fillRect(100,y,50,50); &#125;//其实就是画一个矩形，然后清除，再画，再清除var timer = setInterval(function()&#123; ctx.clearRect(0,0,w,h); move(y); y += 20; if(y &gt;= 470)&#123; move(450); clearInterval(timer); &#125;&#125;,500); 就可以得到矩形块下落的效果图。 弧形1.arc(x,y,r,起始弧度，结束弧度，弧形方向) 注意单位是弧度，弧度方向，0表示顺时针，1表示逆时针。例如： 12iObject.arc(250,250,100,Math.PI/100 * 270,0);iObject.stroke() 然后我们来画一个扇形来试试。 1234ctx.moveTo(250,250);ctx.arc(250,250,100,Math.PI/180*0 ,Math.PI/180*300 , 0/1);//0是顺时针，1是逆时针ctx.closePath();ctx.stroke(); 当是顺时针的时候. 当时逆时针的时候： 圆角 ctx.arcTo(x1,y1,x2,y2,r)，这个方法可以绘制一段圆弧，首先，起始点到第一个点（x1，y1），确定一条线段，这条线段可以得到一个圆该圆与改线段相切，之后，第一个点和第二个点（x2，y2）之间确定另外一条线段，于是又能得到一个圆与之相切，于是两条线段和额外一个半径就能确定一个圆，并且是唯一的，于是在两个切点之间能得到一段圆弧，于是圆弧末端跟起始点连城线段就是所求。 起始点（x,y）和第一个点与第二个点之间的切点所连成的曲线段就是所求。 绘制一个圆角矩形： 12345678ctx.beginPath();ctx.moveTo(300, 250);ctx.arcTo(350, 250, 350, 350, 20);ctx.arcTo(350, 350, 250, 350, 20);ctx.arcTo(250, 350, 250, 250, 20);ctx.arcTo(250, 250, 350, 250, 20);ctx.closePath();ctx.stroke(); canvas和svg能开启GPU加速。 贝塞尔曲线12345//二次贝塞尔曲线ctx.beginPath();ctx.moveTo(250, 250);ctx.quadraticCurveTo(300, 200, 400, 400);ctx.stroke(); 这个到时候用到了再去查 坐标轴转换1.translate(dx, dy) 重新映射画布上的 (0,0) 位置,往x轴方向或者y方向平移。 1ctx.translate(200,200)//坐标系的零点就变成原来的200，200点 2.scale(sx, sy) 缩放当前绘图 整个轴都放大缩小 12scale(2,0.5)//x轴变成原来的2倍，y轴变成原来的0.5倍ctx.rect(100,100,100,100) //编程时长方形的，因为y轴变为原来的0.5倍，高也缩小了。整个轴都缩小了 3.rotate(Math.PI) 旋转当前的绘图//传进的是弧度制，以零点为旋转中心。 4.save() restore() 123456789保存当前图像状态的一份拷贝 （保存的是坐标系）从栈中弹出存储的图形状态并恢复什么时候要开始新的坐标轴，就在开始之前保存，然后在用的时候在拿出来。ctx.save()//保存一个正常的坐标系ctx.rotate(Mate.PI/180 *30);//变换ctx.rect(100,100,100,100); //变换之后的坐标ctx.restore() //重新取回坐标系ctx.rect(100,100,100,100) //正常矩形 5、setTransform(a, b, c, d, e, f) 先重置再变换 1参数：水平旋转、水平倾斜、垂直倾斜、垂直缩放、水平移动、垂直移动 transform(a, b, c, d, e, f) 在之前的基础上变换，不进行重置，直接在原来的基础上进行转换。 Canvas 操作填充图案createPattern(image,”repeat/repeat-x/repeat-y/no-repeat”) ，利用这个方法可以对canvas进行填充，第一个参数表示的是填充图片，第二个表示是否充分，（x，y分别表示对应方向上是否单方向重复，类似于css上的背景图重复属性） 12345var canvas = document.getElementById(&apos;myCanvas&quot;);var ctx = canvas.getContext(&apos;2d&apos;);var oImag = document.getElementsByTagName(&apos;img&apos;)[0];ctx.fillStyle = ctx.createPattern(oImag,&apos;no-repeat&apos;);ctx.fillRect(100,100,100,100); 通过这个代码，我们可以发现，最后没有呈现冲填充的图片，因为当我们请求图片的时候，图片返回过来的时候，已经执行完了，所以这个时候会是一个矩形，默认的是黑色，我们需要把图片加载完过来再进行填充。 1234oImag.onload = function()&#123; ctx.fillStyle = ctx.createPattern(oImag,&apos;no-repeat&apos;); ctx.fillRect(0,0,500,500);&#125;//这样就可以正常显示了 第一个参数除了可以传图片，还能传另一个canvas，或者是video（视频播放标签，里面有一个海报标签） 渐变1.createLinearGradient(x1, y1, x2, y2)（起点左边，终点左边）; 线性渐变 必须在填充渐变的区域里定义渐变, 否则 没有效果 1ctx.fillStyle = ctx.createLinearGradient(0,0,0,500)//表示从上往下渐变 2.addColorStop(p, color);利用这个可以进行颜色的渐变，类似于css3的渐变。 (0,yellow)到&gt;(0.5,red)到&gt;(1,green)例如 1234var bg = ctx.createRadialGradient(250,250,200,250,250,100);bg.addColorStop(0,&apos;yellow&apos;);bg.addColorStop(0.5,&apos;red&apos;);bg.addColorStop(1,&apos;green&apos;); 表示，开始为yellow，中间状态为red，末状态是绿色。 3.createRadialGradient(x1, y1, r1, x2, y2, r2);（开始渐变的圆心，开始渐变的半径，解说状态的圆心，结束状态的半径） 径向渐变（圆的渐变），只能做圆的渐变，css3可以进行椭圆的径向渐变。例如： 123456var bg = ctx.createRadialGradient(250,250,200,250,250,100);bg.addColorStop(0,&apos;yellow&apos;);bg.addColorStop(0.5,&apos;red&apos;);bg.addColorStop(1,&apos;green&apos;);ctx.fillStyle = bg;//这个是从外向里开始渐变的，因为开始的时候，半径比末状态的半径大。圆心是一样的。ctx.fillRect(0,0,500,500); 效果如下图： 阴影1.ctx.shadowColor（阴影颜色） 2.ctx.shadowOffsetX （x轴偏移） 3.ctx.shadowOffsetyY（y轴偏移） 4.ctx.shadowBlur（阴影模糊） 12345ctx.shadowColor = &apos;red&apos;;ctx.shadowOffsetX = 20;ctx.shadowOffsetY = 20;ctx.shadowBlur = 0.5;ctx.strokeRect(0,0,500,500);//画出来的是空心的阴影，如果用fillRect，就是实心的。 这里的阴影不受坐标轴的变换而改变。阴影参照的是canvas对象本身，而不是坐标轴。 文本1、fillText()，实心文本 三个参数，文字，开始绘制的x坐标，开始绘制的y左边 2、strokeText()，空心文本 3、measureText(‘hello world’) ,返回一个对象，该对象是以像素计的指定字体宽度。 4、ctx.textAlign();选择文字起始位置。（对齐方式） 线段样式1.lineCap 延伸线段 线宽的一半，lineCap = round;圆角 1234ctx.moveTo(100,100);ctx.lineTo(200,100);ctx.lineWidth = 30;ctx.lineCap = &apos;round&apos;; //让线段伸长现宽的一半，然后变成圆角 2.lineJoin 线段尖角，对于上面的一种情况就是， 两条线结合的时候，如果角度很小，那么他们将会形成一个角度，当角度很小，尖叫就会伸到很长例如下图： 这个时候，浏览器可以使用lineJoin来尖角转化为圆角。 1ctx.lineJoin = &quot;round&quot;;//还有bevel截断） miter尖角）属性值 我们还可以对控制尖角长度控制（lineJoin为miter）用于控制斜街部分的长度。如果斜接部分长度超过miterLimit的值，就会变成bevel. 1ctx.miterLimit = 20;//实际运算是大于limit*lineWidth/2的值，了解就好 裁剪ctx.clip()；当前路径外的区域不再绘制。比如说，我现在在画布上面画了一个圆，以后画的所有东西，只能在圆的那部分才能展示出来。 123ctx.arc(250,250,100,0,Math.PI*2,1);//先画一个圆ctx.clip();//裁剪ctx.fillRect(0,0,250,250);//画一个250的正方形 能看到，只用与圆重合的那部分才能显示出来。 这个还能在clip()之前使用save()来进行状态的保存，然后来restore来恢复状态。 合成 ctx.globalCompositeOperation = ‘source-over’ ;新像素和原像素的合并⽅方式 （层级类似）,以下是它的层叠方式：默认是source-over（根据画的顺序来显示层叠关系）； 123456ctx.globalCompositeOperation = &apos;source-over&apos; ;//先画的在下面ctx.globalCompositeOperation = &apos;destination-over&apos; ;//先的在上面ctx.globalCompositeOperation = &apos;destination-out&apos; ;//显示出第一画的减去重合的部分//做刮刮乐，利用获得鼠标的位置，然后动态的改变第二个图形的圆心位置，每移动一下，显示一个新的画面。 绘制图片全局透明度： 1ctx.globalAlpha = &quot;0.5&quot;; 无论开启多少个新路径，这个属性都会存在。 1.ctx.drawImage(); 第一个参数是img（图片，canvas，video）,注意的是，它也是要等到onload完之后才能进行下一步操作。 第二个参数是图片的起始点坐标，理解为图片摆放位置 第三个参数是想获取的宽高，分别是想获取的起点，终点 1234oImg.onload = function()&#123; ctx.drawImage(imgae,100,100,200,200,100,100,50,50); //从100,100点开始，划到200，200位置，从图片的100,100位置获取50高，50宽 &#125; 导出canvas内容1.canvas.toDataURL() ; 是canvas自身的方法不是上下文对象 2、将canvas的内容抽取成一张图片, base64编码格式，通过绘制每一个点的rega，直接画出图片，不需要联网也可以。如果想得到这些编码，是需要在服务器中获取的，因为它会认为你是在获取别人的数据，所以要走服务器。 3、oImg.onload = function(){ ctx.drawImage(oImg,100,100,200,200); console.log(canvas.toDataURL()) //报错，同源策略限制 4、将canvas的内容放入img元素里（不走浏览器请求，直接渲染） 1var base64 = canvas.toDataURL(); oImg.src = base64; //将canvas转换为图片 通过这个步骤可以对图片进行操作。拿到一张图，通过drawImage的方式，放到canvas里面去，然后获取这张图片上面的每一像素点的信息，然后再将整个抽出来。 ctx.getImageData(0，0,500,500)，获取每一个点的像素信息。里面有个data对象，获取了250000个像素点，每个像素的有四个信息，于是就有1000000个信息。 ctx.createImageData(),创建新的空白 ImageData 对象，用来放置处理过的data。 ctx.putImageData(imgData, x, y) 将图像数据放回画布上 利用这些方法，处理出高斯模糊。 思路： 123451，通过drawImage，画出图画2，得到图像数据，getImageData()3, 将得出来的data放到高斯函数，得到返还结果data4，将处理的结果利用putImageData重新放到canvas里面5，toDataURL() ,抽出来64。最后获得canvas代码 例如，将一个黑色的方块变成灰色的方块图形： 1234567891011121314151617//将黑色变成灰色ctx.fillRect(0, 0, 100, 100);var pixel = ctx.getImageData(0, 0, 100, 100);var row = pixel.width;var col = pixel.height;var d = pixel.data;//对数据进行处理，变成灰色for(var i = 0; i &lt; row; i++) &#123; var c = i * col * 4; for(var j = 0; j &lt; col; j++) &#123; d[c + j * 4 + 3] = 100; &#125;&#125;ctx.putImageData(pixel, 100, 100); 得到如下图所示： 命中检测1.ctx.isPointInPath(x, y)；检测是否在区域内,在就返回true，不在返回false。 12345678ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(200,100);ctx.lineTo(200,200);ctx.closePath();ctx.stroke();console.log(ctx.isPointInPath(150,150)); //trueconsole.log(ctx.isPointInPath(148,159)); // false; 2.ctx.isPointInStroke(x, y)；检测是否在线上 3、还可以通过检测当前点的像素值，如果为透明，则该点不再路径上。 非零绕数准则判断点p是否在多边形内，从点p向外做一条射线（可以任意方向），多边形的边从左到右经过射线时环绕数减1，多边形的边从右往左经过射线时环绕数加1，最后环数不为0，即表示在多边形内部。 解决canvas放大模糊问题在分辨率比较高的屏幕，例如ip6/6s/mac等机器上，因为canvas绘制的是位图，所以会导致模糊，解决方法是根据屏幕分辨率修改canvas样式代码中的宽和高与canvas的width和height属性的比例。例如： 123456789canvas&#123; border: 1px solid #000; width：300px; height: 300px;&#125;//在style里面写的canvas相当于相框&lt;canvas id=&quot;myCanvas&quot; width=500 height=500&gt;&lt;/canvas&gt;//这里的是相对值，如果style没有设定canvas的宽高//默认是像素作单位，现在已经style设定了width和height，那么，就是500指的就这个框为500个单位，相对的//小相框，大画布 那么，当我们把这个画布放进去之后就是清晰的。如果相反，我们使用大相框，小画布，例如： 1&lt;canvas width=100 height=100&gt;&lt;/canvas&gt; 那么就会显得非常模糊，因为这就相当于把100放大到300之后放进相框里面，导致失真。 好吧，那么关于HTML5中的canvas的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://moreluckily.com/categories/HTML5/"}],"tags":[{"name":"-HTML5","slug":"HTML5","permalink":"http://moreluckily.com/tags/HTML5/"}]},{"title":"CSS3学习6","slug":"CSS3学习6","date":"2018-10-11T16:28:27.000Z","updated":"2018-10-23T02:43:15.474Z","comments":true,"path":"2018/10/12/CSS3学习6/","link":"","permalink":"http://moreluckily.com/2018/10/12/CSS3学习6/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习CSS3。 今天首先要讲一下Bootstrap。 什么是Bootstrap?首先什么是Bootstrap呢？ Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。[1] 它由Twitter的设计师Mark Otto和Jacob Thornton合作开发，是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。Bootstrap一经推出后颇受欢迎，一直是GitHub上的热门开源项目，包括NASA的MSNBC（微软全国广播公司）的Breaking News都使用了该项目。[2] 国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来。 说到底，它就是一个特别好用的框架。 Bootstrap的技术特点Bootstrap是基于HTML5和CSS3开发的，它在jQuery的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件 Bootstrap中包含了丰富的Web组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站。其中包括以下组件：下拉菜单、按钮组、按钮下拉菜单、导航、导航条、路径导航、分页、排版、缩略图、警告对话框、进度条、媒体对象等 Less css预处理器 先不做解释 Bootstrap特色适应各种技术水平Bootstrap适应不同技术水平的从业者，无论是设计师，还是程序开发人员，不管是骨灰级别的大牛，还是刚入门槛的菜鸟。使用Bootstrap既能开发简单的小东西，也能构造更为复杂的应用。 跨设备、跨浏览器最初设想的Bootstrap只支持现代浏览器，不过新版本已经能支持所有主流浏览器，甚至包括IE7。从Bootstrap 2开始，提供对平板和智能手机的支持。 支持响应式设计从Bootstrap 2开始，提供完整的响应式特性。所有的组件都能根据分辨率和设备灵活缩放，从而提供一致性的用户体验。 选用LESS构建动态样式当传统的枯燥CSS写法止步不前时，LESS技术横空出世。LESS使用变量、嵌套、操作、混合编码，帮助用户花费很小的时间成本，编写更快、更灵活的CSS。当然还有很多优势。 尝试使用Bootstrap先介绍一下前端的开发流程，大致可以分为三个阶段： 第一阶段： 前端工程建设的第一项任务就是根据项目特征进行技术选型。基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。 第二阶段： 简单构建：优化选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种前端自动化构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 第三阶段： JS/CSS模块化：开发分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。 第四阶段：组件化开发 分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求： 解释一下上面这个图的特点： 页面上的每一个独立的 可视/可交互区域都是一个组件 每个组件对应一个目录，组件所需的各种资源（img 字体等 js css html）都在这个目录下 组件具有独立性，互不影响可以自由组合 页面只不过是组件的容器而已，负责组合组件形成功能完整的界面; 我们可以想象成 我们要组装一辆车 所以的零件（组件）都准备完毕只需我们利用这些零件进行拼装就好 某一个零件（组件）的损耗不会影响其他零件（组件） 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分： 由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发 Bootstrap下载使用我们直接在百度中搜索Bootstrap，进入它的中文官网就可以下载Bootstrap，解压之后放在我们的项目文件中我们就可以直接使用了。 首先我们需要引入2个CSS文件： 12&lt;link rel=&quot;stylesheet&quot; href=&quot;./../bootstrap/css/bootstrap.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./../bootstrap/css/bootstrap-theme.css&quot;&gt; 这样它的CSS文件我们都可以使用了，举个例子，用一下它里面封装好的。直接复制粘贴就好了。 1&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（首选项）Primary&lt;/button&gt; 就能得到如下图所示的效果了，和官网上显示的样式是一模一样的。 当然官网上也介绍了，如果在class中再加入一个属性值： 12btn-lg//会使按钮变大，具体的看官网，基本什么都有&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（首选项）Primary&lt;/button&gt; 下拉菜单接下来介绍一下官网里的下拉菜单。 由于要用到JS中的代码。首先要引入2个JS文件，一个是jQuery的JS文件，一个是它本身的JS文件。 12&lt;script src=&quot;./jquery-3.2.1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./../bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt; 在官网中找到相关的代码，复制粘贴即可： 12345678910111213&lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-default dropdown-toggle&quot; type=&quot;button&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;true&quot;&gt; Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 就可以得到如下图所示的效果了。 这里面的span是那个小三角形，这个图像也可以换，那我们来换一个吧。 1&lt;span class=&quot;glyphicon glyphicon-save&quot;&gt;&lt;/span&gt; 可以得到如下图所示的情况： 是不是很神奇，还有很多种样式都可以在其中找到。 当然还有很多，例如栅格系统等等，在这里就不多介绍了。 好吧，那么关于Bootstrap的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://moreluckily.com/categories/CSS3/"}],"tags":[{"name":"-CSS3","slug":"CSS3","permalink":"http://moreluckily.com/tags/CSS3/"}]},{"title":"算法学习1","slug":"算法学习1","date":"2018-10-11T14:59:47.000Z","updated":"2018-10-23T02:43:15.646Z","comments":true,"path":"2018/10/11/算法学习1/","link":"","permalink":"http://moreluckily.com/2018/10/11/算法学习1/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习一下算法方面的知识。 首先什么是算法呢？ 什么是算法？有人概括的说： 1程序 = 数据结构 + 算法 这是以前的一个比较常见的说法，现在基本还是比较实用的。 那现在概括的来说，什么是程序呢？ 可以这样来理解： 1程序 = 数据结构 + 算法 + 操作系统 + 网络 数据结构那我先来介绍一下什么是数据结构。 我的理解是这样的： 123456数据结构：1、线性数据结构数组 链表2、非线性图：树是图的一种。 树：有向无环图 数组数组在C语言中，经常是这样写的： 123int a[] = [1,2];a[0] = 1，//这个0就是偏移量， 所以C语言中数组的特点是： 1231、定长2、连续3、起点固定 而JS中的数组是不定长的，可以有push(),pop(),shift(),unshift()等多种方法。所以JS数组的特点就是： 1231、不定长（push可以加,pop可以减）2、连续3、起点不固定（unshift可以加，shift可以减） 经典的算法题例题：使用2个栈形成一个队列。 我们先来分析一下：栈是先进后出，队列是先进先出。我们可以用一个栈来放数据，另一个队列来出数据，画个图来分析一下： 1234567891011121314151617181920var left =[];var right = [];function put(x) &#123; left.push(x);&#125;function pop() &#123; //left--&gt;right var leftLength = left.length; for(var i = 0; i &lt; leftLength; i++) &#123; right.push(left.pop()); &#125; //get a member var result = right.pop(); //还原left var rightLength = right.length; for(var i = 0; i &lt; rightLength; i++) &#123; left.push(right.pop()); &#125; return result;&#125; 这是只有JS才有这么方便的解法。 得到结果： 再看这样一道例题： 求一个随机的数组中最大值和最小值的差。 首先想到的是ES6中的一种方法 12345var arr = [2,3,4,56,7,8,9,4];function test(arr) &#123; return Math.max(...arr) - Math.min(...arr);//ES6里的&#125;console.log(test(arr));//54 这样可以特别方便的得到结果。 还有一种方法是JS中原生的一种方法。apply方法，后面要放一个数组： 123456var arr = [2,3,4,56,7,8,9,4];function test(arr) &#123;return Math.max.apply(null,arr) - Math.min.apply(null,arr);&#125;console.log(test(arr));//54 算法真的太神奇了。 再来看下一道题：1到100共100个数乱序，拿走一个，求拿走的是啥。 将所有的数求和，最后拿1到100相加减去这个和，就得到这个数 第4道题： 一个大数组，所有的数都是成对出现的，只有一个孤独的数，求这个数。 这里利用一个异或的原理，即相同即为0。0环绕一个数异或的这个数本身。 举个例子： 12345678910var arr = [1,1,2,2,3]function test(arr) &#123; //异或 var result = 0; for(var i = 0; i&lt; arr.length;i++) &#123; result ^= arr[i];//异或符号 &#125; return result; &#125;console.log(test(arr));//3 再看下一道题： 如何打乱数组： 12345678910var arr = [1,2,3,4,5,6,7,8,9,10];function test(arr) &#123; if (arr &amp;&amp; !(arr instanceof Array)) return -1; //要严谨 arr.sort(function () &#123; return Math.random() &gt; 0.5 ? 1 : -1; &#125;);&#125;test(arr);console.log(arr); 一定要严谨 12345678910var x = &#123;a:1&#125;;function f(x) &#123; if(x &amp;&amp; x.a &amp;&amp; x.a == 1)&#123; //要严谨 console.log(&apos;yes&apos;); &#125;else&#123; console.log(&apos;no&apos;); &#125;&#125;f(x); 链表如何创建一个链表呢？ 用next来创建 1234567891011function A(value, next) &#123; this.value = value; this.next = next;&#125;var a = new A(1, null);var b = new A(2, null);var c = new A(3, null);a.next = b;b.next = c;//这就形成了链表 a--&gt;b--&gt;c 这是一个单向链表，其特点是： 121、不知所长2、内存不连续 那如何使链表逆序呢？ 这就要遵循一个规则，不多不断。 第一步，找到C，让C指向b, 123456789101112function text(x, me) &#123; if(x.next != null) &#123; var result = text(x.next, x); x.next = me; //告诉其上家是谁 return result; &#125;else &#123; x.next = me; return x; &#125;&#125;text(a, null);//这里有一个递归，能使链表逆向 在这里讲一下数组和链表的区别. 数组插入两边: 12C语言极难JS简单 数组插入中间: 12C语言极难JS一般 而单向链表：（JS和C语言基本一样） 插入中间和两边都简单，故频繁的插入数据使用链表。 读取数据呢？ 读取固定位置时，数组角简单，而链表一般（用几遍next就行） 读取不固定位置呢？数组和链表都一样，都一般，从头到尾走一遍即可。 还有一个问题： &amp;&amp;和| | 哪个优先级高呢？ &amp;&amp;的优先级高于 | |，例如： 1false || true &amp;&amp; false || true 相当于： 12false || false || true//true 拓扑结构拓扑结构：只研究关系，不研究位置。 例如： 这两个二叉树是全等的。 树：有向无环图。 二叉树：最多有2个孩子节点 还分为根节点，节点和叶子节点。 有几种常见的二叉树： 平衡二叉树其定义是：1、一颗子树比另一颗子树最多多一层2、其下每个子树都要满足1中的条件。 满二叉树这个比较重要，分为中国的定义和国际的定义。 中国的定义：所有叶子节点在同一层 国际的定义：任何一个节点要么有2个节点，要么一个也没有。 例如： 第一个是中国的，第二个是国际的。 完全二叉树叶子节点在同一侧。 例如： 第一个和第二个是，而第三个不是。 二叉树遍历分为前序，中序，后序。 来一个二叉树： 例如： 123456789101112131415161718192021222324252627function Node(value, left, right) &#123; this.value = value; this.left = left; this.right = right; &#125; var n1 = new Node(1, null, null); var n2 = new Node(2, null, null); var n3 = new Node(3, null, null); var n4 = new Node(4, null, null); var n5 = new Node(5, null, null); var n6 = new Node(6, null, null); n1.left = n2; n1.right = n3; n2.left = n4; n3.left = n5; n3.right = n6; function qianxu(node) &#123; if (node == null) &#123; return; &#125; console.log(node.value); //放前面就是前序，中间是中序，后面是后序 qianxu(node.left); qianxu(node.right); &#125; qianxu(n1);//124356 中序遍历最重要 可以将其补成满二叉树，再去存取数据。 好吧，那么关于算法学习的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"算法","slug":"算法","permalink":"http://moreluckily.com/categories/算法/"}],"tags":[{"name":"-算法","slug":"算法","permalink":"http://moreluckily.com/tags/算法/"}]},{"title":"CSS3学习5","slug":"CSS3学习5","date":"2018-10-11T09:27:57.000Z","updated":"2018-10-23T02:43:15.459Z","comments":true,"path":"2018/10/11/CSS3学习5/","link":"","permalink":"http://moreluckily.com/2018/10/11/CSS3学习5/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习CSS3。 今天首先要讲一下CSS3中的多列布局。 模拟移动端meta这段代码解释一下: 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 3D动画之前得动画效果都是2d的，接下来开始讲3d的。 相关属性介绍 如果要让一个元素成为3d元素，需要有这个属性： 1transform-style: flat/preserve-3d; 要注意的是，transform-style 属性需要设置在父元素中, 高于任何嵌套的变形元素。 设置了transform-style:preserve-3d的元素，就不能防止子元素溢出设置overflow：hidden；否则会导致preserve-3d失效。 第二个就需要了解一个叫景深的东西。perspective»&gt;景深。 可以简单的把perspective理解成人距离显示器的距离，此值越大的效果越差 越小效果越好 （就相当于越远，也不清晰，越近越清晰） 假设你距离100米和1米的距离去看一个边长一米的正方体，重点记住perspective的值要大于3d物体的值。就是说设定的景深必须在父级的大小的范围之内。而且就是，景深必须是设定在父元素上面。例如： 123456789101112.wrapper &#123; width: 300px; height: 300px; perspective: 1200px; &#125; .wrapper .box&#123; width: 300px; height: 300px; transform-style: preserve-3d; transform: translateZ(300px);//越大离得越近，视觉效果越大 background: red; &#125; 在3D变形中，除了perspective属性可以激活一个3D空间之外，在3D变形的函数中的perspective()也可以激活3D空间。他们不同的地方是:perspective用在舞台元素上（变形元素们的共同父元素）;perspective()就是用在当前变形元素上，并且可以与其他的transform函数一起使用。 123456 .stage&#123; perspective: 600px;&#125;.stage .box&#123; transform: perspective(600px);&#125; 12.backface-visibility: visible hidden 反面隐藏 3d 立方体现在我们要实现一个需求就是，我们需要让一个立方体动起来，有一个3d的效果。这个时候，如果一个一个设定六个面的话，让每个面单独转是很麻烦的，我们需要转化一下思想，我们把六个面让一个div包起来，然后让div转动，即可有里面的东西在动的感觉。 然后有个东西要注意的是，两个相同的元素, 其中一个设置了rotateY(180deg), 然后同时设置translateZ(100px)；这时, 他们在空间的距离是200px。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364.wrapper&#123; perspective:1200px; width: 300px; height: 300px;&#125;.wrapper .box&#123; position: absolute; top: 50%; left: 50%; margin-top: -100px; margin-left: -100px; width: 200px; height: 200px; animation: move 5s linear infinite; transform-style: preserve-3d;&#125;.wrapper .box div&#123; width: 200px; height: 200px; position: absolute; font-size: 50px; color:#fff; line-height: 200px; text-align: center; opacity: 0.7;&#125;.wrapper .box div:nth-of-type(1)&#123; background: red; transform: translateZ(100px);&#125;.wrapper .box div:nth-of-type(2)&#123; background: green; transform: rotateX(180deg) translateZ(100px); &#125;.wrapper .box div:nth-of-type(3)&#123; background: yellow; transform: rotateY(90deg) translateZ(100px); &#125;.wrapper .box div:nth-of-type(4)&#123; background: orange; transform: rotateY(-90deg) translateZ(100px); &#125;.wrapper .box div:nth-of-type(5)&#123; background: deeppink; transform: rotateX(90deg) translateZ(100px); &#125;.wrapper .box div:nth-of-type(6)&#123; background: blue; transform: rotateX(-90deg) translateZ(100px); &#125;@keyframes move&#123; 0%&#123; transform: rotateX(0deg) rotateY(0deg); &#125; 100%&#123; transform: rotateX(360deg) rotateY(360deg); &#125;&#125; 12345678910&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 可以得到这样的效果： 它是在旋转的。 CSS3动画性能优化1、尽可能多的利用硬件能力，如使用3D变形来开启GPU加速 2.如动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack： 12345678-webkit-backface-visibility: hidden;-moz-backface-visibility: hidden;-ms-backface-visibility: hidden;backface-visibility: hidden;-webkit-perspective: 1000;-moz-perspective: 1000;-ms-perspective: 1000;perspective: 1000; 3.尽可能少的使用box-shadows与gradients, 这两个都是页面性能杀手，能避免尽量避免 4.尽可能的让动画元素不在文档流中，以减少重排 12position: fixed;position: absolute; 5.优化 DOM layout 性能 响应式布局响应式布局是一个运用了多种技术的集合总称，包括弹性盒子，媒体查询等。我们今天要讲的是媒体查询。 媒体查询（Media Queries）媒体查询是为了兼容不同大小的屏幕，为用户提供最佳的体验而生的。它向不同的设备提供不同样式。作为css3规范的一部分，媒体查询扩展了media属性（控制样式应用方式）的角色。它最大的特色就是通过CSS3来查询媒体，然后调用对应的样式。 随着网络技术的迅速发展，动设备的快速普及完全颠覆了Web设计领域。用户不再仅在传统桌面系统上查看Web内容，他们越来越多地使用具有各种尺寸的智能电话、平板电脑和其他设备。Web设计人员的挑战是确保他们的网站不仅在大屏幕上看起来不错，在小型的电话以及介于它们之间的各种设备上看起来也不错。 Link 和 @media 使用方法1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-width: 600px)&quot; href=&quot;small.css&quot; /&gt; 这个简单的实例引出两个概念性的东西，一个就是媒体类型（Media Type all(全部)、screen(屏幕)、print(页面打印或打印预览模式)）和 媒体特性（Media Query）。 但是，通常不会采用单独引入一个css样式表一位每次的请求都是很耗时间的，而且，当要配置多个设备的时候，css文件会很多，所以我们只会把特定的代码，写在css文件的media里面： 1234567@media screen and (max-width: 600px)&#123; div&#123; width: 200px; height: 200px; background: black; &#125;&#125; 这样就可以获的一样的效果。 以下是设备表： 以下是特定场景： 例如： 1234567@media screen and (orientation:portrait)&#123;//当屏幕为竖屏的时候走这个样式 item&#123; width: 200px; height: 200px; background: red; &#125;&#125; 指定备用功能Media Query是CSS3 对Media Type的增强版，其实可以将Media Query看成Media Type(判断条件)+CSS(符合条件的样式规则) 12&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (min-device-width:241px) and (max-device-width:360px)&quot; href=&quot;android360.css&quot; type=&quot;text/css&quot; /&gt;//（匹配设配在 最大宽度 和最小宽度 之间） 可以换一种写法：在html页面中引入css文件 12345&lt;link media=&quot;screen and (max-width: 600px)&quot; href=&quot;css3-5.css&quot;&gt;css里面有这样的代码@media all and (max-width :1000px) and (min-width: 600px) &#123;................&#125; 这段代码，表示，当屏幕尺寸大于600，小于1000的时候将会采用代码内的样式。 备用功能： 1media=&quot;screen and (min-width: 769px), print and (min-width: 6in)&quot; 要注意的是：没有or关键词可用于指定备用的媒体功能。相反，可以将备用功能以逗号分割列表的形式列出，这会将样式应用到宽度超过769像素的屏幕或使用至少6英寸宽的纸张的打印设备。 指定否定条件： 1media=&quot;not screen and (monochrome)&quot; 如果要指定否定条件，可以在媒体声明中添加关键字not，不能在单个条件前使用not。该关键字必须位于声明的开头，而且它会否定整个声明。所以，上面的示例会应用于除单色屏幕外的所有设备。 向前兼容浏览器only用来定某种特定的媒体类型，可以用来排除不支持媒体查询的浏览器。其实only很多时候是用来对那些不支持Media Query但却支持Media Type的设备隐藏样式表的。其主要有：支持媒体特性（Media Queries）的设备，正常调用样式，此时就当only不存在；对于不支持媒体特性(Media Queries)但又支持媒体类型(Media Type)的设备，这样就会不读了样式，因为其先读only而不是screen；另外不支持Media Qqueries的浏览器，不论是否支持only，样式都不会被采用。 1media=&quot;only screen and (min-width: 401px) and (max-width: 600px)&quot; 原理： 早期浏览器应该将以下语句 1media=&quot;screen and (min-width: 401px) and (max-width: 600px)&quot; 解释为media=”screen”： 换句话说，它应该将样式规则应用于所有屏幕设备，即使它不知道媒体查询的含义。无法识别媒体查询的浏览器要求获得逗号分割的媒体类型列表，规范要求，它们应该在第一个不是连字符的非数字字母字符之前截断每个值。所以，早期浏览器应该将上面的示例解释为：media=”only” 。 因为没有only这样的媒体类型，所以样式表被忽略。 易混淆的宽度device-width/height width/height来做为的判定值。 device-width/height 是设备的宽度（如电脑手机的宽度 不是浏览器的宽度） width/height使用documentElement.clientWidth/Height即viewport的值。 来个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243*&#123; margin: 0px; padding: 0px; font-size: 0px;&#125;div&#123; width:100%; height:auto;;&#125;@media screen and (max-width: 1000px)&#123; .item&#123; width:30%; height: 100px; border:1px solid black; float: left; flex-flow: 1; &#125;&#125;@media screen and (min-width: 1001px )&#123; .item&#123; width:20%; height: 100px; border:1px solid black; float: left; &#125;&#125;@media screen and (max-width: 600px )&#123; .item&#123; width:40%; height: 100px; border:1px solid black; float: left; &#125;&#125;&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;item&quot;&gt;*10&lt;/div&gt; 性能优化物理像素 和 设备独立像素一个物理像素是显示器（手机屏幕）上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素（也叫目睹无关像素），可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素（css像素），然后由相关系统转换为物理像素 设备像素比（device pixel ratio）设备像素比（简称dpr）定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到 设备像素比 = 物理像素 / 设备独立像素 js中可以通过 window.devicePixelRatio 简单来说，我们在css设置的1px，在不同设备有不同效果，分辨率越高，1px里面有更多的物理像素，成像更清晰，分别率越低，1px里面的物理像素越少，那么成像就会模糊。 那我们再来举个例子： 121.设备宽高为375*667，可以理解为设备独立像素（或css像素）2.dpr为2，根据上面的计算公式，其物理像素就应该 *2 ，为750*1334. 1css像素在PC端显示器需要用（11）个栅格点表示 在iPhone6中则需要4（22）个 也就是在不同的屏幕上（普通屏幕 vs retina屏幕），css像素所呈现的大小（物理尺寸）是一致的，不同的是一个css像素所对象的物理像素个数是不一致 在普通的屏幕下，1个css像素对应的1个物理像素 为1:1 。在retina屏幕下，1个css像素对应4个物理像素 1:4 位图像素1个位图像素是栅格图像（如：png，jpg，gif等）最小的数据单元。每一个位图像素都包含这一些资深的现实信息（如：显示位置，颜色值，透明度等）,在普通屏幕下是没问题的，但是在retina屏幕下就会出现位图像素点不够，从而导致图片模糊的情况. 解决办法使用分辨率大两倍的图片 如200300 img 标签，就需要提供400600的图片.由此一来位图像素点的个数是原来的4倍，在retina屏幕下，位图像素点个数就可以物理像素点个数形成1:1 的比例，图片自然就清晰了。 位图当放大时是会失真的，而矢量图在放大时不会发生失真。 浏览器渲染原理再讲优化之前，要先讲一下浏览器的渲染原理，具体有以下几步： 123451.处理HTML 生成DOM树2.处理CSS 生成CSSDOM树3.将两树合并成render 树4.对render树进行布局计算5.将render树中的每一个节点绘制到屏幕上 细化分析： 1.浏览器把获取到的html代码解析成1个Dom树，html中的每个tag都是Dom树中的1个节点，根节点就是我们常用的document对象(html tag)，当然这里包含用js动态创建的dom节点。 2浏览器把所有样式(主要包括css和浏览器的默认样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，生成CSSDOM树 3.DOM tree和CSSDOM tree 合并成 render tree，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有无样式head节点)，因为这些节点不会用于呈现，而且不会影响呈现的。 注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。 4.render tree构建完毕之后根据样式计算布局，布局阶段的输出结果称为 “盒模型”（box model）。盒模型精确表达了窗口中每个元素的位置和大小，而且所有的相对的度量单位都被转化成了屏幕上的绝对像素位置 (根据css2的标准，render tree中的每个节点都称为box(Box dimensions—-盒子模型)。 1box所有属性：width,height,margin,padding,left,top,border等。) 5.将这些信息渲染为屏幕上每个真实的像素点了。这个阶段称为“绘制”，或者“栅格化”（rasterizing）。 如图： 注意图中的span标签，再生成render tree的时候，它是不占结构的因为他在csstree中是none，要和visibility：hidden做区别，前者是不占结构，后者是占用结构的。 重绘和重排1.我们计算它们在当前设备中准确的位置和尺寸。这正是布局阶段要做的的工作，该阶段在英语中也被称为“回流”（reflow），当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。也会回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。 2.重绘（repaints）当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 每次重绘重排都是会耗时间的，我们测试一下(控制台performance可以检测出)，那个更加耗时间。 1234蓝色：网络通信和HTML解析黄色：JavaScript执行紫色：样式计算和布局，即重排绿色：重绘 可以看到，重排的时间更加长，所以他也更加耗性能。所以我们需要减少重排的次数。 触发重排的方法以下这些属性和方法需要返回最新的布局信息，重新计算渲染树，就会造成回流，触发重排以返回正确的值。建议将他们合并到一起操作，可以减少回流的次数。这些属性包括： 12345获取值：offsetTop、offsetLeft、 offsetWidth、offsetHeight；scrollTop、scrollLeft、scrollWidth、scrollHeight；clientTop、clientLeft、clientWidth、clientHeight；getComputedStyle() 、currentStyle()。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。 DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染. 12345div.style.color = &apos;red&apos;;div.style.background=&apos;yellow&apos;;div.style.left = &apos;10px&apos;;div.style.width = &apos;20px&apos;;//以上几个都是一起执行的（写操作） 但是浏览器只会触发一次重排和重绘。 一般来说，样式的写操作之后，如果有上面那些属性的读操作，都会引发浏览器立即重排，这种重排，不会形成之前队列优化，就是说，读写会分开操作。 1234567891011121314151617div.style.color = &apos;red&apos;;var height = div.offseHeight;div.style.height = height + &apos;px&apos;;Bad：div.style.left = div.offsetLeft + &apos;px&apos;;（读写一起操作）div.style.top = div.offsetTop + &apos;px&apos;;（读写一起操作）重排重绘两次Good:Var left = div.offsetLeft + &apos;px&apos;;Var top = div.offsetTop + &apos;px&apos;;（读）div.style.left = left;div.style.top = top;（写）放到队列一次执行重排重绘一次 来个明显一点的对比： 12345678910111213141516171819var colorArr = [&apos;red&apos;,&apos;green&apos;,&apos;yellow&apos;,&apos;deeppink&apos;];for(var i = 0; i &lt; 1000; i++)&#123; var oli = document.createElement(&apos;li&apos;); oul.appendChild(oli); oli.style.backgroundColor = colorArr[i%4]; oli.style.width = oli.offsetWidth + 100 + &apos;px&apos;; oli.style.height = oli.offsetHeight + 30 + &apos;px&apos;;&#125;var colorArr = [&apos;red&apos;,&apos;green&apos;,&apos;yellow&apos;,&apos;deeppink&apos;];for(var i = 0; i &lt; 1000; i++)&#123; var oli = document.createElement(&apos;li&apos;); oul.appendChild(oli); var width = oli.offsetWidth + 100 + &apos;px&apos;; var height = oli.offsetHeight + 30 + &apos;px&apos;; oli.style.backgroundColor = colorArr[i%4]; oli.style.width = width; oli.style.height = height;&#125; 第一种和第二种差距: 一个效果就差了这么多了。 理论上的解决优化办法1.总结，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。 2.离线操作DOM 如使用隐藏元素，使用文档碎片document.createDocumentFragment()，cloneNode 文档碎片，相当于一个篮子，先往篮子里面放东西，最后再放进渲染树。 1234567891011var oFrag = document.createDocuentFragment();for(var i = 0; i &lt; 1000; i++)&#123; var oli = document.createElement(&apos;li&apos;); oFrag.appendChild(oli); var width = oli.offsetWidth + 100 + &apos;px&apos;; var height = oli.offsetHeight + 30 + &apos;px&apos;; oli.style.backgroundColor = colorArr[i%4]; oli.style.width = width; oli.style.height = height;&#125;oul.appednChild(oFrag); 效果是： 这个就更加明显了，文档碎片不占用文档结构。 3.修改样式的时候添加类名，或一次性添加到 dom.style.cssText上等. 1div.style.cssText = &quot;padding=10px;border:1px&quot;;//最后统一添加到样式当中。 记住这些都是理论上加速的方法 好吧，那么关于CSS3学习的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://moreluckily.com/categories/CSS3/"}],"tags":[{"name":"-CSS3","slug":"CSS3","permalink":"http://moreluckily.com/tags/CSS3/"}]},{"title":"CSS3学习4","slug":"CSS3学习4","date":"2018-10-10T16:02:00.000Z","updated":"2018-10-23T02:43:15.443Z","comments":true,"path":"2018/10/11/CSS3学习4/","link":"","permalink":"http://moreluckily.com/2018/10/11/CSS3学习4/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习CSS3。 今天首先要讲一下CSS3中的多列布局。 clumns 多列布局为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局模块（CSS Multi Column Layout Module）。它主要应用在文本的多列布局方面，这种布局在报纸和杂志上都使用了几十年了，但要在Web页面上实现这样的效果还是有相当大的难度，庆幸的是，CSS3的多列布局可以轻松实现。 语法： 1.columns: column-width 或者 column-count; 12column-width: //指每一列的宽度 根据容器宽度自适应 （最小宽度） column-count: //指规定的列数 唯一精准的是列数，但是不要两一起使用 会乱 来个例子： 123456789101112div&#123; width: 600px; height: 300px; border: 1px solid #000; column-count: 3;&#125;第二种：div&#123; width: 600px; border: 1px solid #000; colum-width:200px;&#125; 第一种： 第二种： 可以看到，第二种使用width来分列的，column-width指的是最小值，只要不小于设定值即可。 这两个值不要设定在一起使用，会发生混乱。 3.column-gap: 设置列与列之间的宽度，直接用数值表示。默认列宽跟字体大小是一样的。设置为0也是会有宽度，但是很小。 4.column-rule: 列宽缝间添加一条分解析。不占列宽。如果太大会把字体覆盖。 column-rule-width: 类似于borde-width属性，主要来定义列边框的宽度，默认为‘medium’， column-rule-width属性接受任意浮点数，但不接收负值。但也像border-width属性一样，可以使用关键词：medium、thick和thin column-rule-style: 类似于border-style属性，主要用来定义列边框样式，其默认值为“none”。column-rule-style属性值与border-style属值相同，包括none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset。 column-rule-color: 分界线的颜色 5.column-span: 1/all 设置多列布局元素内的子元素，可以跨列，类似标题效果。即一个新闻标题要横跨所有内容列。注：此属性要在子元素上设置。例如： 123456789101112.newspaper&#123; -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari and Chrome */ column-count:3;&#125;h2&#123; -webkit-column-span:all; /* Chrome */ column-span:all;&#125;&lt;div class=&quot;newspaper&quot;&gt; &lt;h2&gt;成品油价格25日凌晨上调 汽柴油涨300、290元/吨&lt;/h2&gt;省略新闻内容。。。。。。&lt;/div&gt; 效果如图： css hack首先介绍一下什么是css hack，由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。 那么，再讲这里涉及到的hack问题。 存在这么一种情况，看一下代码（内容省略）： 123456&lt;div class=&quot;aaa&quot;&gt;内容省略&lt;/div&gt; div[class*=&quot;aaa&quot;]&#123; width:400px; height: 600px; column-width:200px;&#125; 我们设定了200的列宽，但是因为列缝的存在，使得，在400的容器内装不下两列的文字，于是它就自动设定为一列的宽度，并沾满整个容器。 解决办法: column-width = (width-(n-1)font-size)/n /其中n大于或等于2;并且其他值为默认值 如当n为2 时 所设置的column-width 大于上面公式算出的值 那么 就会变成1列 （Opera下最好再减1个px，当然如果你是中文的话也最好这样做，减1-2px，至于为什么，我也说不清楚。） 第二种情况就是这样的： 12345678910111213div[class*=&quot;aaa&quot;]&#123; width: 400px; border: 1px solid #008000; -moz-column-width: 195px; -webkit-column-width: 195px; column-width: 195px; -moz-column-gap: 0; -webkit-column-gap: 0; column-gap: 0; -moz-column-rule: 0 none; -webkit-column-rule: 0 none; column-rule: 0 none; &#125; 可以看出，文字部分为了填补gap的空隙，自动撑开到200px了。这个时候，解决方式还是需要通过计算，确定适合的值。 盒模型在css中盒模型被分为两种，第一种是w3c的标准盒模型，另一种是IE6混杂模式的传统模型。他们都是对元素计算尺寸的模型。但他们的不同是计算的方式不同。 1.W3C标准盒模型 12element空间高度（盒子） = width + padding + border;width 为内容高度。即width不包括padding 和 border 2.IE6混杂模式盒模型 12内容高度 （盒子）= width - padding - border即 设置width的数值就是element 的空间高度，width包含padding 和border 这个时候，如果我们想将这两个盒子模型，一个用混杂模式，一个用标准模式，就需要用到一下这个方法了。 css3中有一个可以选择盒模型的属性。 1234box-sizing : border-box/content-boxcontent-box为W3C标准盒子border-box为IE6混杂模式的盒子 来个例子： 123456789101112div&#123; width:100px; height:100px; padding: 10px; border: 10px solid #000;&#125;div1&#123; box-sizing:border-box;&#125;div2&#123; box-sizing:content-box;&#125; 弹性盒子先声明一下，在弹性盒子中成父级为容器，子级为项目。横轴为主轴，纵轴为侧轴。 设定属性flex为复核属性，且必须配合父元素display:flex使用。把flex设定在父级上面 设定在子级（项目）现在有这么一个需求就是，有一个父级宽度为500，然后呢，有三个子级，要求，把父级平均非配给每个子级，抛开手动设置宽度的方法，我们可以使用这个弹性盒子。例如： 1.flex-grow: 把剩下部分按比例分配 1234567891011.wrapper&#123; width: 500px; height: 200px; background: #eee;&#125;.wrapper div&#123; width: 100px; height: 100px; flex-grow: 1;//表示把剩下的每部分，按比例分配，每个div都占1分。&#125;........省略子元素样式 2.flex-shrink，按比例缩小 这个，适用于，如果子级的和超过父级，那么就会按照比例，按比例缩小。具体这样算： 123456789101112.div1&#123; width: 100px; flex-shrink:3;&#125;.div2&#123; width: 200px; flex-shrink:2;&#125;.div3&#123; width:300px; flex-shrink:1;&#125; 求div3的缩小部分：1乘300/(3乘100 + 2乘200 + 1乘300) (超出的部分) 100 = 30。(shrink值盒子宽度/（所有盒子shrink的和） 超出部分。 那么div3设置实际宽度就是300-30 = 270；同理div1设置实际宽度就是100-30 = 70；同理div2设置实际宽度就是200-40 = 160； 3.flex-basis:伸缩基准值. 该属性设置元素的宽度当然width也可以用来设置元素宽度，如果元素上同时出现了width 和flex-basis,那么flex-basis会覆盖width的值 子元素宽度尽可能按照basis来如果基准值相加大于容器宽度那么 下面由下面公式分配宽度给子元素 ( flex-basis/(flex-basis相加) ) * 容器的宽度 常用简化写法: 12flex:1 —&gt; flex:1 1 0%;flex:3 —&gt; flex:3 1 0%; 注意:flexbox布局和原来的布局是两个概念，部分css属性在flexbox盒子里面不起作用，eg：float， clear， column,vertical-align 等等 真实情况： 123456789101112son1 = (flex-shrink) * flex-basis；son2 = (flex-shrink) * flex-basis；…..sonN = (flex-shrink) * flex-basis；加权值 = son1 + son2 + …. + sonN；压缩的宽度 w = (子元素flex-basis值 * (flex-shrink)/加权值) * 溢出值缩减值1：(flex-basis1 * 1/ 加权值) * 溢出值缩减值2：(flex-basis2 * 2/ 加权值) * 溢出值缩减值3：(flex-basis3 * 3/ 加权值) * 溢出值最后son1、son2、son3，的实际宽度为：flex-basisn– 缩减值n = son n 真实宽度； flex: 就是复合了上面三个属性。 4.order: number，定义项目的排列顺序。数值越小，排列越靠前，默认为0 5.align-self: auto/ flex-start(从父级头部开始排序）/ flex-end(从后往前排)/ center(中间开始)/baseline(以第一行文字为基准值对齐)/stretch(拉伸充满整个父级，设高度的话，stretch无效); 我们来试一下baseline： 123456789.wrapper div&#123; width:200px; height: 100px; align-self: baseline;&#125;.div3&#123; width:300px; padding: 30px;&#125; 如果其中一个没有文字的话就会以底部对齐文字： 6.align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 7.align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 设定在父级上的属性（容器）1.flex-flow：flex-direction/flex-wrap， flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 2.flex-direction: row/row-reverse/column/column-reverse row表示横排，column表示竖着排。 3.flex-wrap:nowrap（默认)/ wrap/wrap-reverse 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 当设置flex-grow属性的时候wrap失效，flex-basis尽可能按basis值往大了去从而达到折行的目的， flex-shrink会失效 (根据子元素实际的宽度判断是否折行 4.justify-content:center; justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 123456flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 这个是space-between的效果： 这个是space-round的效果： 5.align-items:center; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 这就相当于，在哪里设置就听谁的，没有就听自己的，因为子级也能设定，子级默认继承父级的。 6.align-content:center; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 例如：现在有多个项目，就是有很多div，在父级上设置样式，使他们不在一行展示，产生换行。这样就出现两条轴线了。（父级宽设为500，子级每个div为100，flex-direction为wrap即可产生换行） space-around: 注此方法在盒子里只有一行元素时，不生效。定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 画三角形123456789.wrapper&#123; width: 30px; height: 30px; border: 50px solid #000; border-top-color: red; border-right-color: green; border-bottom-color: yellow; border-left-color: deeppink;&#125; 12345678910.wrapper&#123; width: 0px; height: 0px; border: 50px solid #000; border-top-color: transparent; border-right-color: green; border-bottom-color: transparent; border-left-color: transparent;&#125;// transparent 渐变色 好吧，那么关于CSS3学习的这一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://moreluckily.com/categories/CSS3/"}],"tags":[{"name":"-CSS3","slug":"CSS3","permalink":"http://moreluckily.com/tags/CSS3/"}]},{"title":"CSS3学习3","slug":"CSS3学习3","date":"2018-10-10T09:08:19.000Z","updated":"2018-10-23T02:43:15.443Z","comments":true,"path":"2018/10/10/CSS3学习3/","link":"","permalink":"http://moreluckily.com/2018/10/10/CSS3学习3/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习CSS3，今天要讲一下CSS3中的动画特性。 animation 动画关键帧 @keyframes这个是在使用animation之前设定的，它会按照定义的状态发生相应的改变，例如： 1234567@keyframes demoMove&#123;//每一个keyframes都要设定一个关键帧，用来以后调用 0%&#123; background-color:red;&#125; //初始颜色为红色 10%&#123; background-color:green;&#125;//动画到10%的时候，颜色是绿色 20%&#123; background-color:blue;&#125;//动画到20%的时候，颜色为蓝色 50%&#123; width:200px;&#125; //50%时间宽度是200 100%&#123; height:200px;&#125; //最终状态高度变为蓝色&#125; 帧频里面如果只有 0% 和 100%两个关键帧，那么可以用 from to 代替 animation 动画animation 属性为css3的复合属性，主要包括以下子属性： 1.animation-name: 此属性为执行动画的 keyframe 名，就是设定关键帧的时候设定的名字。 2.animation-duration:此属性为动画执行的时间，对应的是关键帧里面设定百分数 3.animation-timing-function:指定过渡函数速率（linear，） 4.animation-delay: 执行延迟时间，跟过渡动画是一个意思 5.animation-direction（动画执行方向）: 1234normal(0%---&gt;100%)/reverse（100%----&gt;0%）/alternate(奇数次正向，偶数次反向）/alternate-reverse（奇数次反向，偶数次反向）; 6.animation-iteration-count:动画执行次数，infinite（无数次）/number（具体次数）; 7.animation-fill-mode:forwards/backwards/both/none; 8.animation-play-state:属性主要用来控制元素动画的播放状态。一开始默认是播放。 12running 播放paused 暂停 利用JavaScript动态改变animation-play-state的值，可以实现动画的动态变化。 9.animation-fill-mode:属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值： 1234567891011none: 默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧处 forwards: 表示动画在结束后继续应用最后的关键帧的位置，不会回到动画一开始的位置。 backwards: 会在向元素应用动画样式时迅速应用动画的初始帧，例如初始位置是在0，初始帧是在150px，那么使用了backwards，会在150px处开始动画。 both: 元素动画同时具有forwards和backwards效果 12animation: move 2s linear infinite alternate backwards;//选取move关键帧，总时长2秒，正常速率，运动无数次，奇数次正向，偶数次反向，开始在初始帧的位置 最后来个网易云音乐的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849body&#123;background-color: gray;&#125;.wrapper&#123;position: relative;&#125;.wrapper .turn-table&#123; position: absolute; left: 300px; top: 300px; width: 100px; height: 100px; border-radius: 50%; text-align: center; line-height: 100px; border: 60px solid #333; background: green; animation: run 5s linear infinite; animation-play-state: paused;&#125;.wrapper .turn-table span&#123; color: #fff; font-size: 10px;&#125;.wrapper .pin&#123; position: absolute; left: 420px; top: 140px; display: block; width: 15px; height: 200px; background: #fff; border-bottom-left-radius: 7px 30px; border-bottom-right-radius: 7px 30px; transform-origin: top; transform: rotateZ(-30deg); transition: all 1s linear;&#125;@keyframes run&#123; 0%&#123; transform: rotateZ(0deg); &#125; 100%&#123; transform: rotateZ(360deg); &#125;&#125;.wrapper .pin-turn&#123; transform: rotateZ(0deg);&#125; 1234567&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;turn-table&quot;&gt; &lt;span&gt;网易云音乐转盘&lt;/span&gt; &lt;/div&gt; &lt;span class=&quot;pin&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;button&gt;play/paused&lt;/button&gt; 1234567891011121314151617181920var obtn = document.getElementsByTagName(&apos;button&apos;)[0];var otable = document.getElementsByClassName(&apos;turn-table&apos;)[0];var opin = document.getElementsByClassName(&apos;pin&apos;)[0];var flag = true;var timer;obtn.onclick = function()&#123; clearTimeout(timer); if(flag)&#123; timer = setTimeout(function()&#123; otable.style.animationPlayState = &apos;running&apos;; &#125;,1000); opin.className = &quot;pin pin-turn&quot;; flag = false; &#125;else&#123; otable.style.animationPlayState = &apos;paused&apos;; opin.className = &quot;pin&quot;; flag = true; &#125; &#125; 这样就可以得到类似于网易云音乐中的转盘： 好吧，那么关于CSS3学习的第三部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://moreluckily.com/categories/CSS3/"}],"tags":[{"name":"-CSS3","slug":"CSS3","permalink":"http://moreluckily.com/tags/CSS3/"}]},{"title":"CSS3学习2","slug":"CSS3学习2","date":"2018-10-10T09:07:02.000Z","updated":"2018-10-23T02:43:15.443Z","comments":true,"path":"2018/10/10/CSS3学习2/","link":"","permalink":"http://moreluckily.com/2018/10/10/CSS3学习2/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起继续学习CSS3，今天要讲一下CSS3中的下一部分。 首先讲一下CSS3中的属性选择器： 属性选择器jQuery库里面有很多选择器都是从css3里面来的。那我们现在开始学习吧。 E[att^=“val”]{…}，选择匹配元素E, 且E元素定义了属性att, 其属性值以val开头的任何字符串。 E[att$=“val”]{…}，选择匹配元素E, 且E元素定义了属性att, 其属性值以val结尾的任何字符串。 E[att*=“val”]{…}，选择匹配元素E, 且E元素定义了属性att, 其属性值任意位置出现了“val”。即属性值包含了“val”，位置不限。例如： 123456&lt;div class=&quot;demoaaa&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;aaademo&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;demoaa&quot;&gt;3&lt;/div&gt;div[class*=&quot;aaa&quot;]&#123; color:red;&#125; 可以看到，1和2都变色了，3没有变色，因为它其中并没有含有aaa。 伪类选择器和伪元素选择器什么是伪类选择器和伪元素选择器呢？ 简单的说就是：伪类选择器向某些选择器添加特殊的效果，用一个” : “而伪元素选择器需要添加一个实际的元素才能达到，用“ : : ” 伪类： 伪元素： 简单理解一下，hover我们都用过，只有我们的鼠标放在目标元素上面才会出现效果。只有我们激活它它才会有效果。这就是伪类。 关于伪元素，记得after吗？我们是利用它来清除浮动的，它没有标签结构，但是只要给他内容，并不需要我们激活，它就会有效，这就是伪元素。当然这个是我自己的理解，方便记忆，如果大家有不同的意见，可以按照你们的认为去记忆即可。 伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 伪类选择器伪类用于向某些选择器添加特殊的效果。 1.root 根标签选择器 “:root”选择器等同于html元素，简单点说： 12:root&#123;background:orange&#125;html&#123;background:orange&#125;//得到的效果等同 建议使用:root（xml等） 2.:not 否定选择器 用法和jQuery 中的not类似，可以排除某些特定条件的元素 123div:not([class=“demo”])&#123;background-color:red;&#125; 意思为除了class为demo的div以外，所有的div的背景颜色都变红, 伪类的效果可以通过添加一个实际的类来达到。 伪元素的效果则需要通过添加一个实际的元素才能达到。 就上述例子，我们可以为div添加一个类，然后为这个类名设置样式。也是可以达到同样的效果。 3.empty 空标签选择器 用来选择没有内容的元素、不在文档树中的元素，这里的没有内容指的是一点内容都没有，哪怕是一个空格。 4.target 目标元素选择器 用来匹配被location.hash 选中的元素(即锚点元素),选择器可用于选取当前活动的目标元素. 12345&lt;a href=&quot;#item&quot;&gt;&lt;/a&gt; &lt;div id=&quot;item&quot;&gt;&lt;/div&gt;div:target&#123; background:orange;&#125;//当a标签被点击之后就会变成橙色 5.子元素选择器 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child(){} 第xxx个子元素，n代表变量自然数，从数字1开始，如果是表达式就是从0开始。例如：3n+1，n从0开始 :nth-last-child(){} 从后往前数 123456789101112&lt;body&gt;&lt;li&gt;1&lt;/li&gt; &lt;ul&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;li:first-child&#123; background: red;&#125;//只有1和2被选中，父元素的第一个子元素，而且是li的子元素。 6.子元素选择器第二部分··· :first-of-type 第一个子元素 123456789101112&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;li:first-of-type&#123; background: red;&#125;//把所有的li、选出来之后在选择第一个li，并不是第一个子元素，并且是li的元素，跟first-child区别。 :last-of-type 最后一个子元素 :nth-of-type(){} 第xxx个子元素，n代表变量自然数，这个可以选出一些特定的元素，例如： 123456789101112131415&lt;body&gt; &lt;ul&gt; &lt;p&gt;0&lt;/p&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;span&gt;3-4&lt;/span&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;li:nth-of-type(4)&#123; background:red;&#125;//把4选出来，同样的是把所有的li拿出来在选第四个。 :nth-last-of-type(){} 从后往前数 7，only各种选择器。 :only-child 唯一子元素选择器 选择是独生子的子元素，即该子元素不能有兄弟元素，它的父元素只有他一个直接子元素。 12345678&lt;div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; p:only-child&#123; background:red; &#125;//左边代码块能选上，右边不能 注意：选择的元素是独生子子元素，而非有唯一子元素的父元素。 :only-of-type 如果要选择第某类特定的子元素(p) 在兄弟节点中是此类元素唯一个的话 就需要用到这个属性了 8.可用与否选择器（这个名字····呵呵，我自己起的，凑个格式） :enabled 可用的元素 :disabled 不可用的元素 在web的表单中，有些表单元素有可用（“enabled”）和不可用（“disabled”）状态，比如输入框，密码框，复选框等。在默认情况下，这些表单元素都处在可用状态。那么我们可以通过伪类选择器 enabled 进行选择，disabled则相反。 9.input checkbox :checked，选择框的被选中状态，之后触发。例如： 12345input:checked&#123; width:400px; height:200px; background:red;&#125;//选中之后，改变样式 还可以结合一些其他选择器 12345678&lt;input type=&quot;checkbox&quot;&gt;&lt;span&gt;hahahahahah&lt;/span&gt;span&#123; display:none;&#125;input:checked + span&#123; display: inline;&#125;//当input被选中之后，它后面紧接着的兄弟节点span标签display改变为inline。 注：checkbox, radio 的一些默认状态不可用属性进行改变，如边框颜色。 10,读写选择器~~~ :read-only 选中只读的元素。eg: 1&lt;input type=“text” readonly=“readonly”/&gt; :read-write 选中非只读的元素eg: 1&lt;input type=“text”/&gt; 伪元素选择器伪元素的效果是需要通过添加一个实际的元素才能达到的。 CSS3对伪元素进行了一定的调整，在以前的基础上增加了一个:也就是现在变成了 1::first-letter,::first-line,::before,::after 1.选中选择器 ::selection “::selection” 选择器是用来匹配突出显示的文本（用鼠标选择文本的时候）。浏览器默认情况下，用鼠标选择网页文本是以“蓝色的背景，白色的字体”显示的。属性：user-select: none;表示不能选中，在一些版权文章中，经常就是不能选中的，这个时候，就是用了这个属性。 123::selection&#123; user-select: none; color: red;//选中之后，颜色变为红色 注：火狐下必须加-moz- -moz-::selection。 2.条件选择。 E &gt; F ： an F element child of an E element 直接子元素 E + F ： an F element immediately preceded by an E element 后面的紧挨着的兄弟节点 E ~ F ： an F element preceded by an E element 后面的兄弟节点 写一个小例子：每次选中一个input，对应的div展示出来，其他消失: 1234567891011121314151617181920212223242526272829303132333435363738394041input&#123; width: 50px; height: 50px; &#125;.wrapper&#123; position: relative; left: 50%; margin-left: -100px; width: 200px; height: 255px; border: 1px solid black;&#125;.wrapper div&#123; position: absolute; top: 55px; width: 200px; height: 200px; display: none;&#125;.wrapper div:nth-of-type(1)&#123; background: red;&#125;.wrapper div:nth-of-type(2)&#123; background: deepskyblue;&#125;.wrapper div:nth-of-type(3)&#123; background: #f40;&#125;input:checked + div &#123; display:block;&#125;&lt;div class=&quot;wrapper&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;group&quot; checked&gt; &lt;!-- name相同，就变成了单选框 --&gt; &lt;div&gt;moreluck&lt;/div&gt; &lt;input type=&quot;radio&quot; name=&quot;group&quot;&gt; &lt;div&gt;morelucky&lt;/div&gt; &lt;input type=&quot;radio&quot; name=&quot;group&quot;&gt; &lt;div&gt;moreluckily&lt;/div&gt; &lt;/div&gt; 就能得到如上图所示的效果。 形状变换—高级动画基础transform 可以实现元素的形状、角度、位置等的变化。属性值： 1.rotate(); 以x/y/z为轴进行旋转，默认为z 1rotatex(), rotatey(), rotatez(), rotate3d(x, y, z, angle) x, y, z ---&gt; rotateZ()：正值顺时针转，rotateY: 绕着Y轴开始旋转，rotateX():绕着X轴开始旋转。 rotate3D(x,y,z.angle),三个轴一起转。对应轴上可填写1或0，表示是否参与旋转。 2.scale(); 以x/y为轴进行缩放 scale(x, y) 接受两个值，如果第二参数未提供，则第二个参数使用第一个参数的值 scalex(),scaley() 值是数字表示倍数，不加任何单位，如果是赋值会发生倒立或反转。（x轴倒立，y轴翻转） scalez() scale3d() scale3d(sx,sy,sz)。 3.skew(); 对元素进行倾斜扭曲 skew(x, y);接受两个值，第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 skewx(), skewy() 4.translate(); 可以移动距离,相对于自身位置。 translate(x, [y]) translatex(),translatey(),translatez(),translate3d(x, y, z)。利用这个可以实现居中展示： 1234567div&#123; position:absolute; left:50%; top:50%; background: orange; transform: translate(-50%,-50%);&#125; 5.transform-orgin 变换旋转原点 任何一个元素都有一个中心点，默认情况下，其中心点是居于元素x轴和y轴的50%处，如图为 关键字： 1transform-origin：top;//以顶部50%的位置作为旋转原点。 transition 过渡动画hover123456789div&#123; width: 100px; height: 100px; background: red;&#125;div:hover&#123; width: 400px; height: 200px;&#125; 当我们使用这个的时候，是发生的突变，变化很快，给人感觉很不好，于是就出来了一个叫过渡动画的概念，我们可以实现让div hover的时候慢慢变化。 过渡动画transition 属性是css3的一个复合属性，主要包括一下几个子属性 transition-property:指定过渡或动态模拟的css属性 transition-duration:指定过渡所需要的时间 transition-timing-function:指定过渡函数 transition-delay:指定开始出现的延迟时间 transition: width(如果高度也要实现渐变需要写all) 3000ms linear 20; 1234567891011div&#123; width: 100px; height: 100px; background: red; transition: width 3000ms linear 1s; /* 改变宽度，持续时间为3000ms,直线运动, 延迟时间1s*/ /* transition: all 3000ms linear 1s; 全部发生变化*/&#125;div:hover&#123; width: 400px;&#125; 但是有些内容不能使用过度，如下图： 能参与过渡的属性： 好吧，那么关于CSS3学习的第二部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://moreluckily.com/categories/CSS3/"}],"tags":[{"name":"-CSS3","slug":"CSS3","permalink":"http://moreluckily.com/tags/CSS3/"}]},{"title":"CSS3学习1","slug":"CSS3学习1","date":"2018-10-09T14:42:08.000Z","updated":"2018-10-23T02:43:15.428Z","comments":true,"path":"2018/10/09/CSS3学习1/","link":"","permalink":"http://moreluckily.com/2018/10/09/CSS3学习1/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习CSS3，今天要讲一下CSS3中的一部分。 CSS3 简介我们之前用的css版本是2.0的版本，那么css3就是它的升级版，是css3.0的版本，它在css2.1的基础上增加了很多强大的新功能。目前主流浏览器chrome、safari、firefox、opera、甚至360都已经支持了CSS3大部分功能了，IE10以后也开始全面支持CSS3了。 css3前缀在编写CSS3样式时，不同的浏览器可能需要不同的前缀。它表示该CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但为了更好的向前兼容前缀还是少不了的。 标准写法如表顺序，再在后面添加无前缀的： 举个例子： 12345678910div&#123; width: 100px; height: 100px; background-color: red; border-radius: 30px; -webkit-border-radius: 30px; -moz-border-radius: 30px; -ms-border-radius: 30px; -o-border-radius: 30px; //w3c标准之前&#125; 查看是否需要实现兼容，我们可以使用‘www.caniuse.com’,来进行查找，如果不兼容就要进行兼容。 CSS3 初级功能提供了更加强大且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状、角度等，可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等等等… 但是css3的兼容性问题也是同样的重要，并不是所有的css3属性都通过W3C标准，所以我们可以在这个网站查询： 12http://www.runoob.com/cssref/css3-browsersupport.html //兼容性参考手册 又例如： IE6混杂模式盒模型： 12width=(border+padding+content)的宽度height=(border+padding+content)的高度 标准模式： 12width=content的宽度height=content的高度 也就是说，如果：width: 100px,height: 100px,padding:10px,border:10px,margin:10px;则在标准模式下：盒子长度为140px,在混杂模式下，盒子长度为100px,contend区为60px。 如果现在有个需求，部分盒子需要混杂模式的，部分符合标准模式的。这个时候需要进行一些操作。我们后面再说。 border-radius —— 圆角border-radius是一个复合属性，他复合了上下左右四个角属性值。因此我们可以拆成四个角进行设置： 123456border-radius: 20px 30px 40px 50px;//相当于：border-top-left-radius: 20;border-top-right-radius: 30px;border-bottom-right-radius: 40px;border-bottom-left-radius: 50px; 原理如图： 出现圆的原理是，例如，我们画了一个正方形，宽高一百，设定border-radius为50px，那么浏览器会在页面中以50px为半径，以小正方形（左上角那个）的右下角为圆心画出一个半径为50的1/4圆弧，那么每个角都是如此类推，就出现了圆的效果了。如果是： 1border-radius: 20px 30px 40px 50px; 之前说个，它们是复合属性，bottom-top-left-radius也是有两部分构成的，例如： 1bottom-top-left-radius：20px 50px; 这个表示的是，上边20px，左边50px为长轴或短轴画一个椭圆，以他们焦点做1/4弧。 再来举几个小例子： 123456div&#123; width: 100px; height: 50px; background-color: red; border-radius: 50px 50px 0 0;&#125; 得到一个半圆 123456div&#123; width: 100px; height: 60px; background-color: red; border-radius: 50px 0 50px 0;&#125; 得到一个类似叶子的形状。 还有一种写法就是使用相对单位： 1border-radius: 1em 2em 1em 2e/2em 1em 2m 1em //x轴上的Y轴上的 这种方法很少用，了解即可。 box-shadow 盒子阴影box-shadow，有几个属性，分别是x轴的偏移，和y轴偏移，模糊半径（越大越模糊，会有临界值），扩展半径（阴影大小，放大缩小效果，）阴影颜色还投影方向，一共六个参数投影方向默认值是outset但是不能填写，写了反而错，还有就是inset，从里往外投。 12345678div&#123; width:100px; height: 100px; background:red; border-radius: 20px 30px 40px 50px; box-shadow: 10px 10px 5px 5px #ccc inset/outset; //outset是不能设置的，这里只作展示来用&#125; 这个是inset的。 这个是outset的。 文字投影文本阴影text-shadow， 1text-shadow:X-Offset Y-Offset blur color; X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移； Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移； Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0； Color：是指阴影的颜色，其可以使用rgba色。 比如，我们可以用下面代码实现设置阴影效果。 1text-shadow: 5px 1px 1px #fff; rgba 颜色函数这是一种设定颜色的另一张方式，rgb分别表示红绿蓝的成分，最多是255，a表示透明度1为不透明，0为全透明。 RGB是一种色彩标准，是由红(R)、绿(G)、蓝(B)的变化以及相互叠加来得到各式各样的颜色。RGBA是在RGB的基础上增加了控制alpha透明度的参数。 语法： 1color：rgba(R,G,B,A) 以上R、G、B三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。并非所有浏览器都支持使用百分数值。A为透明度参数，取值在0~1之间，不可为负值。 12rgba(255,0,0,1) //红色rgab(0,0,0,1) //全黑色 渐变CSS3的渐变分为两种，线性渐变和径向渐变。接下来给大家分别介绍一下： 1）线性渐变（linear - to），就是按照一条线来渐变语法： 1linear-gradient([direction], color [percent], color [percent], …) direction为方向，从左到右，从上到下之类的，color指的从什么颜色变成什么颜色。liru例如： 1234background:linear-gradient(to top,#fff,#000) //从下往上渐变，从白色变为黑色background:linear-gradient(to top right,#fff,#000) //从左下角渐变到右上角background:linear-gradient(0deg, #fff,red,green,yellow,blue,black);从零度角开始渐变，各种颜色变为黑色。如图一background:linear-gradient(0deg, #fff,red 20%,green 30%,yellow 20%,blue 20%,black) 控制颜色渐变的位置 2）径向渐变（radial - at），就是按照圆的路径进行渐变。语法: 1radial-gradient(shape at position, color [percent] , color, …) shape:放射的形状，可以为原型circle，可以为椭圆ellipse，后面跟着的相当于渐变的大小。如果是椭圆的话需要填长短轴。 position: 圆心位置，可以两个值，也可以一个，如果为一个时，第二个值默认center 即 50%。值类型可以为，百分数，距离像素，也可以是方位值(left,top…); /x 轴主半径 y轴次半径/ 12background: radial-gradient(circle 50px at 50px 50px, #faf, #ff4400, yellow,transparent);//效果如下图 12345 div&#123; width: 100px; height: 100px; background: radial-gradient(ellipse 50px 30px at 50px 50px, #faf, #ff4400, yellow);&#125; 也可以得到一个椭圆 word-wrap:normal|break-word;当写一堆英文不空格时，会超出规定的区域。 这就有一个属性叫做强制换行，“word-wrap:break-word”,这样溢出之后，会换行。 字体我们可以自定义一些字体，从网上选取喜欢的下载，然后使用。 123456789@font-face&#123; font-family:”myFirstFont”; src:url(&apos;Sansation_Light.ttf&apos;), url(‘Sansation_Light.eot&apos;) format(‘eot’)；&#125;//format: 此值指的是你自定义的字体的格式，主要用来帮助浏览器识别浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，浏览器自身也无法通过路径后缀来判断字体#demo&#123; font-family: &quot;myFirstFont&quot;;&#125;//使用定义好的字体 border-image ——边框应用背景之前我们的border都是只用实线或者虚线，没有其他的内容了。我们在css3可以自定义border，使用图片来实现。 1border-image: url(xxx.png) number strech repeat 举个例子如下图： 第一个参数是Number，它会按照你给的值，例如是30px，它会在从左边，右边，下边，上边开始30px，分别剪一下。得到四个角，然后对应的放到border对应的四个角。 第二个参数是strench就是拉伸，把剩下的部分铺满边框剩下的部分。例如： 1border:url(border.png) 27px strentch; 可以看出，四个角分别是剪下来的四个角，中间是剩下部分的拉伸展示。除了拉伸还有平铺效果（repeat）和铺满效果（round）（主要在于，剩下的部分如果填充不了，是否会发生裁剪，还是按比例伸缩，平铺是切割，铺满是不切割），就是这样的： 1border:url(border.png) 27px repeat; 发生裁剪 从中间开始裁剪 1border:url(border.png) 27px round; 不发生裁剪 对于round来说，如果width太小，它会发生裁剪合并，判断是，拉伸范围是否大于自身的1.5倍，如果是，那么就会进行合并。 背景图片起始位置background-origin图片默认从padding区开始展示，我们可以对它进行设置。 1background-orgin: border-box | padding-box | content-box; 参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。 裁剪背景图片 background-clip1background-clip ： border-box | padding-box | content-box | no-clip 参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。background-clip默认值为border-box。 background-position,利用这个可以进行定位，确定要展示哪一个部分的内容。（豆瓣评分，星图,雪碧图） 123456.start&#123; width:100px; border: 1px solid #000 ; background: url(&apos;star.png;) no-repeat; background-position: 0 -45px;&#125; 可以得到： 背景图片尺寸background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。语法： 1background-size: auto/&lt;长度值&gt;/&lt;百分比&gt;/cover/contain 取值说明： 1、auto：默认值，不改变背景图片的原始高度和宽度； 2、&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放； 3、&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上； 4、cover：用一张图片铺满整个背景，如果比例不符，则截断图片 5、contain：尽量让背景内，存在一整张图片 好吧，那么关于CSS3学习的第一部分的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://moreluckily.com/categories/CSS3/"}],"tags":[{"name":"-CSS3","slug":"CSS3","permalink":"http://moreluckily.com/tags/CSS3/"}]},{"title":"雅虎35条优化","slug":"雅虎35条优化","date":"2018-10-08T09:47:12.000Z","updated":"2018-10-23T02:43:15.662Z","comments":true,"path":"2018/10/08/雅虎35条优化/","link":"","permalink":"http://moreluckily.com/2018/10/08/雅虎35条优化/","excerpt":"","text":"新的blog，新的开始。今天我将和大家介绍一下雅虎前端优化的一些需要注意的东西。 雅虎前端优化的35条军规无论是在工作中，还是在面试中，web前端性能的优化都是很重要的，那么我们进行优化需要从哪些方面入手呢？可以遵循雅虎的前端优化34条军规，不过现在已经是35条了，所以可以说是雅虎前端优化的35条军规。已分类，挺好的，这样对于优化有一个比较清晰的方向。 内容部分1.尽量减少HTTP请求数 80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。 减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。 合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。 CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。 图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。 行内图片（Base64编码）用data:：URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。 减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。 2.减少DNS查找 域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。 DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。 IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件) 如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。 减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 3.避免重定向 重定向用301和302状态码，下面是一个有301状态码的HTTP头： 123HTTP/1.1 301 Moved Permanently Location: http://example.com/newuri Content-Type: text/html 浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。 牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。 有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。 重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。 4.让Ajax可缓存 Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。 要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。下面适用于Ajax的其它规则：12345Gzip组件减少DNS查找压缩JavaScript避免重定向配置ETags 我们一起看看例子，一个Web 2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。 即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。 5.延迟加载组件 可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。 JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。 工具可帮你减轻工作量：YUI Image Loader可以延迟加载折叠的图片，还有YUI Get utility是一种引入JS和CSS的简单方法。Yahoo!主页就是一个例子，可以打开Firebug的网络面板仔细看看。 最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。 6.预加载组件 预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。 实际应用中有以下几种预加载的类型： 无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。 条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。 提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。 7.减少DOM元素的数量 一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。 大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的s？或许应该用更好的语义化标记。 YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用1&lt;div&gt; 而不是因为它能够渲染一个新行。 DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：1document.getElementsByTagName(&apos;*&apos;).length 那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如Yahoo!主页是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。 8.跨域分离组件 分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。 9.尽量少用iframe 用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。 iframe的优点：123引入缓慢的第三方内容，比如标志和广告安全沙箱并行下载脚本 iframe的缺点：123代价高昂，即使是空白的iframe阻塞页面加载非语义 10.杜绝404 HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。 有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。 css部分11.避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的： 1background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); 12.选择link舍弃@import 前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。 在IE中用@import与在底部用link效果一样，所以最好不要用它。 13.避免使用滤镜 IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。 最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。 14.把样式表放在顶部 在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。 关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。 js部分15.去除重复脚本 页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。 IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。 除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。 避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签： 1&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt; 16.尽量减少DOM访问 用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：123缓存已访问过的元素的索引先“离线”更新节点，再把它们添到DOM树上避免用JavaScript修复布局问题 17.用智能的事件处理器 有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 18.把脚本放在底部 脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。 有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。 一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。 javascript, css19.把JavaScript和CSS放到外面 很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？ 实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。 20.压缩JavaScript和CSS 压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。 混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。 除了压缩外部脚本和样式，行内的&lt;script和&lt;style块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。 图片img21.优化图片1尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 22.优化CSS Sprite1234在Sprite图片中横向排列一般都比纵向排列的最终文件小组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 23.不要用HTML缩放图片 不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 24.用小的可缓存的favicon.ico（P.S. 收藏夹图标） favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。 所以为了缓解favicon.ico的缺点，应该确保：12足够小，最好在1K以下设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 cookie25.给Cookie减肥 使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。1234清除不必要的cookie保证cookie尽可能小，以最小化对用户响应时间的影响注意给cookie设置合适的域级别，以免影响其它子域设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 26.把组件放在不含cookie的域下 当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。 如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。 把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。 移动端27.保证所有组件都小于25K 这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 28.把组件打包到一个复合文档里 把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 服务器29.Gzip组件 前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 1Accept-Encoding: gzip, deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。 1Content-Encoding: gzip 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 30.避免图片src属性为空 Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： 1、straight HTML1&lt;img src=””&gt; 2、JavaScript 12var img = new Image();img.src = “”; 这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 31.配置ETags 实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag： 1234HTTP/1.1 200 OK Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT ETag: &quot;10c24bc-4ab-457e1c1f&quot; Content-Length: 12195 然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。 12345GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot; HTTP/1.1 304 Not Modified 32.对Ajax用GET请求 Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。 POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 33.尽早清空缓冲区 当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。 较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。 例如： 12345... &lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; ... &lt;!-- content --&gt; 34.使用CDN（内容分发网络） 用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？ 实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。 记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 35.添上Expires或者Cache-Control HTTP头 这条规则有两个方面：12对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求 网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。 浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。 1Expires: Thu, 15 Apr 2010 20:00:00 GMT 如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期： 1ExpiresDefault &quot;access plus 10 years&quot; OK，这些很多都要背的哦，一起加油吧！","categories":[{"name":"总结","slug":"总结","permalink":"http://moreluckily.com/categories/总结/"}],"tags":[{"name":"-总结","slug":"总结","permalink":"http://moreluckily.com/tags/总结/"}]},{"title":"jQuery源码学习2","slug":"jQuery源码学习2","date":"2018-10-08T09:45:54.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/10/08/jQuery源码学习2/","link":"","permalink":"http://moreluckily.com/2018/10/08/jQuery源码学习2/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习jquery。今天要讲一下jQuery源码中的另外一小部分。 今天听了思彤哥的一些话，很有感触。学习新的东西需要经过三个区，分别是恐惧区，学习区，舒适区。当我们学习一个新的东西的时候，刚开始肯定都是恐惧区，这个东西怎么这么难呢？然后再是学习区，学习的特别熟练的时候就到了舒适区了，人一定要在恐惧区多呆着，也就是要多学习心得知识，不要在舒适区呆多了，那样会使我们的技能减退的。 jQuery源码学习学习预热首先讲一下当我们调用时经常这样写： 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;$(&apos;ul&apos;).find(&apos;li:eq(0)&apos;) .css() .end() //回退//还可以这样写：$(&apos;ul&apos;).find(&apos;li&apos;).eq(0) .css(&#123;backgroundColor: &apos;orange&apos;&#125;) .end().eq(1) .css(&#123;backgroundColor: &apos;red&apos;&#125;); jQuery源码首先介绍一下eq( )的源码： 123456eq: function( i ) &#123; var len = this.length, j = +i + ( i &lt; 0 ? len : 0 );//+i ,将字符串变成数字 //-1就+len，就是从后面开始数数 return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );&#125; 这里有个.pushStack函数 123456789101112131415pushStack: function( elems ) &#123;// Build a new jQuery matched element setvar ret = jQuery.merge( this.constructor(), elems );// Add the old object onto the stack (as a reference)ret.prevObject = this;// Return the newly-formed element setreturn ret;&#125;,//end()源码end: function() &#123; return this.prevObject || this.constructor();&#125; 我们分析一下，首先我们写:$(‘li’).eq(0) 会创建一个对象，我们将其取名为li-group，它里面有{0：li1：li…9：li} 然后.end(0) 会返回一个新的对象： {0：liprovObject: –&gt;指向li-group} 再进行.eq(1) 同时会再返回一个新的对象： {0：li –&gt; li-group中的 1: liprovObject: –&gt;还是指向li-group} 这样我们就可以一直链式调用了。它里面创建了一个provObject，它里面就是li-group，这样实现了一直链式调用。 $.extend()的源码首先介绍一个类数组变成一个特别像数组的一个方法： 12345678var arr = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;console.log(arr);//Object = &#123;...&#125; 1234567891011var arr1 = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3, push: Array.prototype.push, sort: Array.prototype.sort, splice: Array.prototype.splice&#125;;console.log(arr1);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 再讲一下$.extend()的功能，它能浅拷贝和深拷贝 首先是浅拷贝： 123456789var target = &#123; user: &apos;haha&apos;&#125;;var copy1 = &#123; user: &apos;fa&apos;, age: 18&#125;;$.extend(target, copy1);console.log(target); //&#123;user: &quot;fa&quot;, age: 18&#125; 将copy1里的东西拷给target。 再来一个深拷贝： 1234567891011121314151617var target = &#123; name: &#123; nam: &apos;aaa&apos; &#125;&#125;;var copy1 = &#123; name: &#123; age: &apos;111&apos; &#125;&#125;;$.extend(true, target, copy1);//有true就是深拷贝console.log(target); //name: &#123;age: &quot;111&quot;nam: &quot;aaa&quot;&#125; 当然也可以多写几个copy对象： 1234567891011121314151617var target = &#123; name: &#123; nam: &apos;aaa&apos; &#125;&#125;;var copy1 = &#123; name: &#123; age: &apos;111&apos; &#125;&#125;;var copy2 = &#123; name: &#123; age: &apos;111&apos; &#125;&#125;;$.extend(true, target, copy1, copy2);//将copy1和copy2里的东西都拷到target中,还可以加 $.fn.extend()和.extend()的区别就是:fn就是代表prototype上写。 我们来看一下源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, //argument[0]没有就是一个空对象 i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === &quot;boolean&quot; ) &#123; //第一个值看一下是不是true deep = target; //深拷贝 // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; //target 和 copy都确定了 for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // var targetObject = &#123;name: &apos;&apos;&#125;; // var copyObject = &#123;name: targetObject&#125;; // $.extend(targetObject, copyObject); // console.log(targetObject) //会一直引用，相互引用，永不停息 // Prevent never-ending loop if ( target === copy ) &#123; continue; //跳过此循环 &#125; // Recurse if we&apos;re merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 好吧，那么关于jquery源码的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"jquery","slug":"jquery","permalink":"http://moreluckily.com/categories/jquery/"}],"tags":[{"name":"-jquery","slug":"jquery","permalink":"http://moreluckily.com/tags/jquery/"}]},{"title":"jQuery源码学习1","slug":"jQuery源码学习1","date":"2018-10-08T09:18:40.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/10/08/jQuery源码学习1/","link":"","permalink":"http://moreluckily.com/2018/10/08/jQuery源码学习1/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习jquery。今天要讲一下jQuery源码中的一小部分。 jQuery整体的想法首先如果自己写一个库方法，因该怎么写呢？ 1234567(function (global) &#123; function a() &#123; &#125; global.a = a; //global.a就是全局的a&#125;(window))a();//这样就能用了 先为了避免全局污染，写一个立即执行函数，将window作为参数传进去，用global代替window，将立即执行函数中的函数方法能拿到全局中执行，最后在全局中也能使用该方法。 用这个概念我们就可以知道jQuery中是怎么写的了： 12345678(function (global) &#123; function jQuery() &#123; &#125; global.$ = global.jQuery = jQuery; &#125;(window))$();jQuery(); //这样就能用该方法了 我们引入jQuery库文件，我们知道可以这样去写：$(‘div’)，那我们将它打印出来： 123456789console.log($(&apos;div&apos;)) //返回的是一个对象，0: divlength: 1prevObject: jQuery.fn.init [document]__proto__: Object(0)// __proto__ 上有一堆的方法，就可以调用其上的方法// 例如：console.log($(&apos;div&apos;).html()) 那jQuery是如何写这部分内容的呢？ 12345678910111213141516171819202122232425262728(function (global) &#123; // function jQuery() &#123; // // var this = &#123;&#125;; //隐式的生成原型 // // this.__proto__ = jQuery.prototype; // // return this; // &#125; function jQuery(selector, context) &#123; return new jQuery.prototype.init(selector, context) //这样用户就不需要在外面new了，直接就可以得到 &#125; jQuery.prototype.init = function(selector, context) &#123; var oDiv = document.getElementById(selector.slice(1 )); this[0] = oDiv; this.length = 1; this.selector = selector; this.context = context; &#125;//初始化的方法 jQuery.prototype.css = function () &#123; this[0].style.height = &quot;100px&quot;; this[0].style.width = &quot;100px&quot;; this[0].style.backgroundColor = &quot;red&quot; &#125; jQuery.prototype.init.prototype=jQuery.prototype; global.$ = global.jQuery = jQuery; &#125;(window))$(&quot;#demo&quot;).css();//自己写了一个类似jQuery库的方法 jQuery内部是如何去写的打开jQuery文件：（整体是这样的） 1234567 (function(global,factory)&#123;&quot;use strictfactory(global); ...... &#125;((typeof window !== &quot;undefined&quot; ? window : this,function()&#123; ..........................直接翻到最后面 &#125;)) 利用立即执行函数，整个jQuery核心部分是一个function，是个参数。而且利用的是严格模式. 然后，typeof window ！== “undefined” ，因为在低版本浏览器，window是可以赋值为undefined的，如果是undefined，就把this传进去，实际上就是把window传进去jQuery里面。这样才可以把立即执行函数里面的东西给暴露出来。相当于一个接口。 因为外面是可以使用$符号进行引用的，所以，肯定会在函数里面把该符号做操作。 在上面已经说过了，$和jQuery是等价的。 $(“div”) 得到的是 return new jQuery.fn.init(“div”)。 1234567init = jQuery.fn.init = function(selector,context,root)&#123; .......//root是jQuery内部操作的&#125;init.prototype = jQuery.fn;jQuery.fn = jQuery.prototype = &#123;......&#125; init就是一个初始化的方法，传两个参数，选择器和上下文。 $()使用的时候，return的东西出来，这是个对象，上面的方法存在于原型上。那么最后的原型链就落在了jQuery.prototype上面。又因为，jQuery.fn = jQuery.prototype. 那么再回头再看 ，整圈循环出来实现了： 1jQuery.prototype.init.prototype = jQuery.prototype jQuery可以把一切的东西都定义在原型上面。这样很方便。这样循环往复的prototype互相赋值，你会发现，在init方法下面的prototype里还有init方法，循环嵌套在里面。这就是它的模式。 123456789101112131415161718(function (target)&#123; target();&#125;(function()&#123; var jq = function ()&#123; ... return new jq.prototype.init(); &#125; jq.prototype = &#123; xxx : function()&#123;&#125; &#125; jq.prototype.init = function()&#123; ...... &#125; jq.prototype.init.prototype = jq.prototype =&#123; ... &#125; window.$ = window.jq = jq; &#125;)) 这样通过$().xxx(),就能够调用对象上面的属性和方法了。先定义原型，在定义构造方法，在让构造方法的原型等于原来的原型，顺序不能换。不能使用连等。防止出bug。 原型的嵌套主要是实现链式调用。 jQuery的init( )函数当我们传进去选择器之后，初始化函数是会对这个选择器进行一些操作的。用来选择出用户想要的DOM元素。 12345678jQuery.prototype.init = function (selector, context,root)&#123;//root参数是用来jQuery自己使用的，不用我们传，是一个doucment(jQuery对象） var oDiv = document.getElememntById(selector.slice(1)); this[0] = oDiv; this.length = 1; this.selector = selector ; this.context = context;&#125;$(&quot;#demo&quot;); 这样当我们调用$()来进行方法的调用的时候，就相当于通过构造函数来构造出来一个jQuery对象，并将它返回出来。 之后，jQuery的选择器可以兼容多种参数，如下形式都是符合的： 12345678910111213141516171819//单参数1、$(&apos;div&apos;)2、$(&quot;.class&quot;)3、$(&quot;#id&quot;)4、$(&quot;*&quot;)5、$(&quot;&lt;div&gt;&quot;)6、$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)7、$(&quot;&lt;div/&gt;&quot;)8、$(&quot;&lt;div&gt;sdagfagfasdgasdgsag&quot;)9、$(null/undefined/false/&quot;&quot;)10、$(function() &#123;&#125;)11、$(dom/&amp;())// //多参数1、$(&quot;&lt;div&gt;&quot;,&#123;html:123,class:&quot;demo&quot;&#125;)//就变成了 //&lt;div class=&quot;demo&quot;&gt;123&lt;/div&gt;2、$(&quot;li&quot;,&quot;ul&quot;)3、$(&quot;li&quot;,dom/$()) 然后看jQuery中是如何处理的呢？ 首先介绍一些知识： 正则表达式 exce方法，merge方法合并数组，jQuery自带的工具方法内部使用。 这是exec返回的内容的例子，复习一下： 这是选择器匹配，jQuery中用的就是这种方法： 接下里就是jQuery中完整的代码了。其详细的介绍了各种情况的创建过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758init = jQuery.fn.init = function( selector, context, root ) &#123; var match, elem; if ( !selector ) &#123; return this; &#125; root = root || rootjQuery; if ( typeof selector === &quot;string&quot; ) &#123; if ( selector[ 0 ] === &quot;&lt;&quot; &amp;&amp; selector[ selector.length - 1 ] === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) &#123; match = [ null, selector, null ]; //为了跟接下来操作的match一致，只保留中间的selector &#125; else &#123; match = rquickExpr.exec( selector );//正则匹配，返回一个数组， //第一位是匹配到的东西，第二位是匹配到的第一个内容，第三位是匹配到的第二个内容。 //rquickExpr = /^(?&quot;\\s*(&lt;[\\w\\W] +&gt;)[^&gt;]* | #([\\w-]+))$/, // 左边匹配出来的是情况6，右边匹配出来的是情况3 &#125; if ( match &amp;&amp; ( match[ 1 ] || !context ) ) &#123; if ( match[ 1 ] ) &#123;//匹配创建标签 context = context instanceof jQuery ? context[ 0 ] : context; jQuery.merge( this, jQuery.parseHTML(match[ 1 ],context &amp;&amp; context.nodeType /*判断nodeType来判断是否是原生dom*/ ? context.ownerDocument || context //实在太特么长了，这里是一个三目运算符，把它分隔一下 : document,true) );//最后都是要把document返回出去 if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123; //rsingleTag用来判断是否是单标签，第二对象是否为对象，用来匹配case 10；单标签+字面量对象 for ( match in context ) &#123; //遍历上下文。就是第二个参数 if ( jQuery.isFunction( this[ match ] ) ) &#123; this[ match ]( context[ match ] ); &#125; else &#123; this.attr( match, context[ match ] ); //把match当做属性添加到标签上面，最后返回，注意这里的match是废物利用，跟之前的match不一样 &#125; &#125; &#125; return this; &#125; else &#123;//匹配id选择 elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; this[ 0 ] = elem; this.length = 1; &#125; return this; &#125; &#125; else if ( !context || context.jquery ) &#123;//处理类名和标签名和通配符即1,2,3（id已经匹配） return ( context || root ).find( selector );//通过上下文，没有上下文就上document来寻找selector，类似父子关系的选择器 &#125; else &#123;//原生dom return this.constructor( context ).find( selector );//直接调用init，创建jQuery对象 &#125; &#125; else if ( selector.nodeType ) &#123;//原生dom节点 直接封装称为类数组，jQuery对象 this[ 0 ] = selector; this.length = 1; return this; &#125; else if ( jQuery.isFunction( selector ) ) &#123;//传函数的形式，类型8 return root.ready !== undefined ? //root 就是document 目的执行isFunction root.ready( selector ) : //当所有的dom加载完，触发ready，然后执行selector，就是传进来的函数 selector( jQuery ); //如果没有加载完就直接手动加载这个方法 &#125; return jQuery.makeArray( selector, this );//胡乱写的东西做兼容&#125;; 最后，init这个函数通过很多的if和else来进行匹配selector。有很多正则表达式。 好吧，那么关于jquery源码的第一部分的知识就讲到这，希望大家能有所收获。 后面为大家讲的还是jquery中的源码部分，一起加油吧。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"jquery","slug":"jquery","permalink":"http://moreluckily.com/categories/jquery/"}],"tags":[{"name":"-jquery","slug":"jquery","permalink":"http://moreluckily.com/tags/jquery/"}]},{"title":"jquery工具方法","slug":"jquery工具方法","date":"2018-10-07T13:55:03.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/10/07/jquery工具方法/","link":"","permalink":"http://moreluckily.com/2018/10/07/jquery工具方法/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习jquery。今天要讲一下jquery的工具方法和它其中的Ajax trigger()事件trigger()事件，它的作用就是触发自定义的事件，第一个参数就是触发事件的名字，第二个及之后的参数就是传到该事件的参数，首先它可以出发自定义事件： 12345678$(&apos;div&apos;).on(&apos;click&apos;, function () &#123; console.log(1);&#125;)//click是系统自带的$(&apos;div&apos;).on(&apos;eat&apos;, function () &#123; console.log(1);&#125;)//eat是我们自定义的$(&apos;div&apos;).trigger(&apos;eat&apos;);// eat使我们自定义的，刷新打印1，帮我们主动触发事件了。 trigger触发事件是会冒泡的，就是触发子元素上的事件会冒泡到父级上面。例如在ul结构下的li，触发li，ul也会被触发。在这里就举例了。 我们可以利用第二个参数位来进行一些操作。可以利用trigger来进行数据的传输。例如： 1234$(&apos;div&apos;).on(&apos;body&apos;,function(e,tall,weight)&#123; console.log(&apos;我的身高是&apos;+tall+&apos;我的体重是&apos;+weight);&#125;)$(&apos;div&apos;).trigger(&apos;body&apos;,[&apos;175cm&apos;,&apos;65kg&apos;]); 要注意的是，在trigger里面第一个是事件对象，第二个参数传的是数组！！！ jQuery 工具方法之前的几篇博客讲的都是定义在jquery的原型链上的，也叫jquery实例方法。 jQuery里定义的工具方法有很多，在调用它们的时候直接使用”$.”的形式即可，这类方法是定义在jQuery函数上面的，就是这样： 1jQuery.工具方法() = function (); 可以直接调用，而不需要像之前那样还需要调用对象。 1、type( )判断参数的数据类型 举个例子： 12345$.bb = function () &#123; console.log(9999);&#125;$.bb();//就相当于工具方法 原生JS判断数组和对象三种方法 1.arr instanceof Array 如果是数组 则返回true，如果是对象返回false。 2.arr.constructor == Array ,对象就是Object。 3.Object.prototype.toString.call(arr) 1234567891011121314var arr = [1,2,3];console.log(typeof arr); //objectconsole.log(arr instanceof Array);//trueconsole.log(arr instanceof Object);//trueconsole.log(arr.constructor === Array);//trueconsole.log(arr.constructor === Object);//false//这2种方法iframe 不好使,在子页面下不好使console.log(Object.prototype.toString.call(arr));//[object Array]//1,2两种有局限性 3比较通用//$.type() 判断 参数的数据类型console.log($.type(arr)) //array//简单清晰明了 type( )方法 ,针对不同窗口，它也能判断数据类型。以后利用它就可以了。 2、trim( ) 去除空格，只能去除左边和右边的空格，如果是要去掉中间的空格，用正则表达式匹配即可。 123 var str = &apos; aaa &apos;;console.log(&apos;|&apos; + str + &apos;|&apos;);//| aaa |console.log(&apos;|&apos; + $.trim(str) + &apos;|&apos;);//|aaa| 3、proxy( )，利用这个函数，可以改变this的指向。它可以将this指向改变为对象，或者是对象里面的函数。 12345678910111213141516171819202122var obj = &#123; name: &apos;fa&apos;, age: 18, techang: function() &#123; console.log(&apos;dance&apos;); &#125;&#125;function aa() &#123; console.log(this);//指向window &#125;aa();function aa() &#123; console.log(this);//指向window &#125;var bb = $.proxy(aa, obj);bb();// this指向obj了//第二种写法// var cc = $.proxy(obj, &apos;techang&apos;);// cc();//后面的函数必须就是obj里的函数 这个方法是用来改变this指向，在我们之前写的那个拖拽，就是可以用这个来改变指向，就不用bind()方法了。 4、noConflict( )防止变量冲突，例如当我们不想用jQuery的时候，引入其他库，那么其他库会有很多方法，可能会冲突，于是，我们把管理权限改一下。 123var aa = $.noConflict();//这样aa就代替$//以后写$就会出错，其他的库用$好使 5、$.parseJSON(json),字符转换成json 要求非常严格 外部是单引号 内部属性是双引号 不需要回车符. 1234var json = &apos;&#123;&quot;name&quot;: &quot;fa&quot;,&quot;age&quot;: 18&#125;&apos;;console.log($.parseJSON(json));&#123;name: &quot;fa&quot;, age: 18&#125; 6、$.makeArray,把类数组转化为数组。 1234var arrFalse = &#123; length: 0&#125;console.log($.makeArray(arrFalse));//[] jQuery高级方法$.extent()插件扩展，用来添加扩展，工具（类）方法。 $.fn.extent()，用来添加实例方法。记住是实例 不是工具方法 类方法（静态方法）：通过类直接访问，不需要声明类的实例来访问 实例方法（动态方法）：不能通过类直接访问，需要通过该类声明的实例才能访问。 简单来说，类方法，你可以直接调用访问，实例方法，就必须使用new来构造出来才能使用。 $.extend( )1234567$.extend(&#123; aa: function () &#123; console.log(11); &#125;&#125;)$.aa(); //11//可以自己写一个工具方法 $.fn.extent()123456789101112131415161718192021$.fn.extend(&#123; drag : function () &#123; //this ---&gt; jquery object由jQuery对象触发的 this.on(&apos;mousedown&apos;,function(e)&#123; //this -- &gt;dom，由DOM触发的事件 var disX = e.pageX - $(this).offset().left; var disY = e.pageY - $(this).offset().top; //this --&gt; div $(document).on(&apos;mousemove&apos;,$.proxy(function (e)&#123;//如果没有proxy就是指向document，有proxy就是指向原生div var newL = e.pageX - disX; var newT = e.pageY - disY; $(this).css(&#123;left: newL, top: newT&#125;);// &#125;,this) ) $(document).on(&apos;mouseup&apos;,function()&#123; $(document).off(); &#125;) &#125;) &#125;&#125;)$(&apos;div&apos;).drag(); 实例方法：就是之前写的拖拽。 $.Callbacks()看例子： 1234567891011121314151617181920function aa() &#123; console.log(&apos;aa&apos;);&#125;function bb() &#123; console.log(&apos;bb&apos;);&#125;function cc() &#123; console.log(&apos;cc&apos;);&#125;var oCb = $.Callbacks();oCb.add(aa);//aa函数加到Callbacks中oCb.fire();//执行Callbacks函数, aaoCb.add(aa, bb);oCb.fire();//执行Callbacks函数, aa bboCb.add(aa);oCb.add(aa);oCb.fire();//执行Callbacks函数, aa aa 加入once方法，只执行该方法一次： 1234var oCb = $.Callbacks(&apos;once&apos;);oCb.add(aa);oCb.fire();oCb.fire();// aa ,只执行一次fire()方法 加入memory方法，将函数提前 1234var oCb = $.Callbacks(&apos;memory&apos;);oCb.add(aa);oCb.fire();oCb.add(bb);//aa bb ,后面的bb肯定提升了 加入unique方法，相同的函数只执行一次 12345oCb.add(aa,aa,aa);只执行一次aavar oCb = $.Callbacks(&apos;memory&apos;);oCb.add(aa, bb , aa, cc);oCb.fire();//aa bb cc ,相同的只执行一次 加入stopOnFalse方法，来进行混合使用 12345678910111213function aa() &#123; console.log(&apos;aa&apos;);&#125;function bb() &#123; console.log(&apos;bb&apos;); return false;&#125;function cc() &#123; console.log(&apos;cc&apos;);&#125;var oCb = $.Callbacks(&apos;stopOnFalse&apos;);oCb.add(aa, bb , aa, cc);oCb.fire(); // aa bb 有ruturn false就截止了 jquery中的ajax( )jQuery里面的ajax方法非常厉害，它可以实现跨域还能实现使用jsonp来进行数据传输。它有以下几个参数。 1234567891011121.type:GET POST 访问形式2.url：访问路径，获取资源的路径3.data:传输数据 json格式，然后拼接成字符串 4.context：回调函数的作用域5.aync：是否异步 默认true6.cache：是否缓存 默认true 数据分分钟更新的时候比如说获取图片验证码此时我们就要添加false 事件上就是添加时间戳7.dataType：一般请求不予填写 jsonp请求是需要填写为jsonp8.success：访问成功是触发的函数 参数 是返回数据9.error：返回失败的时候触发的函数10.crossDomain：true跨域 默认false11.jsonp：在一个jsonp请求重写回调函数的名字，这个值用来替代在“callback=？”这种GET或POST请求中URL参数里的“callback”部分，比如&#123;jsonp：’onJsonPLoad’&#125;会导致“onJsonPLoad=？”传给服务器。12.jsonCallback:为jsonp请求指定的一个回调函数名。这只将用来取代jQuery自动生成的随机函数名。这主要用来让jquery生成独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名 可以举个例子： 123456789101112131415161718192021222324252627282930var input = document.getElementsByTagName(&apos;input&apos;)[0];input.onkeyup = function()&#123; var data2 = input.value;//获取输入框的输入信息进行搜索$.ajax(&#123; type:&quot;GET&quot;, url: &quot;https://api.douban.com/v2/music/search?q=&quot; + data2, data:data2, dataType:&apos;jsonp&apos;, success: function(data)&#123; console.log(data); &#125;, error:function(error)&#123; console.log(error); &#125;, //上面是ajax跨域 //下面是jsonp跨域必须要写的 //dataTppe: &apos;jsonp&apos;, //jsonp: &apos;cb&apos;, //jsonpCallback: &quot;doJson&quot; //可写可不写，有 // jsonp:&#123;&quot;start&quot;:0,&quot;count&quot;:10,&quot;total&quot;:20&#125;, crossDomain:true,//这个其实可以不用写 jsonpCallback: &quot;doJson&quot; &#125;) function doJson(data)&#123; console.log(data); &#125;&#125; $.deferred ()延迟对象 相当于有状态的Callback();拿上面的ajax( )方法举例子：12345678$.ajax(&#123;type:&apos;GET&apos;,url:&apos;getNews.php&apos;&#125;).done(function () &#123; console.log(&apos;done&apos;);&#125;)//成功了就触发这个函数.fail(function () &#123; console.log(&apos;fail&apos;);&#125;)//失败了就是这个函数//ajax是典型的$.deferred() 延迟对象 添加函数：done fail progress第一个是成功，第二个是失败，第三个是正在进行中。 触发函数： resolve reject notify即： 123oDf.resolve() -&gt; done(function()&#123;&#125;)oDf.reject() -&gt; fail(function()&#123;&#125;)oDf.notify() -&gt; progress(function() &#123;&#125;) 123456789101112131415161718192021222324var oCf = $.Deferred();oCf.done(function () &#123; console.log(&apos;done&apos;);&#125;)//成功了就触发这个函数.fail(function () &#123; console.log(&apos;fail&apos;);&#125;).progress(function () &#123; console.log(&apos;progress&apos;);&#125;)// function getDate() &#123;// oCf.resolve();// &#125;// getDate();//done，成功的状态// function getDate() &#123;// oCf.reject();// &#125;// getDate();//failfunction getDate() &#123; oCf.notify();&#125;getDate();//progress when()1$.when($.ajax(&#123;type:&apos;GET&apos;,url:&apos;getNews.php&apos;&#125;), $.ajax(&#123;type:&apos;POST&apos;,url:&apos;getNews.php&apos;&#125;) 传2个延迟对象，全部是成功的状态，才会触发done，其中一个失败就是失败。 好吧，那么关于jquery第四节课的知识就讲到这，希望大家能有所收获。 后面为大家讲一下jquery中的源码，一起加油吧。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"jquery","slug":"jquery","permalink":"http://moreluckily.com/categories/jquery/"}],"tags":[{"name":"-jquery","slug":"jquery","permalink":"http://moreluckily.com/tags/jquery/"}]},{"title":"jquery学习3","slug":"jquery学习3","date":"2018-10-05T11:46:18.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/10/05/jquery学习3/","link":"","permalink":"http://moreluckily.com/2018/10/05/jquery学习3/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习jquery。今天要讲一下jquery。这是一个很牛逼的js库。 遍历节点1.children() 方法 这个方法获得的是匹配元素的子元素。通过计算子元素长度，我们可以知道，该父级中有多少个子元素，注意的是不包含孙子辈的。 2.next()方法 该方法可以获得元素紧跟着的兄弟元素。 3.prev()方法 获得的是该方法前面的一个兄弟元素。 4.siblings()方法，这个方法是用来取得匹配元素所有的兄弟元素。 5.closest() 方法 这个方法获取的是元素的最近的祖先元素，可以有参数，selector能把自己选中 6.parent(),parents()与closest()区别 parent()：获得每个匹配元素的父级原宿 parents()：获得集合中每个元素的祖先元素 closest()：从元素本身开始，逐级向上匹配，并返回最先匹配到的祖先元素。 offsetParent()：寻找最近的有定位的父级。 加载DOM1.$(document).ready()方法可以在解析完成dom结构之后，就已经把事件绑定在元素身上了。这样有很大的好处，例如，在一个大型的网站，我们给图片绑定了事件，那么不用等到整个文档解析完成才可以进行操作，只要图片解析完成就能进行操作 新版本的API没有改变，但是操作起来是先触发了window.onload再触发ready事件函数。所以这一点有所保留，大家可以自行测试。 事件冒泡还记得事件冒泡吗？当我们触发一个子节点的事件的时候，它会自子元素向父级元素冒泡。 123456789101112131415&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;div class=&quot;grandson&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;$(&quot;.father&quot;).on(&apos;click&apos;,function()&#123; console.log(&apos;father&apos;);&#125;)$(&quot;.son&quot;).on(&apos;click&apos;,function()&#123; console.log(&apos;son&apos;);&#125;)$(&quot;.grandson&quot;).on(&apos;click&apos;,function()&#123; console.log(&apos;grandson&apos;);&#125;) 我们点击grandson，最后打印出来的是grandson,son.father.这就是冒泡，由子元素冒泡向父元素。 那么这样会出现一个问题就是，本来我们只想触发grandson的事件，但是连同他父级都一起触发了，这不是我们要的，于是就有阻止冒泡事件了。 阻止冒泡在jQuery我们可以使用事件对象里面的event.stopPorpagation()来阻止冒泡事件。这里有涉及到一个叫做事件对象的东西，就是我们在绑定事件处理函数的时候，系统会自动向事件处理函数传递一个参数“event”，它就是事件对象，上面有事件的各种方法属性。那么阻止冒泡就是上面的一个方法，jQuery的是经过包装的，兼容性很好，原生谷歌和IE的都不一样，这就不叙述了，可以看我之前的文章。那么现在在以上面的grandson为例，阻止冒泡。 1234$(&quot;.grandson&quot;).on(&apos;click&apos;,function()&#123; console.log(&apos;grandson&apos;); event.stopPropagation();&#125;) 阻止默认事件各种标签有自己的默认的事件，例如a标签自带跳转功能，button自带刷新页面功能等，有时候，我们需要组织元素的默认行为。这也是一个在事件对象上的方法。 1event.preventDefault(); 另外一种就是子函数里面直接”return false”. 1234567$(&apos;botton&apos;).on(&apos;click&apos;, function () &#123; var obj = &#123;&#125;; $(&apos;input&apos;).each(function (index, ele) &#123; obj[$(ele).prop(&apos;name&apos;)] = $(ele).val(); &#125;) return false;&#125;) 事件对象的属性1.event.type:该方法的作用就是可以获取事件的类型 2.event.preventDefault()，阻止默认事件 3.event.stopPropagation()，阻止冒泡事件 4.event.target，寻找事件源对象，这个兼容性很好，用于事件委托。就是一百万个li，每次点击都输出对应的内容，绑定事件在ul上面，然后找他的事件源对象，之后在输出li的内容。 5.event.pageX和event.pageY 该方法是获取光标相对于页面的X坐标和Y坐标,如果没有用jQuery的话，在IE上面就是使用event.x/y而火狐上面就是使用event.pageX/Y。 6.event.which,该方法作用是获取鼠标的左中右键，在键盘事件中获取键盘按键。 123456$(&apos;a&apos;).mousedown(function(e)&#123; console.log(e.which) //鼠标左中右分别打印出123.&#125;$(&apos;input&apos;).keyup(function(e)&#123; console.log(e.which) //获取键盘按键&#125; 移除事件我们利用off()来进行事件移除。 1234&lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;点击1&quot; /&gt;function btnClick1()&#123; &#125;$body.on(&quot;click&quot;, &quot;:button&quot;, btnClick1 );//为body中是button的input元素绑定click事件，处理函数是btnClick1.$body.off(&quot;click&quot;, &quot;:button&quot;, btnClick1);//接触函数，注意这里的选择器不能写&quot;#btn1&quot;,怎样绑定的就是怎样解绑的，形式要一样。另外如果帮了其他函数，之后解绑配对正确的那个函数. 利用类名来解绑： 12345678910111213141516$btn1.on(&quot;click.foo.bar&quot;, function(event)&#123; alert(&quot;click-1&quot;);&#125;);$btn1.on(&quot;click.test&quot;, function(event)&#123; alert(&quot;click-2&quot;);&#125;);$btn1.on(&quot;click.test.foo&quot;, function(event)&#123; alert(&quot;click-3&quot;);&#125;);$btn1.off(&quot;click.foo&quot;); // 移除click-1、click-3$btn1.off(&quot;click.foo.bar&quot;); // 移除click-1$btn1.off(&quot;click&quot;); // 移除所有click事件处理函数(click-1、click-2、click-3)$btn1.off(&quot;.foo&quot;); // 移除所有包含命名空间foo的事件处理函数，不仅仅是click事件 其他1、serialize 串联表单数据 serializeArray 串联数据成数组$(‘form’).serialize();把数据拼接成表单的形式 2、wrap wrapInner循环包裹 参数 functionwrapAll 包裹选中的所有元素 会破坏结构unWrap解除包装 结构化标签不能删除删除离它最近的一层 3、end() 回退操作closest() 查找最近的祖先节点 可以有参数selector 能把自己选中siblings() 当前元素节点的所有兄弟节点prevAll() 当前元素上面的所有兄弟节点nextAll() 当前元素下面的所有兄弟节点prevUntil() nextUntil —&gt;掐头去尾选中元素 动画show()方法和hide()方法 这两个方法是jQuery中最常用的动画方法。依赖于display的none。它们还可以穿进一个参数，可以是slow normal或者是false。也可以填写时间，单位是毫秒。 animate(attr,speed,callback),自定义动画方法 这个方法很强大，他有三个参数，第一个参数是包含样式和对应的值的对象，第二个参数是速度，单位毫秒，第三个参数是一个回调函数。 1234567$(function() &#123; $(&apos;somethings&apos;).click(function()&#123; $(this).animate(&#123;left:&quot;+500px&quot;&#125;,300,function()&#123;//累加变化，最后触发回调函数，改变宽高 $(this).css(&apos;border&apos;,&quot;5px solid blue&quot;); &#125;) &#125;&#125; stop(clearqueue,gotoend) 两个参数都是布尔值，第一个指的是，停止当前元素的当前动画，并在当前动画停止的位置开始当前元素的新动画。第二个参数指的是，停止当前元素的所有动画，直接到达动画的最后结束状态。 如果不传参数，则会停止当前动画并且在当前位置执行接下来的动画。 如果只传了一个true，那么表示清空当前元素的所有动画。 如果第一个为false，第二个为true，这种方式来让当前的动画直接到达末状态。 如果是两个都是true，那么表示停止当前动画并直接到达当前动画的末状态。 要注意的是，jQuery只能设置正在执行的动画的最终状态。 delay()方法 这个是对动画进行延迟执行，传毫秒为单位的参数。 好吧，那么关于jquery第三节课的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"jquery","slug":"jquery","permalink":"http://moreluckily.com/categories/jquery/"}],"tags":[{"name":"-jquery","slug":"jquery","permalink":"http://moreluckily.com/tags/jquery/"}]},{"title":"jquery学习2","slug":"jquery学习2","date":"2018-10-05T11:46:05.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/10/05/jquery学习2/","link":"","permalink":"http://moreluckily.com/2018/10/05/jquery学习2/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习jquery。今天要讲一下jquery。这是一个很牛逼的js库。 jQuery操作DOM查：最简单的方法就是利用选择器来进行选择，然后获取该节点的信息。 第二种方法就是，上一篇补充的内容讲过attr方法，它可以根据属性来获取元素，它的参数可以是一个，也可以是两个。当参数是一个的时候，就是要查询的属性的名字。 12var $para = $(&quot;p&quot;);var p_tet = $para.attr(&apos;title&apos;);//获取p元素的属性title 增：我们还可以利用jQuery来添加节点，而且可以是动态的创建HTML内容，是文档浏览器里面的呈现效果直接发生变化，最典型的一个例子，就是我们常常遇见的登录框，这个登录框是等我们点击登录的时候他才会出来的，不点击的时候它是没有的，如果利用html 建立一个元素，然后display:none，这样是很不“划算”的，最好的方法就是在js中，动态的创建。 创建节点 我们可以利用jQuery的$()函数进行创建，直接把想创建的html标签写在里面，他就可以创建创建出一个dom对象了，并将这个DOM对象包装成一个jQuery对象后返回。例如： 1var $div = $(&quot;&lt;div class=&quot;hhh&quot;&gt;哈哈哈&lt;/div&gt;&quot;);//可以有属性有文本，甚至是更加复杂的结构 这样就可以成功创建一个元素节点了，jQuery强大之处在于，即使你没有写完整，“”，它也能创建成功，当然，我们还是要按标准来。创建完成之后，我们需要将它插进到页面当中，利用append()方法。例如： 1$(&quot;body&quot;).append($div); 必须要最后插入到页面才能显示出来。 加class名上节课已经用了，在这里再介绍一下： 1234567891011121314//addClass() removeClass() 参数可以是function$(&apos;li&apos;).addClass(&apos;demo demo1&apos;);$(&apos;li&apos;).addClass(function (index) &#123; if(index % 3 === 0)&#123; return &apos;li-3&apos;; &#125;else &#123; return &apos;no-li-3&apos;; &#125;&#125;);$(&apos;li&apos;).removeClass(function (index) &#123; return &apos;li-3&apos;;&#125;)//移除这个 插入节点有许多种方法： insertBefore 插入到 ### 的前面 (有剪切的功能)before 在 ### 的前面 (有剪切的功能) appendTo: 添加到###的里面 (添加到最后一个子元素后)append: 里添加### (同上) 12345678$(&apos;.box1&apos;).insertBefore($(&apos;.box&apos;));//box1插在了box的前面//获取的是box1的对象$(&apos;.box&apos;).before($(&apos;.box1&apos;));//也是box1插在了box的前面//区别，.css()...。返回的都是前面的对象 1234567$(&apos;.box1&apos;).appendTo($(&apos;.content&apos;));$(&apos;.content&apos;).append($(&apos;.box&apos;));//都是插在了content的里面,操作的也都是前面的对象//prependTo prepend (添加到第一个元素前)$(&apos;.box1&apos;).prependTo($(&apos;.content&apos;));$(&apos;.content&apos;).prepend($(&apos;.box&apos;)); 注意的是，上述插入节点的方法，不仅能将新创建的DOM元素插入到文档中，它还有另外一个功能就是剪切元素，append可以将元素节点从原来的地方剪切，然后放到另外的地方。 12345678&lt;ul&gt;&lt;li&gt;香蕉&lt;/li&gt;&lt;li&gt;苹果&lt;/li&gt;&lt;li&gt;梨子&lt;/li&gt;&lt;/ul&gt;$apple = $(li:eq(1));$peach = $(li:eq(2));$peach.insertBefore($apple) //最后变成就香蕉 梨子 苹果 on()1.on()方法绑定事件，第一个参数传入事件类型，第二个参数是选择器,用来过滤掉某些子元素，如果没有，就是全部触发。第三个参数是为可选参数，是你需要被传到事件函数的参数，第四个参数是事件处理函数。 123$(&apos;div&apos;).on(&apos;click mousedown mousemove&apos;,function() &#123; console.log(333);&#125;//绑定多个事件类型 我们还可以给事件添加名字，例如： 1&apos;click.shijian&apos; 在后续的解绑，我们可以利用名字进行解绑。 还可以实现链式调用： 1234567$(&apos;box1&apos;).on(&apos;mousedowm&apos;,function () &#123; console.log(&apos;click&apos;);&#125;).on(&apos;mousedown&apos;, function () &#123; console.log(&apos;two&apos;);&#125;).on(&apos;mouseup&apos;, function () &#123; console.log(&apos;three&apos;);&#125;)//链式调用 123456789101112$(&apos;.box&apos;).on(&#123; mousedown: function () &#123; console.log(1); &#125;, mousedown: function () &#123; console.log(1); &#125;, mouseup: function () &#123; console.log(1); &#125; &#125;)//输出2，3。会覆盖前面的 12345678传数据：可以将obj传给evar obj = &#123; name = &apos;aimee&apos;&#125;$(&apos;box1&apos;).on(&apos;mousedowm&apos;, obj, function (e) &#123; console.log(e.data);&#125;) 12345678//ul下的li绑定该事件,实际是给ul绑定$(&apos;ul&apos;).on(&apos;mousedowm&apos;, &apos;li&apos;, obj, function (e) &#123; console.log(e.data);&#125;)//实际是给li绑定$(&apos;ul li&apos;).on(&apos;mousedowm&apos;, obj, function (e) &#123; console.log(e.data);&#125;) 2.one()方法绑定事件，这个跟on绑定差不多，但是这个事件绑定后只生效一次，下次再出发将不会有任何效果。。这个事件处理函数会接收到一个事件对象，可以通过它来阻止（浏览器）默认的行为。如果既想取消默认的行为，又想阻止事件起泡，这个事件处理函数必须返回false。 3.hover()方法 这个绑定事件的方法，用于模拟光标悬停事件，当光标移进，触发第一个函数，移出触发第二个函数。结合attr()更改类名，可以迅速的更该页面的样式。 12345$(&apos;h5&apos;).hover(function()&#123; $(this).attr(&apos;class&apos;,&apos;first&apos;)&#125;,function()&#123; $(this).attr(&apos;class&apos;,&apos;second&apos;)&#125;) 4.off()解除绑定 123456789$(&apos;li&apos;).off();$(&apos;ul&apos;).on(&apos;mousedown&apos;, &apos;li:odd&apos;, obj, function () &#123; console.log(1);&#125;).on(&apos;mouseup&apos;, function () &#123; console.log(2);&#125;)//&quot;li:odd&quot;,只能是子元素下的,即前面必须写ul//奇数打印12，偶数打印2 remove()remove方法可以将元素从dom中删除，传入的参数就是选择器。，而且要注意的是，利用这个方法，被删除的节点所绑定的事件将不复存在。不过，它会返回一个已删除的节点的引用，还能继续使用，但是没有了原来的事件而已。 2.detach() 这个方法和remove一样，都是可以删除所匹配到的元素。但是最大的区别在于，它不会把原来的事件也删除，下次使用的时候，事件能继续使用。 举个例子进行对比：(做一个小demo) 123456789101112131415161718192021222324252627282930 &lt;style&gt; .content&#123; width: 300px; height: 300px; background-color: red; border: 2px dashed #000; /* dashed虚线 */ &#125; .box&#123; width: 300px; height: 100px; background: orange; &#125; .box1&#123; width: 300px; height: 100px; background: green; &#125; .box2&#123; width: 300px; height: 100px; background: yellow; &#125; &lt;/style&gt;&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot;&gt;box&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; 12345678910111213$(&apos;.box1&apos;).appendTo($(&apos;.content&apos;));$(&apos;.box2&apos;).appendTo($(&apos;.content&apos;));$(&apos;.box1&apos;).on(&apos;click&apos;, function () &#123; a = $(this).remove();&#125;);$(&apos;.box2&apos;).on(&apos;click&apos;, function () &#123; b = $(this).detach();&#125;);$(&apos;.box&apos;).on(&apos;click&apos;, function () &#123; a.appendTo($(&apos;.content&apos;)); b.appendTo($(&apos;.content&apos;));&#125;); 可以得到下图所示的demo: 当点击box时，box中就会出现box1和box2，再点击box1，box1会消失，再点击box2，它也会消失，再点一下box，box1和box2都会回来。但再点击box1时，它不会再消失了，而box2的现象和之前的一样。得出结论： remove删除了就全部删除了detach就删除了还会保留remove点击第1下好使，第2下就不好使了detach无论点击多少下都好使 3.empty() 严格来讲，这个方法并不是删除节点，而是清空节点，他能清空元素中的所有后代节点。 复制节点复制节点，使用clone()方法来完成，被复制的节点不具有任何行为，即使不继承原来的事件，如果需要新元素，也具有复制功能，可以在clone方法传一个参数，true，这样就可以也有事件了 替换节点$a.replaceWith(b): 这个方法就是用b来替换a。 12$a = $(&apos;&lt;div&gt;hahaha&lt;/div&gt;&apos;);$(&apos;p&apos;).replaceWith($a);//用$a来替换p标签 $a.replaceAll(b): 这个跟第一个方法是相反的操作，它是用a来替换b。 要注意的是，如果在替换之前已经为元素绑定了事件，那么替换后原先绑定的事件将会域被替换的元素一同消失，需要重新绑定。 包裹节点jQuery提供了将某个节点用其他节点包裹起来的方法。 wrap()。该方法对于需要在文档当中插入额外的结构化标记非常有用，而且它不会破坏原始的文档的语义。 1$(&quot;strong&quot;).wrap(&apos;b&apos;)//利用b标签将strong标签包裹起来。 wrapAll()，这个方法将所有的匹配的元素用一个元素来包裹。它不同于wrap方法，wrap是将所有的元素进行单独的包裹。要注意的是，如果被包裹的多个元素间有其他元素，其他元素会被放到包裹元素之后。 wrapInner()：给每一个匹配的元素的子元素，用其他结构化的标记包裹起来。意思就是在父元素内部进行包裹。 属性操作讲到属性，又要提到attr()这个方法了，它可以用来获取和设置元素属性，还有另外一个方法就是removeAttr()用它可以删除元素属性。 1.获取属性和设置属性 如果要获取某个元素的属性，首先要给attr()方法传递一个参数，就是属性的名称。如果要设定属性，就要穿另外一个参数就是属性名称对应的值。如果需要一次性为同一个元素设定多个属性，可以利用对象的格式进行传值。例如： 123456$(&apos;a&apos;).attr(&apos;class&apos;); //获取a标签的class属性值$(&apos;a&apos;).attr(&apos;class&apos;,&apos;FE&apos;) //将a标签的class属性值设定为FE。$(&apos;a&apos;).attr(&#123; &apos;title&apos; : &quot;connection&quot;, &apos;name&apos; : &quot;a label&quot; &#125;);//将一个名值对形式的对象设置为匹配元素的属性 2.删除属性 当我们需要删除文档中某个元素的特定属性，可以使用removeAttr()方法来完成。传入的第一个参数就是需要删掉的属性，如果没有传参，它将会将所有的属性都删除。 3.添加样式 注意如果利用attr给class设定属性的话，它是会把原来的属性覆盖的。如果我们需要额外加一个属性，需要用到这个addClass()方法。它是具有一个追级属性追加属性的功能，即在原有的基础上，多添加一个属性。这个在我们更改某个元素的时候，如果需要更改元素的样式，可以通过修改它们的类型进行间接地修改，这样效率会很高。 4.删除样式 跟addClass相对的还有一个方法就是removeClass()，它的功能就是可以删掉匹配元素的某个类名或者全部类名。 5.切换样式 toggle()方法作用是可以交替执行两个代码，如果元素原来是显示的，则隐藏他，如果原来是隐藏的，则显示他。此时toggle()方法主要是控制行为上的切换。这个我们在事件中会再讲，今天主要讲它的引申，toggleClass(). toggleClass()可以控制样式上的重复切换。如果类名存在，则删除它，如果类名不存在，则添加它。例如： 1$(&apos;div&apos;).toggleClass(&apos;another&apos;) //重复切换类名‘another’ 我们可以来一个点击事件，当点击某个按钮的时候，触发一次类名的切换，来换取不同的样式。 6.判断样式是否存在 利用hasClass()可以用来判断元素中是否含有某个class，如果有则返回true，如果没有则返回false。 设定和获取html，文本的值 1.html()方法 这个方法依赖于原生的innerHTML属性，可以利用它来读取或者设置某个元素中的html内容，如果不传参数，就是读取内容，如果传参就是为某元素设定HTML内容。 2.text()方法 这个方法依赖于原生的innerText属性，可以用来读取或者设置某个元素的文本内容。它的操作方法跟html()是一模一样的。这里就不再赘述了。 3.val()方法 此方法跟JavaScript原生的value属性类似，可用来设置或获取元素的值。典型的就是输入框的聚焦和失焦的例子。 123456789101112&lt;input id=&quot;address&quot; value=&quot;id&quot;&gt;$a = $(&apos;#address&apos;);$a.focus(function()&#123; if($a.val() == &quot;hh&quot;)&#123; $(this).val(&quot;&quot;); &#125;&#125;)//聚焦清空$a.blur(function() &#123; if($a.val() == &quot;&quot;)&#123; $(this).val(&quot;hh&quot;); &#125;&#125;//失焦之后填写hh css-dom 操作1.css() 这个是很厉害的一个方法，可以通过它来设定元素的css属性,之前已经介绍过了，现在就不再介绍了。 2.offset()方法 它的作用是获取元素在当前是视窗的相对偏移，其中返回的对象有两个属性，即top和left。它们只对可见元素有效。 123var offset = $(&apos;p&apos;).offset();var left = offset.left;var top = offset.top; 3.position() 它是获取元素相对于最近的一个position样式属性设置为relative或者absolute的父节点的相对偏移。返回值和操作同上。 4.scrollTop()方法和scrollLeft() 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左端的距离。可以传递一个参数，空值元素的滚动台滚动到指定位置。例如： 12$(&apos;div&apos;).scrollTop(300);$(&apos;div&apos;).scrollLeft(300); innerWidth 宽度: content paddingouterWidth 宽度: content padding border 。(宽度: 参数为true的时候 求出的宽度带有margin) 小demo写一个小demo，动态的创建一个小弹窗：它类似于百度登录一样，当点击百度主页的登录时，会动态的弹出一个小弹窗。 1234567891011121314151617181920 &lt;style&gt; .box&#123; position: absolute; left: 50%; top: 50%; width: 400px; height: 400px; margin-left: -200px; margin-top: -200px; display: none; border: 1px double red; border-width: 5px; &#125; .btn&#123; position: absolute; right: 0; margin: 10px; &#125; &lt;/style&gt;&lt;button type=&quot;&quot; class = &quot;show&quot;&gt;登录&lt;/button&gt; 中间得引入jquery.js文件：123456789101112var oDiv = $(&apos;&lt;div&gt;&apos;);oDiv.addClass(&apos;box&apos;);var oBtn = $(&apos;&lt;button&gt;X&lt;/button&gt;&apos;);oBtn.appendTo(oDiv);oBtn.addClass(&apos;btn&apos;);$(&apos;body&apos;).append(oDiv);$(&apos;.show&apos;).on(&apos;click&apos;,function()&#123; $(&apos;.box&apos;).css(&apos;display&apos;,&apos;block&apos;);&#125;);$(&apos;.btn&apos;).on(&apos;click&apos;,function()&#123; $(&apos;.box&apos;).css(&apos;display&apos;,&apos;none&apos;);&#125;); 当我们点击登录时，会弹出一个小弹窗，小弹窗的右上方有个关闭按钮，点击它，小弹窗就没有了，和百度主页登录的原理是一样的。 好吧，那么关于jquery第二节课的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"jquery","slug":"jquery","permalink":"http://moreluckily.com/categories/jquery/"}],"tags":[{"name":"-jquery","slug":"jquery","permalink":"http://moreluckily.com/tags/jquery/"}]},{"title":"jquery学习1","slug":"jquery学习1","date":"2018-10-05T11:37:41.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/10/05/jquery学习1/","link":"","permalink":"http://moreluckily.com/2018/10/05/jquery学习1/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习jquery。今天要讲一下jquery。这是一个很牛逼的js库。 jQuery特点jQuery是一个非常优秀的js库，它jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等 在我们学习jQuery的时候，首先要明确，jQuery只是辅助工具，不能完全代替js，方法再全也是会有缺失的，我们主要是学习它的编程思想，把主要方法运用熟练，对于一些不常用的方法，我们先理解其用途，现用现查API。 zepto是从jQuery演变过来的，zepto是移动端的开发库。 DOM对象和jQuery对象的区别在正式讲jQuery的时候，我们必须要先分清楚，DOM对象和jQuery对象之间的区别。 DOM对象之前已经讲过，它就是文档对象模型（Document Object Model）,它可以使用JavaScript的原生方法。 jQuery对象是jQuery独有的对象，它是通过jQuery包装DOM对象后产生的对象。只有jQuery对象能够使用jQuery的方法，原生的DOM是不可以使用jQuery的方法的。而且，jQuery对象无法使用DOM对象的任何方法。例如： 12$(&apos;#foo&apos;).html(); //获取id为foo的元素内的html代码，html()是jQuery的方法$(&apos;#foo&apos;).innerHTML //错误，因为jQuery 不能使用DOM的方法。 等价于: 12document.getElementByid(&apos;foo&apos;).innerHTML;//正确，原生的使用原生的方法document.getElementById(&apos;foo&apos;).html//错误,原生的不能使用jQuery的方法 另外还有一点就是关于jQuery和DOM对象的编码风格，如果是jQuery对象的变量需要在变量名之前加一个$符。 12var $aa = jQuery对象aavar aa = dom原生对象aa 还有最重要的就是jquery返回的是一个对象，而原生的东西返回的是一个类数组，这点不要弄错了哦。 下载jQuery库在官网上下载jquery库文件，注意有两个文件，一个是压缩版的，还有一个就是为压缩的，上线的时候用压缩版本的，学习的时候当然是使用未压缩的咯，因为那样比较好理解。 首先通过script标签将jquery.js文件引进去，然后我们就能使用jquery的方法去操作html和css了。 要注意一点就是，为了防止污染全局变量，在进行编程时候，通常都会使用代码块进行编写。 12345(function () &#123; window.jQuery = jQuery; window.$ = window.jQuery; function jQuery() &#123;&#125;)(); 这样写就可以在全局中使用jQuery函数，而不污染全局变量。 jQuery选择DOM对象的时候，可以这样： 12$(dom) //一个函数执行的形式，将dom转化为jQuery对象jQuery(dom) //也是可以的 例如我们想选择li: 123$(&apos;li&apos;); // 他会把所有的li都返回给我们，是一个对象，是一个jQuery对象。如果想单独想选出某一个li，可以利用eq();$(&apos;li&apos;).eq(1) //选出索引为1的li。 在jquery里有一些必须提前讲的内容，就是jquery为什么能链式调用呢？ 12345678910function jQuery(selector, content)&#123;//（选择器，执行期上下文）。 return new Jquery.prototype.init(selector,content);&#125;jQuery.prototype.init = function (selector, content)&#123; var dom = document.getElementsByTagName(selector); for(var i = 0; i &lt; dom.length; i++)&#123; this[i] = dom[i]; &#125; return this;//把jQuery对象返回出来实现链式调用&#125; 同样的，eq函数也是挂在jQuery原型链上面的。因为选出来的jQuery对象，是利用init构造出来的对象，要再次调用eq方法的时候，如果init和eq不在同一个原型链上的话，就不能选中: 1234jQuery.prototype.eq = function () &#123; console.log(&quot;eq function&quot;);&#125;jQuery.prototype.init.prototype = jQuery.prototype;//因为要使init和eq在同一个原型链 那么jQuery出来的对象就是有init构造出的。这个稍微在这提一下，在后面的源码博文会再次讲一下。 $(null);这个是什么都选不到的，但是不会报错。 jQuery操作cssjQuery的选择器完全继承了css的风格，利用jQuery选择器，可以非常便捷和快速地找出指定的DOM元素，然后为它们添加相应的行为，而且不需要担心兼容性的问题。功能非常强大。 jQuery选择器分为基本选择器层次选择器、过滤选择器、和表单选择器。 基本选择器基本选择器是jQuery中最常用的选择器，也是最简单的选择器，通过id、class等查找DOM元素。 12345#id : $(&apos;#test&apos;) ，选出id为test的元素。选出来的是一个元素.class : $(&apos;.test&apos;),选出所有类名为test的元素，注意是全部，所以说这返回的是一个集合。element: $(&apos;p&apos;),选出所有p标签，返回一个集合* : $(&apos;*&apos;)选出所有元素$(组合) :$(p #id .class) 将所有匹配到的元素合并后一起返回。 DOM不能统一操作，要for循环,其实jquery里也是用了for循环的 再举一个作为例子： 1234$(&apos;#demo&apos;).css(&#123; &quot;width: &quot;100px&quot;, &quot;height&quot;: &quot;100px&quot; &#125;) //将id为demo的元素宽高都设定为100px 层次选择器如果想通过DOM元素之间的层次关系来获取特定的元素，例如后代元素，子元素，兄弟元素等，那么层次选择器是一个很好的选择。 1234$(&apos;father son(grandson)&apos;) : 选取父元素下面的所有子包括孙子辈的元素，返回的是一个集合。$(&apos;father son&apos;) : 选取父元素下面的子元素，不包括孙子辈的，返回一个元素。$(&apos;prev + next&apos;) : 这是一个css3的选择器，选取的是紧接在prev元素后的next元素。要注意的是，next是它的兄弟元素。$(&quot;prev~siblings&quot;) : 选取prev元素之后的所有siblings，是一个集合元素，注意是所有兄弟元素。 来个例子： 12$(&apos;div + li&apos;).css(&apos;display&apos;,&quot;inline-block&quot;) //将div后面的第一个li元素变为行级块元素$(&apos;div &gt; li&apos;).css(&apos;background&apos;,&apos;red&apos;) //将div的所有子元素变为红色 在来个例子： 12345$(&apos;ul&gt;li:first&apos;);$(&apos;ul&gt;li:eq(2)&apos;);$(&apos;ul&gt;li:odd/even&apos;);$(&apos;ul&gt;li:odd&apos;)奇数$(&apos;ul&gt;li:even&apos;)偶数 另外就是，jQuery里有个方法就是nex(),它可以代替 $(‘prev + next’),nextAll()，可以代替 $(“prev~siblings”)。 12$(&quot;prev&quot;).next(&apos;next&apos;);$(&apos;prev&apos;).nextAll(&apos;div&apos;); 另外还有一个siblings()方法，它也能选择出兄弟元素，但是没有前后位置的限制，只要是兄弟就行。 过滤选择器过滤选择器主要是通过特定的过滤规则选出所需要的DOM元素，过滤规则与css中的为类选择器语法相同，也是用一个冒号开头，按照过滤选择器的不同规则，又分为基本过滤 内容过滤 可见性过滤 属性过滤 子元素过滤等。 基本过滤选择器（没有声明的都是返回一个元素集合）12345678910:first ： 选取出第一个元素，返回的是单个元素。:last ： 选取出最后一个元素，返回的也是单个元素。:not ： 去除所有的与给定选择器匹配的元素:even ： 选取索引为偶数的所有元素，索引从0开始:odd ：选取索引是奇数的所有元素:eq(index)：选取索引等于index的元素，返回的是单个元素:gt(index)：选取索引大于index的元素:lt(index)：选取索引小于index的元素:animated ：选取当前正在执行动画的所有元素:focus ：选取当前获取焦点的元素 内容过滤选择器内容过滤选择器规则主要体现在他所包含的子元素或文本内容上。 1234:contains(text)：选取含有文本内容为text的元素:empty(text) ：选取不包含子元素或文本为空的元素:has(selector) ：选取含有选择去所匹配到的元素的元素，$(&quot;div:has(p)&quot;)选取含有p标签的div元素:parent ：选取含有子元素或者文本元素的元素 可见性过滤选择器可见性过滤选择器是根据元素的可见和不可见状态来选择相应的元素。 12:hidden ： 选取所有不可见的元素，包括&lt;input type=&quot;hidden&quot;/&gt;&lt;div display=&quot;none&quot;&gt;和 &lt;div style=&quot;visvility:hidden;&quot;&gt;等元素，如果想只选择input，就可以这样$(&quot;input:hidden&quot;):visible：选取所有的可见元素。$(&quot;div:visible&quot;)选取所有的可见的div元素。 属性过滤选择器属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素。 123[attr] : 选取拥有此属性的元素[attr=value] : 选取拥有attr属性并且值为value的元素[attr!=value] : 选取attr属性不等于value的元素 这个属性过滤选择器还有很多，还有以value开头的，以value结尾的等等，这里就讲主要的几个。读者可以到jQuery中文网自行查阅。 子元素过滤选择器:nth-child(index/even/odd) ： 选取所以为index/偶数/奇数的子元素，要注意的是这里的index是从1开始的。这个选择器很常用，主要讲一下，它还能按照倍数进行选择，例如: 1$(&quot;div:nth-child(2n)&quot;)能选出每个父元素下的索引值是3的倍数的元素，n从1开始 :last-child ：选取每一个父元素的最后一个子元素 :first-child : 选取每一个父元素的第一个子元素 补充最后补充一些相关知识，还有就是为接下来的做铺垫。 1、window.onload事件触发完之后，再触发$()函数的里面的东西。这个在旧版本是先完成$()在触发window.onload事件的，现在改过来了，先触发window.onload,在执行$()函数的。 2、之前讲过的上下文，$(‘li’,’ul’) ，意思就是将ul下面的li选择出来。有点类似于子元素选择器。 3.html()方法，如果我们没有传值的话，就会打印出调用该方法的对象的html内容，html()当取值时，是取第一个 赋值赋一组。如果传值，则会覆盖原来的内容。 text()函数也是一样的。 4.在jQuery点击事件中， this指的是原生的DOM我们需要包装一下$(this)，才能在jQuery中使用。 5.attr()设定属性，获取属性，主要依赖于原生的getAttribute和setAttribute，它可以操作的是特性，天生就有的。 6.prop()，主要依赖的是js中的 element[property] 和 element[property] = value;它里面的属性是普通属性，直接通过js来设置元素的属性，这样的不会在页面html更新的。 7.根据官方的建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() 8.index()方法可以查看当前兄弟节点的索引。 9.filter()和not()1234567filter(&apos;.box/[title=hello]&apos;);过滤的意思$(&apos;li&apos;).filter(function (index) &#123; return index%3 === 0;&#125;).css(&apos;background-color&apos;,&apos;red&apos;);//是true就返回出来，过滤的意思//not()就是选出来不要 10.has()和find()12$(&apos;li&apos;).has(&apos;div&apos;);//选择的是li$(&apos;li&apos;).find(&apos;div&apos;)//选择的是div 11.is() 12$(&apos;li:eq(0)&apos;).is(&apos;.item&apos;);//判断是不是同一个东西是同一个就true,不是就是false 12.attr()和prop() 123456$(&apos;.item&apos;).attr(&apos;draw&apos;,&apos;well&apos;);&lt;li class=&quot;item&quot; draw=&quot;well&quot;&gt;0&lt;/li&gt;//相当于 setattribute 或者 getattribute.prop()$(&apos;.item&apos;).prop(&apos;draw&apos;,&apos;well&apos;);相当于 oLi.draw = well; 一个小demo点击div，弹出div里的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.wrapper&#123; width: 500px; height: 500px; border: 2px double red; border-width: 5px;&#125;.wrapper .box1&#123; text-align: center;&#125;.wrapper .box1 button&#123; width: 50px; height: 50px; background-color: #f40; margin-right: 50px;&#125;.wrapper .content&#123; position: relative; width: 500px; height: 450px;&#125;.wrapper .content div&#123; display: none; font-size: 50px; width: 500px; height: 450px; background-color: deepskyblue; text-align: center; line-height: 450px; color: orangered&#125;.wrapper .box1 .show&#123; background-color: yellow;&#125;.wrapper .content .active&#123; display: block;&#125;&lt;/style&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;box1&quot;&gt; &lt;button class = &quot;show&quot;&gt;1&lt;/button&gt; &lt;button&gt;2&lt;/button&gt; &lt;button&gt;3&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class = &quot;active&quot;&gt;moreluck&lt;/div&gt; &lt;div&gt;morelucky&lt;/div&gt; &lt;div&gt;moreluckily&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 引入jquery.js文件，并用jquery的方法去写该代码：12345678910&lt;script src = &quot;./../jquery-3.2.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&apos;button&apos;).click(function()&#123; $(&apos;.show&apos;).removeClass(); $(this).addClass(&apos;show&apos;); var num = $(this).index(); $(&apos;.active&apos;).removeClass(); $(&apos;div&apos;,&apos;.content&apos;).eq(num).addClass(&apos;active&apos;); &#125;) &lt;/script&gt; 得到如下图所示的小demo： 当点击1时，会出现1中的内容，点击2时，出现2中的内容，点击3时，出现3中的内容。 好吧，那么关于jquery第一节课的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"jquery","slug":"jquery","permalink":"http://moreluckily.com/categories/jquery/"}],"tags":[{"name":"-jquery","slug":"jquery","permalink":"http://moreluckily.com/tags/jquery/"}]},{"title":"Iframe","slug":"Iframe","date":"2018-10-02T05:01:37.000Z","updated":"2018-10-23T02:43:15.537Z","comments":true,"path":"2018/10/02/Iframe/","link":"","permalink":"http://moreluckily.com/2018/10/02/Iframe/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习网络。今天要讲一下网络中Iframe的一些知识。 iframe之间我们使用jsonp来进行跨域，iframe也能实现跨域。 iframe就是一个标签dom元素，可以在网页里面嵌入另一个网页。它里面有几个属性。 src: 新页面的地址，可以填其他网址，例如百度啦，淘宝啦之类的。 frameborder：新页面的边框大小。 width,height设置宽高等等。 还有其他就不举例了，因为很少用。 iframe应用1.iframe应用在一些tab页面，点击一个tab页，切换到该页面，但是并不会整个页面刷新。就是刷新点击的那部分即可。但是，缺点就是，这个iframe非常卡，用起来效率不高。因为他需要把所有的页面都加载过来才算整个页面加载完，换句话就是，必须要等到所有的iframe嵌入面加载完，window.onload事件才会触发。这样会使加载时间特别长，让我们看起来特别卡。 iframe也有一个onload事件，看下面代码： 123456widnow.onload = function ()&#123; console.log(444);&#125;iframe.onload = function () &#123; console.log(333);&#125;//先打印333后打印444 2.iframe还可以做一个在线实时的编辑器，通过获取我们输入的代码，直接前进iframe标签里，于是就可以显示出内容。 iframe 利弊当我们利用iframe打开一个新窗口的时候，新窗口自然会有一个window对象，而本身父窗口也是有window对象的，于是这里就有一些关系了。 获取iframe内的window121.document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow(子窗口)2.document.getElementsById(&apos;iFr&apos;).contentWindow 简易写法 1window.iframeName (iframe的name) IE专用 123.document.iframes[name].contentWindow4.document.iframes[i].contentWindow 来个例子，我们建立两个页面，第一个叫a页（父窗口），第二个叫b页（子窗体）。子窗口里面有一个b变量，我们要在a窗口中访问这个b变量，应该怎样做呢？请看下列代码： 父窗口中： 1234&lt;iframe src=&quot;b.html&quot; frameborder=&quot;1&quot; width=&quot;300&quot; height=&quot;300&quot; id=&quot;b&quot;&gt;&lt;/iframe&gt;var a = 1;var bIframe = document.getElementById(&apos;b&apos;);//先获取到子窗口console.log(bIframe.contentWindow.b); //获取到子窗口中的window，在访问b变量 子窗口中： 1var b = 2; 但是这样访问是不成功的，最后是报出的undefined，这里有一个同步和异步的点，首先解析到iframe标签的时候，取src请求资源，接着不会阻塞页面，继续访问script标签，但是，在资源还没请求回来的时候，就要访问，所以是undefined。 解决这个问题，我们需要的是，当iframe加载完再执行这个操作。 123456789bIframe.onload = function () &#123; console.log(bIframe.contentWindow.b)&#125;//这样就可以了iframe.onreadystatechange = function()&#123; if (iframe.readyState == &quot;complete&quot;)&#123; alert(&quot;Local iframe is now loaded.&quot;); //第二种判断方法 &#125; &#125; 如果我们想反过来，在b里面打印a页的a变量。就需要这样写： 在子窗体： 1console.log(window.parent.one)//这个跟前面的不一样，它是已经解析完毕再执行。 窗口的其他属性window.self: 指的就是window window.parent: 父级窗口的对象 window.top: 找的是该网页的顶级窗口。 例如现在有三个页面分别是abc，a页里面有个变量a为1，b页里面也有个变量a为2，c页如果写这样的代码： 1console.log(window.top.a)//打印出来的是1.因为找的是顶级窗口 iframe 实现跨域1.对于iframe，document.domain是最后的解决方法，他们的基础域名相同即可。 2.利用window.location.hash，哈希值，决子页面访问父页面数据问题(window.location.href)。之前在最后的JavaScript那篇文章稍微提了一下，现在再说一下。 现在我们在页面写这样一段代码： 123456789101112&lt;a href=&quot;#aa&quot;&gt;&lt;br&gt;*200&lt;div id=&quot;aa&quot;&gt;width: 100px;height: 100px;background-color: red;&lt;/div&gt;&lt;div id=&quot;bb&quot;&gt;width: 100px;height: 800px;background-color: green;&lt;/div&gt; 那么当我们点击a标签的时候，就可以回到aa中。这个时候，我们观察输入框可以发现这个时候在URL后面添加了“#aa”，这个字符，这是一个简单的锚点功能 这个时候，我们写这样的代码： 12window.location.hash // &quot;#aa&quot;window.location.href // &quot;url#aa&quot; 可以看到，当我们使用hash的时候，返回的就是这个URL后面的部分，href就是整个URL地址。 哈希值的特点就是，当它发生改变的时候，页面不会刷新，这样我们就可以利用这个进行传值。 父窗口箱子窗口传值例如，同样ab两个页面，我们在a里面设定值，传给b使用。 a页中： 12345&lt;iframe src=&quot;b.html&quot; width=&quot;300&quot; height=&quot;300&quot; id=&quot;b&quot;&gt;&lt;/iframe&gt;var one = 1;var oneIframe = document.getElementsById(&apos;one&apos;);var oneSrc = oneIframe.src;oneIframe.src += &quot;#&quot; + one; b页中：1console.log(window.location.hash);// “#1” 通过哈希获取值 这个时候，我们可以利用点击事件，点击某个地方之后，将哈希值传过去。但是这里有个先后顺序的问题，例如，点击事件之后，我们需要将a页设定的哈希传到b页，在b页打印出来。这个时候，我们需要在b打印之前，把a传过去，因为，如果b都打印了，即使传过去了，也不会再打印，这个时候，我们用一个很low的方法，就是用计时器。。。 a页中： 123456var bIframe = document.getElementById(&apos;one&apos;);var oneSrc = oneIframe.src;document.onclick = function ()&#123; bIfram.src = oneSrc; oneIframe.src += &quot;#&quot; + one;&#125; b页中： 1234567var twoHash = window.location.hash;setInterval(function ()&#123; if(twoHash !== window.location.hash)&#123; twoHash = window.location.hash; console.log(window.locatio.hash); &#125;&#125;,0) 这样就可以实现父窗口向子窗口传值了。哈希值传值也是很不安全的，而且传递数据量有限。 子窗口向父窗口传值这个时候，我们就可以利用name属性进行传值了。在同一个窗口中，name值是会一直保持的，只要保持该窗口打开。于是我们就可以利用name进行传值了。 例如：在淘宝中输入window.a = ‘a’;再在百度中打开，输入window.a并不会出现’a’;Console窗口不关闭,但在其中输入window.name = ‘a’;再在百度中打开，输入window.a会出现’a’。 注意就是，在子窗口b中利用（window.contentWindow.name）来获取name的值是会报错的。因为子窗口是跟父窗口a不同源。 于是我们需要引入一个中间人c，该中间人是和子窗口b同源的，这样c就可以获取b的name值了。 a页中： 12345678910var bIframe = document.getElementById(&apos;one&apos;);//获取子窗体var flag = 0;//锁，只如果没有锁，将会在b页c页之间来回刷新oneIframe.onload = function () &#123; if(flag == 0);&#123; flag = 1; oneIframe.src = &quot;c.html&quot;;//three是与子窗体同源的一个中间人，通过它来获取b中的name。 &#125;else&#123; console.log(oneIframe.contentWindow.name); &#125;&#125; b页中： 1window.name = &quot;b&quot;; 通过name就可以通过子窗体传数据给父窗体，实现跨域。 还有一点要注意的就是，中间人页面什么都不要需要写，因为它只起一个传递作用。 好吧，那么关于Iframe的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"网络","slug":"网络","permalink":"http://moreluckily.com/categories/网络/"}],"tags":[{"name":"-网络","slug":"网络","permalink":"http://moreluckily.com/tags/网络/"}]},{"title":"Cookie","slug":"Cookie","date":"2018-10-02T05:01:15.000Z","updated":"2018-10-23T02:43:15.474Z","comments":true,"path":"2018/10/02/Cookie/","link":"","permalink":"http://moreluckily.com/2018/10/02/Cookie/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习网络。今天要讲一下网络中Cookie的一些知识。 什么是cookie今天来讲一下cookie，昨天我们讲了，http是一个无状态的协议，无状态指的是，当我们建立了一个连接之后，可以进行数据交互了，当这个链接一断开，服务器和浏览器之间就不存在任何联系了。这个时候，当我们存在重复请求同一个资源的时候，如果每次都去服务器获取是非常耗时间的，于是就有一个cookie了。 很多情况下，我们的账号密码输入第一次的时候，都会被记录下来，那么下次我们再一次登陆的时候，如果账号密码没有修改，那么我们就可以直接使用使用被记录下来的账号密码即可。具体流程是这样的： 当我们第一次发送请求的时候，服务器发现如果是新的请求，会返回一个ID，并且有一个set-cookie：id=“xxx”,会返回到浏览器的数据库当中，当下次再次访问的时候，浏览器会把cookie值发送到服务器中，如果没有改变，那么就直接取浏览器缓存的数据即可。 要注意的是，昨天说过的ETag值是唯一标识，它主要应用于网页，json或者是xml，但是cookies，主要是应用于账号密码等一些小数据当中。 那么什么是cookie呢？ Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），（服务器告诉浏览器设置一下cookie），浏览器会将Cookie以key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。 Cookie就是一个小型文件，大小大概4k。（浏览器对cookie的内存大小是有限制的——-用来记录一些信息） 在浏览器中的application中的cookie中可以查看cookie的信息。 cookie特点满足同源策略 虽然网站images.google.com与网站www.google.com同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。 问题来了 举个例子： 访问zhidao.baidu.com 再访问wenku.baidu.com还需要重新登陆百度账号吗？ 这个时候，他们是域名不相同的网站，但是它们的基础域名相同，这个时候，我们就可以使用这个： 1document.domain = &apos;baidu.com&apos;; 那么它们就可以互相访问彼此之间的cookie了。这个方法我们昨天讲跨域的时候也讲过，document.domain是必须要基础域名相同才好使的。 在报文是这样的：set-cookie： name=”Steven”; domain=”baidu.com”;表示设置一个cookie名为Steven，基础域名为baidu.com都能使用。 操作cookie设置cookie的时候，默认是临时的cookie，意思就是一旦页面关闭，cookie就会自动删除，我们需要把它设定一个保质期。 设定保质期有两种方法，第一种是利用expires另一种是利用max-age。 123var oDate = new Date();oDate.setDate(oDate.getDate()) + 1);document.cookie = &apos;name = &quot;hh&quot;;expires= &apos; + oDate;//字符串形式，cookie明天过期 还有一个要注意的地方，利用max-age设定时间，是按照格林威治时间，中国在东八区，需要有八个小时的时差。 删除cookie，可以利用修改保质期，把max-age写成0，或者，将expires设定为当前日期前的一天。 查询cookie，首先利用字符串方法分割成数组，再遍历数组，将获取到的cookie进行判断是否是我们需要的那个信息，如果是就继续操作即可。不是就跳出。 12345var oDate = new Date();oDate.setDate(oDate.getDate() + 1);console.log(document.cookie); //就可以打印出来了，存到了明天document.cookie = &apos;name = &quot;hh&quot;;expires= &apos; + oDate;document.cookie = &apos;name = &quot;hh&quot;;max-age= 10&apos;;//按秒来算，但注意时差 封装cookie函数1234567891011121314151617181920212223242526var cookie = &#123;//名 值 时间 setCookie : function(key, val, date)&#123; //增和改 //设置cookie var oDate = new Date(); oDate.setDate(oDate.getDate() + date); //document.cookie = &apos;name = &quot;hh&quot;;expires= &apos; + oDate; document.cookie = key + &apos;=&apos; + val + &apos;;expires=&apos; + oDate; return this;//实现链式调用 &#125;, removeCookie : function(key)&#123; //删 this.setCookie(key,&apos;&apos;,-1); return this;//实现链式调用 &#125;, getCookie : function(key,callback)&#123; //获取 var str = document.cookie; var arr = str.split(&apos;;&apos;);//类数组 arr.forEach(function(item)&#123; var itemArr = item.split(&apos;=&apos;); if(itemArr[0] == key)&#123; callback ? callback(itemArr[1]) : &apos;&apos;;//判断是否有传回调函数，有就用，没有就来一个空串。 &#125; &#125;) return this; 小方块使用cookie记录位置设置一个小方块，用cookie去记录它的位置，当关闭网页再次打开后，能让该方块回到最后关闭的那个位置。 第一次拖拽的时候，查看是否有cookie，没有进行正常拖拽，并记录下最后的位置，下次打开的时候，直接使用之前的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;style&gt; #demo&#123; position: absolute; left: 100px; top: 100px; font-size: 30px; text-align: center; line-height: 100px; width: 100px; height: 100px; background: red; &#125;&lt;/style&gt; &lt;div id=&quot;demo&quot;&gt;小方块&lt;/div&gt;&lt;script&gt; var cookie = &#123; setCookie:function(key,val,date)&#123; var oDate = new Date; oDate.setDate(oDate.getDate() +date); document.cookie = key + &apos;=&apos; +val +&apos;;expires=&apos; +oDate; return this; &#125;, removeCookie:function(key)&#123; this.setCookie(key,&apos;&apos;,-1); return this; &#125;, getCookie:function(key,callback)&#123; var str = document.cookie; var arr = str.split(&apos;; &apos;); arr.forEach(function(item)&#123; var itemArr = item.split(&apos;=&apos;); if(itemArr[0] == key)&#123; callback ? callback(itemArr[1]) : &apos;&apos;; &#125; &#125;) return this; &#125; &#125;var oDemo = document.getElementById(&apos;demo&apos;); var dragFun = &#123;//定义一个对象，来存放，更加模块化，避免污染全局变量 init: function(dom)&#123;//入口函数，获取div,并且作为一个参数，做更多的操作 this.oDiv = dom;//所有函数都能使用这个dom，定义在drag就可以使得所有drag里的函数都能用。 cookie.getCookie(this.oDiv.id,function(data)&#123; //进入浏览器，如果之前有cookie,就保存了 var arr = data.split(&apos;&amp;&apos;); dom.style.left = arr[0] + &apos;px&apos;; dom.style.top = arr[1] + &apos;px&apos;; &#125; ) this.bindEvent(); &#125;, bindEvent: function()&#123; this.oDiv.onmousedown = this.onDemoDowm.bind(this); //改变this指向，指向了dragFun &#125;, onDemoDowm: function()&#123;//鼠标按下,记录下鼠标的位置 this.disX = event.clientX - this.oDiv.offsetLeft; //记录鼠标到div左边框的距离 this.disY = event.clientY - this.oDiv.offsetTop; document.onmousemove = this.onDemoMove.bind(this); //一般都放在document上 document.onmouseup = this.onDemoUP.bind(this); //改变this指向让他指向drag。不改变就是指向odiv &#125;, onDemoMove: function()&#123;//鼠标移动 var newLeft = event.clientX - this.disX; var newTop = event.clientY - this.disY; this.oDiv.style.left = newLeft + &apos;px&apos;; this.oDiv.style.top = newTop + &apos;px&apos;; this.positionStr = newLeft + &apos;&amp;&apos; + newTop; //坐标拼接 &#125;, onDemoUP: function()&#123;//鼠标抬起 document.onmousemove = null; document.onmouseup = null; cookie.setCookie(this.oDiv.id,this.positionStr,1)//记录最后的位置 &#125; &#125; dragFun.init(oDemo); 这样就顺利完成了。 好吧，那么关于cookie的知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"网络","slug":"网络","permalink":"http://moreluckily.com/categories/网络/"}],"tags":[{"name":"-网络","slug":"网络","permalink":"http://moreluckily.com/tags/网络/"}]},{"title":"跨域和JSONP","slug":"跨域和JSONP","date":"2018-10-01T15:48:35.000Z","updated":"2018-10-23T02:43:15.662Z","comments":true,"path":"2018/10/01/跨域和JSONP/","link":"","permalink":"http://moreluckily.com/2018/10/01/跨域和JSONP/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习网络。今天要讲一下网络中JSONP的一些知识。 跨域的几种方法鉴于利用ajax进行数据传输的时候，会受到同源策略的影响，那么如果我们需要从其它网站获取资源的时候，就需要进行跨域获取信息了。 首先要说明一点，原生使用jsonp是只能get数据，就是获得数据，不能post，jsonp跨域是通过动态添加script标签实现跨域的 由于script标签只能发送get请求 所以jsonp不支持post方式的跨域。 解决跨域的几种方法： 1.Flash （技术落后，已被淘汰，不做讨论） 2.服务器代理中转（从自己的服务器进行中转，利用服务器之间的通信进行数据的传输，不走浏览器，就没有同源限制） 3.Jsonp 4.document.domain(针对基础域名相同的情况) 1234// http://bj.58.com// http://tj.58.com// document.domain = &apos;58.com&apos;;// 基础域名相同的 JSONP利用ajax进行数据的传输的时候，我们利用src将ajax代码段引入到了自己的script中，就相当于把整端ajax方法都引进来，一样道理，如果我们利用src进行引用的话，不管什么，他都会引入到页面当中的。例如： 1.txt文件里面写： 1console.log(123) 在另外一个html文件引入 1&lt;script src=&quot;1.txt&quot;&gt;&lt;/script&gt; 我们可以发现，可以正常打印出123.尽管后缀名不是js。 12345678&lt;/script&gt;&lt;script src=&quot;1.txt&quot;&gt;&lt;/script&gt;&lt;script&gt;//1.txt --&gt; doJson(22);fuction doJson(data) &#123; console.log(data);&#125;&lt;/script&gt; 当我们利用img标签引用图片，里面的src属性就是不受同源限制的，可以利用src进行跨域。这个就引出jsonp的原理了。 123456//当我们利用img标签引用图片，里面的src属性就是不受同源限制的//src属性不受同源策略的限制//img//script//iframe//都有src属性，都能实现跨域 jsonp 原理1.Web页面上用script引入 js文件时则不受是否跨域的影响 （不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如 2.于是我们把数据放到服务器上，并且数据为json形式（因为js可以轻松处理json数据） 3.因为我们无法监控通过script标签的src属性是否把数据获取完成，所以我们需要做一个处理。 4.实现定义好处理跨域获取数据的函数，如 function doJSON（data）{}。 5.用src获取数据的时候添加一个参数cb=‘doJSON’ (服务端会根据参数cb的值返回 对应的内容) 此内容为以cb对应的值doJSON为函数真实要传递的数据为函数的参数的一串字符 如 doJSON（’数据’） 当我们给后台传输数据的时候，后台是直接将我们的回调函数返回给我们执行，什么意思呢，就是在ajax里面，当我们数据交互完成了，我们需要对数据进行处理，这个时候就有个callback回调函数是用来处理数据的，ajax里面有onreadystatechange可以检测交互的状态，但是在jsonp里面没有这个监听事件，所以，我们需要将回调函数传给后台，然后后台给我们返回数据的时候，我们直接处理。 拿一个百度搜索框做例子。百度有个接口，在network里面，”su?wd=输入的内容&amp;cb=传进的处理方法”这样的接口它就是用来处理数的。右击，openweb即可找到数据。 1234567891011121314151617181920212223242526&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; #box&#123; margin: 50px; &#125; input&#123; width: 400px; height: 50px; &#125; ul&#123; display: none; width: 400px; border: 1px solid black; &#125; li&#123; list-style: none; padding: 5px 10px; &#125; a&#123; text-decoration: none; color: #333; &#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot;&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var oInput = document.getElementsByTagName(&apos;input&apos;)[0]; var oUl = document.getElementsByTagName(&apos;ul&apos;)[0]; function doJson(data)&#123; var list = data.s; oUl.innerHTML = &apos;&apos;; if(list.length == 0)&#123; oUl.style.display = &apos;none&apos;; &#125;else&#123; list.forEach(function(item,index)&#123; var oLi = document.createElement(&apos;li&apos;); var oA = document.createElement(&apos;a&apos;); oA.href = &apos;https://www.baidu.com/s?wd=&apos; + item; oA.innerText = item; oLi.appendChild(oA); oUl.appendChild(oLi); oUl.style.display = &apos;block&apos;; &#125;) &#125; &#125; oInput.onkeyup = function()&#123; var val = oInput.value; var oScript = document.createElement(&apos;script&apos;); oScript.src = &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot; + val + &quot;&amp;cb=doJson&quot;; document.body.appendChild(oScript); document.body.removeChild(oScript);//解决每次抬起键盘后的多个script标签的生成 &#125; 这样就简单的模拟了一个百度搜索框。 好吧，那么关于JSONP知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"网络","slug":"网络","permalink":"http://moreluckily.com/categories/网络/"}],"tags":[{"name":"-网络","slug":"网络","permalink":"http://moreluckily.com/tags/网络/"}]},{"title":"同源策略和协议","slug":"同源策略和协议","date":"2018-10-01T10:47:43.000Z","updated":"2018-10-23T02:43:15.630Z","comments":true,"path":"2018/10/01/同源策略和协议/","link":"","permalink":"http://moreluckily.com/2018/10/01/同源策略和协议/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习网络。今天要讲一下网络中同源策略和协议的一些知识。 同源策略浏览器有一个很重要的概念————同源策略（same-origin policy），所谓同源指的是：域名，协议，端口相同。不同源的客户端脚本（JavaScript、actionscript）在没有明确授权的情况下，不能读写对方的资源。 简单来说啊，浏览器不允许包含在腾讯页面的脚本访问阿里巴巴页面的数据资源，会受到同源策略的限制。 例如：我们在百度页面搜索：lol。会有一个wd关键字，它是我们需要搜索的内容。如果搜索lol，一般出现特别长的一段代码。 1https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=lol&amp;rsv_pq=8576d71b00025292&amp;rsv_t=f996f7E4HJRAldhArJ4GpWAOnLeGnWAC8ZtULFXSTjEcvagG9YNeN0wZRZg&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=2&amp;rsv_sug1=2&amp;rsv_sug7=100 我们可以写短一点也可以得到相同的搜索结果，我们可以这样写： 1https://www.baidu.com/s?wd=lol 这样写可以得到相同的搜索结果。 但是要注意的是，这个必须是在百度页面才能访问，如果我们在本地发送请求是会报错的。 这就是因为同源策略的限制，我们不能在不同源的页面请求数据。（域名不相同，协议不相同）。 URL(资源定位符)构成协议://域名（端口号，参数，查询等）例如： 1http://www.zhidao.baidu.com 1.其中协议就是http，域名就是www.zhidao.baidu.com，域名是倒着解析的，baidu.com属于一级域名，zhidao.baidu.com属于二级域名，www是一级域名前缀，表示由万维网维护的。这个前缀是用来区别处理信息的，用来分开不同的服务器进行处理。例如邮件利用a服务器，网站用b服务器，通过前缀就可以直接找到处理网站的b服务器了。但是现在基本不需要使用www了。 zhidao.baidu.com属于百度自己进行维护的。com，org，net属于顶级域名，是在全世界范围内解析的，hk，cn，例如，cn就是在中国解析的。 2.端口、通常有几个80/90/3000等，http默认是80端口。https默认端口443.这里涉及到一个dns解析问题， 当我们输入URL之后，会进行寻找服务器，每个服务器上面有很多端口，每个端口有不同的功能，用来处理不同的业务。 12345678910举例来说，http://www.example.com/dir/page.html协议是http://域名是www.example.com端口是80（默认端口可以省略）http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同）https://www.example.com/dir/page.html ：不同源（协议不同） 输入一个URL之后发生了什么同源就是指协议，域名，端口都相同的网页。 1.浏览器通过DNS域名解析到服务IP（ping www.baidu.com）. DNS解析可以将我们输入的URL解析成一个IP地址，通过这个IP地址也能直接找到该网页。 2.客户端(浏览器)通过TCP协议建立到服务器的TCP连接 (三次握手)。 当找到服务器之后，我们需要建立一个连接才能进行数据的传输。那么通过TCP建立连接需要有一个过程，叫做“三次握手”.断开连接的时候也有一个过程叫做，“四次挥手” 3.客户端（浏览器）向web服务器端（HTTP服务器）发送HTTP协议包，请求服务器里的资源文档 （telnet 模拟） 在交互数据这里也有一个协议叫做http协议。请求服务器的资源文档。 4.服务器想客户端发送HTTP协议应答包 5.客户端和服务器断开（四次挥手），客户端开始解释处理HTML文档。 画图来说明一切： TCP/UDP(传输层协议)面向连接的TCPTCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。 面向非连接的UDP协议“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。与手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ 总的来说TCP协议是需要建立连接的，而UDP是不需要建立连接的。 三次握手过程具体过程： 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN—SEND状态，等待服务器B确认。（先Client端发送连接请求报文。） 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN-RECV状态。(Server段接受连接后回复ACK报文，并为这次连接分配资源。) 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。(Client端接收到ACK报文后也向Server段发送ACK报文，并分配资源，这样TCP连接就建立了。) 完成三次握手，客户端与服务器开始传送数据 如图： 四次挥手四次挥手 1.Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭（Socket），可以继续发送数据。 2.server发送ACK，告诉Client端，你的请求我收到了，但是我还没准备好，请继续等我的消息。 wait:这个时候Client端就进入FIN-WAIT状态，继续等待Server端的FIN报文。 3.当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端，好了，我这边数据发完了，准备好关闭连接了。 4.Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME-WAIT状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 应用层协议（http和https）超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 上面的协议为了建立客户端与服务器端的连接，此协议为了让两者进行沟通。 为什么要有此协议呢，让计算机之间按照规矩说话，你问我答，你怎么问我怎么答，否则计算机各说各话，没办法沟通。 http格式http（请求报文，响应报文）通过报文进行沟通. 请求报文： 先说一下请求报文吧。首先请求报文有几部分构成：“请求头”，“请求行”，“请求主体”。 请求行： 1请求方法（GET POST DELETE HEAD TRACE OPTION） 请求资源 (URL) 请求协议版本（HTTP/1.1） 要注意的是在http1.0，每次请求的时候都需要建立连接这样很耗性能，在1.1版本，出现了一个长连接的概念，例如，如果我们有十张图片资源需要请求，这个时候，会产生一个长连接，一次就接受10张图，而不需要每张图都建立一个连接。 请求头：允许客户端传递关于自身的信息和希望的响应形式。 123Accept：指定客户端能够接收的内容类型Content-Length：请求的内容长度//这个就限定了post和get的数据请求长度Date：请求发送的日期和时间 请求主体： 1表单提交数据如：name=cst&amp;age=18; 这个可以跟我们昨天讲的post发送数据的时候，把内容就是放在报文体里面。 关于响应报文，格式类似于请求报文，有几部分构成：“响应行”，“响应头”，“响应主体”。 响应报文： 1.响应行 1响应协议版本号（HTTP/1.1） 响应状态码 （200） 响应状态文字 （0K） 常见的http状态码： 成功状态码： 123200 服务器成功返回内容301/2 临时/永久重定向304 资源未被修改过 失败状态码： 123404 请求内容不存在500 服务器暂时不可用503 服务器内部错误 2.响应头（HTTP Responses Header ） 12Date就是原始服务器消息发出的时间，Expires，响应过期的日期和时间，等 3.响应主体 1‘sign success’ (注册成功) 响应体里面就有咱们请求回来的数据。 GET和POST的区别 在http协议里实际上没有区别！ 常规理解：1.GET 使用URL 或Cookie 传参，而POST将数据，放在BODY中。 ? NAME = ‘FA’&amp;AGE=18 2.GET 的URL会有长度上的限制， POST可以传输很多数据。 3.POST比GET安全。 但其实HTTP协议里没有规定POST数据就要放在BODY里， 也没有要求GET数据就一定要放在URL中而不能放在BODY中。 HTTP协议对GET和POST 都没有对数据的长度进行限制，两方面原因造成数据限制的原因 1.早期浏览器会对URL长度进行限制（浏览器URL输入框） 2.浏览器会对Content-length进行限制，这是为了服务器安全和稳定。 安全问题呢，看你怎么想了，对于纯小白什么都是安全的，对于黑客什么都是不安全的 浏览器缓存机制响应头里面有一个属性叫做ETag，它是每个数据都特有的一个唯一标识，第一次请求的时候，会把这个唯一标识缓存起来，那么在下次请求的时候会直接把这个唯一表示放到请求报文的请求头里面，再次给服务器发送的时候，有一个属性叫做“if-None-Match”它是匹配ETag的值的，如果if-None-Match和服务器的ETag一样，会返回一个304状态码，然后将本地的缓存给返回过来，如果发生改变就会返回新的资源。 ETag交互过程Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match.请求一个文件的流程可能如下： 123456====第一次请求===1.客户端发起 HTTP GET 请求一个文件；2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200====第二次请求===1.客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存； 还有一个if-Modified-Since是用来确定服务器发过来的资源的最后修改时间，如果发现修改了，不取缓存。 最后再讲一下一些响应头信息。 Date： 服务器响应内容日期 Cache-control：内容缓存时间 no-cache 会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 根据缓存超时 max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以 接收超出超时期指定值之内的响应消息。 Expires：内容保质期，表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同max-age的效果。但是如果同时存在，则被cache-control的max-age覆盖。 referer：可以统计用户从哪里点击而来的，如果从浏览器地址里直接输入地址，请求头里面是没有referer的。计算点击量，从而对其进行计费什么的。 好吧，那么关于同源策略和http的相关知识就讲到这，希望大家能有所收获。 好了，今天的这篇blog就到这里结束了 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"网络","slug":"网络","permalink":"http://moreluckily.com/categories/网络/"}],"tags":[{"name":"-网络","slug":"网络","permalink":"http://moreluckily.com/tags/网络/"}]},{"title":"Ajax简介","slug":"Ajax简介","date":"2018-10-01T02:04:45.000Z","updated":"2018-10-23T02:43:15.428Z","comments":true,"path":"2018/10/01/Ajax简介/","link":"","permalink":"http://moreluckily.com/2018/10/01/Ajax简介/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习网络。今天要讲一下网络中Ajax的一些知识。 复习一下form标签在一开始的时候，我们使用form表单进行数据的传输。 1&lt;form action=&quot;&quot; method=&quot;&quot;&gt;&lt;/form&gt; action属性是指这个数据要传输到那个地方，意思就是数据传送的地址，method属性就是数据传输的方式，有get和post两种方式。 post和get传送数据方式的区别： 1.get数据传递直接利用&amp;符号拼接到URL后面 2.post和get传输数据长度要求不一样，post更长一些，get长度小一点。get会受输入框的长度限制。 3.get相对于post，安全性更弱一点，因为它可以直接在输入框中看到数据。当然，post也是可以的，但是需要在浏览器后台进行操作。在network下面的headers也是可以看到数据的。 4.get多数用在获取数据，post通常用于传送数据。 form表单还有一个属性enctype：application/ x - www- form -urlencoded 告诉浏览器 用什么编码格式来进行编码 我们还可以利用input type=file,来进行文件的上传，这个时候: 1enctype: multipart/form-data //不对字符进行编码，在使用包含文件上传控件的表单是，必须使用该值。 但是form有一个最大的缺点就是，它在刷新数据的时候是整个页面都会刷新，并不是将需要改变的那部分进行刷新，这样就是非常耗性能的。例如，在我们经常使用的地图软件中，我们经常会刷新地点，看看自己的位置之类的，如果这个时候是利用form表单的话，我们是移动一下地图，然后全部数据都重新发送一遍，并不是局部发生改变，这样就是一个很大的缺点。所以现在form基本上被淘汰了。Ajax就是局部发生变化。 Ajaxajax（Asynchronous JavaScript And Xml）才是我们现在常用的数据传输方法。它用JavaScript以异步的方式操作xml（现在操作的是json） 现在又有一个异步和同步的概念，异步就是可以同时干两个事情，同步就是只能同一时间干同一件事。ajax异步操作，就不会阻塞页面的后续进程。最典型就是在网速很慢的时候，也不用担心等很久数据都出不来。 ajax 传送数据流程我们可以打个比方： 这个我们可以形象地用定外卖的过程进行模拟。 在我们利用外卖软件进行定外卖的时候，我们通常有几个步骤： 1.手机一部 2.外卖软件 3.打开app， 寻找商家和食品。 4.下单，添加各种备注。 5.监控物流信息 6.完成，验货即可。 那么这个过程对于ajax传送数据来说，也是类似的。 1.浏览器。 2.一个ajax对象，ajax传送数据的基础。创建这个对象有个要注意的地方就是,IE浏览器需要用自己方法创建： 12var ajax = new XHLHttprequest();//主流浏览器的创建方法var ajax = new ActiveXObject(&apos;Micrrosoft.XMLHTTP&apos;);//IE 3.open(method, url, flag)：这个方法是用来建立对服务器的调用，method参数是以get，post或者put进行数据的传输；URL指的是传送的地址。flag就是指的是异步或同步方式进行数据传输，true就是异步，flase就是同步。 4.send()，向服务器发送请求。要注意的是利用post和get方式传输数据的时候，send处理方式不一样，如果是post，我们需要把得到的数据传进send方法，如果是get就要进行URL拼接。 5.检测状态，需要利用一些事件。onreadystatechange和readyState，这两个方法之前在js时间线的时候讲过，这里有需要用到。onreadystatechange，可以检测readyState的状态变化，每次readyState发生变化，都会触发onreadystatechange事件，这两个结合使用，就可以监控ajax数据变化。 readyState：0代表未初始化状态，1，表示读取中，2表示已读取，3，表示交互中，4,表示已完成。我们需要的是检验readyState的值是否为4. 6.检验数据，当我们检测完readyState是否等于4时。这个时候我们需要对获取的数据进行检测，这里有一些状态码需要了解。 status：404表示文件未找到，200表示成功，500表示服务器内部错误。304表示资源未被修改。我们需要的是status为200的状态。 当这个过程都成功，我们就可以对数据进行处理了。 以下就是ajax的创建的过程： 123456789101112131415var ajax = null;if(window.XMLHttpRequest)&#123;//非ie ajax = new XMLHttpRequest();&#125;else&#123;//ie ajax = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125;//创建ajax对象，兼容IEajax.open(&apos;GET&apos;,&apos;url&apos;,true);//建立连接ajax.send();//发送请求ajax.onreadyStatechange = function()&#123; if(readyState == 4)&#123;//交互已完成 if(ajax.status == 200)&#123;//数据无误 console.log(ajax.responseText);//打印出所获取的数据 &#125; &#125;&#125; 但是上面这个方法有很多不完善的方法，第一个就是规定了只能用get来进行数据传输并且只是获取，post并没有用到，利用get进行传值也没有。如果是利用get进行传值需要使用拼接。例如： 1ajax.open(&apos;GET&apos;,&apos;getNew.php?username=Steven&amp;age=18&apos;,true); 通过这个方式进行传值，但是我们前端是不知道数据的名字和值的例如，我们有时候就不知道数据是不是叫做username和age，而且我们也不知道传值方式是什么，所以我们还是要写一个更加完善的形式。 第二个就是，很多时候在Ajax的get方法调用的时候由于缓存的原因无法及时获取正确的数据，(火车票验证码）我们需要利用一个实时的时间戳，将URL改变一下。 另外要注意的是post传值需要把数据传到send方法里面，而get方法是直接拼接在URL后面。 Ajax的封装： 12345678910111213141516171819202122232425262728293031323334353637383940function ajax(method, url,flag,data,callback) &#123; var app = null; //var data = data + &quot;&amp;date=&apos; + new Date().getDate();//拼接一个新的时间戳 if(window.XMLHttpRequest)&#123; app = new XMLHttpRequest(); &#125;else&#123; app = new ActiveXObject(&apos;Micosoft.XMLHttp&apos;); &#125; if(method == &apos;GET&apos;)&#123;//GET方式 app.open(method, url + &apos;?&apos; +data,flag); app.send(); &#125;else&#123;//POST方式 app.open(method,url,flag); app.setRequestHeader(&apos;content-type&apos;,&apos;applicateion/x-www-form-urlencoded&apos;);//告诉服务器，传输数据的类型 app.send(data); &#125; app.onreadystatechange = function () &#123; if(app.readyState == 4)&#123; if(app.status == 200)&#123; callback(app.responseText); &#125;else&#123; alert(&apos;error&apos;) &#125; &#125; &#125;&#125;function showList(ajaxData)&#123; //任意一个回调函数 var data = JSON.parse(ajasData); var ul = document.getElementsById(&apos;ul1&apos;); data.forEach(function(item,index)&#123; var li = document.createElement(&apos;li&apos;); var a1 = document.dreateElement(&apos;a&apos;); var a2 = document.createElement(&apos;a&apos;); a1.innerText = item.date; a2.innerText = item.title; li.appendChild(a1); li.appendChild(a2); ul.appendChild(li); &#125;)&#125; 上面的showList是一个回调函数，就是穿进去callback参数位里，是用来处理获取过来的数据的。将他一条一条插入到页面中。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解网络的同源策略和相关协议,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"网络","slug":"网络","permalink":"http://moreluckily.com/categories/网络/"}],"tags":[{"name":"-网络","slug":"网络","permalink":"http://moreluckily.com/tags/网络/"}]},{"title":"js的终章","slug":"js的终章","date":"2018-09-30T12:18:05.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/30/js的终章/","link":"","permalink":"http://moreluckily.com/2018/09/30/js的终章/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中一些知识的补充。 DOCTYPE查看视口的尺寸有两个方法，window.innerWidth/innerHeight IE8及IE8以下不兼容，还有就是document.documentElement.clientWidth/clientHeight ，这个在标准模式下任意浏览器都兼容，最后还有，document.body.clientWidth/clientHeight 这个适用于怪异模式下的浏览器。 这里就涉及到一些关于标准模式和怪异模式的知识了。 首先我们要知道渲染模式，在多年以前（IE6诞生以前），各浏览器都处于各自比较封闭的发展中（基本没有兼容性可谈）。随着WEB的发展，兼容性问题的解决越来越显得迫切，随即，各浏览器厂商发布了按照标准模式（遵循各厂商制定的统一标准）工作的浏览器，比如IE6就是其中之一。但是考虑到以前建设的网站并不支持标准模式（也可以理解更新前的网页版本），所以各浏览器在加入标准模式的同时也保留了混杂模式（即以前那种未按照统一标准工作的模式，也叫怪异模式）。 三种标准模式的写法：（如果没有写或者写错了就是怪异模式） 三种标准模式的写法 1.&lt;!DOCTYPE html&gt;（直接用这个就可以） 2.&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd”&gt; 3.&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd”&gt; BOM（Browser Object Model）BOM定义了操作浏览器的接口，它最常见的5个对象：window（操作window），history（操作历史记录），navigator（操作导航栏），screen（操作屏幕的），location（操作地理位置）。 Windowalert(): 显示一段消息并有一个确定按钮的弹出框。 close(): 关闭浏览器窗口，通常是配合iframe使用。 open() : 打开一个新的窗口。 1var newWindow = window.open(&apos;http://www.baidu.com&apos;,&apos;baidu&apos;,&apos;width=200px,height=200px&apos;); 这样就可以得到一个子窗口。我们可以查询它的一些window属性。 属性： closed: 用来查询是否关闭。通常是查询子窗体是否关闭。 opener: 查询该窗口是在那个窗口打开的。 navigator可以区别浏览器和之间的不同。浏览器嗅探。 userAgent: 可以真正区别浏览器是啥。利用正则表达式进行截取后，匹配操作之后，可以知道浏览器是哪个。 online: 查看浏览器是否脱机模式。就看电脑有没有联网，有网true，没网false。 platform：浏览器平台。 screen返回屏幕的各种参数，分辨率，高度等，但是不兼容。直接略过。 Hisorylength: 历史记录的长度 方法： back(): 往后退一次。 forword(): 往前进一次。 go(): 跳转，在历史记录上进行跳转。 locationhash: 哈希，手动置锚点。后端前端整合。 1location.hash = &quot;only&quot; //可以直接找到锚点的位置。例如在a标签写id，就可以用hash找到。 host: 查询主机名。 href: 完整的URL。 pathname: 返回URL中的路径名部分。 assign: 跳转到某个页面。 replace: 新页面代替当前页面。 reload: 刷新页面。 label标签label标签: 输入框聚焦的时候，只能点击文本框，如果点击文本框前的文字却聚焦不了，我们需要将他们连接起来， 使得点击文本都能聚焦。这就需要使用label标签了。 1234567&lt;form action=&quot;&quot;&gt; &lt;label for=&quot;demo&quot;&gt;username&lt;/label&gt; &lt;input id=&apos;demo&apos; type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;/form&gt;demo.onclick = function()&#123; alert(&apos;is easy&apos;);&#125; 属性映射，一个标签有一些属性，例如id，class等标签先天就有的，不需要我们手动添加，我们称之为特性。但是有些我们可以给他后天添加的属性，它们就不是特性。如果是特性，他们就有一种映射关系，如果利用js修改，它们可以直接在html里面改也发生变，如果是简单的属性，就是我们后天添加的，它们就没有一一对应的关系，在js里面修改，并不会在html里面体现，如果在html里面添加一个简单属性，那么在js里面访问就是undefined。 getByClass写一个方法通过类名取元素。getByClass。弥补IE8的getElementByClassName不好使的缺点。 12345678910111213141516Document.prototype.getByClass = function(target) &#123; //先选择出所有的元素，一个一个看它们的类名。如果类名有空格（前面有，后面有，中间有），要去空格。先去两边空格，在判断中间有没有空格。 var all = document.getElementsByTagName(&apos;*&apos;); var arr = []; //use to handle var trim = /^\\s+|\\s+$/g for(var i = 0; i &lt; len; i++)&#123; var nodeClassName = all[i].className.replace(regSpace, &quot;&quot;);//这里需要调试一下正则，以防出错； var testArr = nodeClassName.split(&quot; &quot;); for(var j = 0; j &lt; testArr.length; j++)&#123; if(testArr[j] === target)&#123; arr.push(all[i]); &#125; &#125; &#125; return arr;&#125; 图片预加载和懒加载网页加载图片的时候，并不是一开始全部都加载出来，而是，用户读到哪才加载到哪（懒加载）。预加载就是在没有读到之前，就尽量加载，加载完在展示，不要加一点显示一点。 12345678var oimg = new Image();//创建一个图片oimg.src = &quot;图片地址&quot;;oimg.onload = function() &#123; //加载完才注册事件 btn.onclick = function ()&#123;//点击才会出现图片 实现懒加载 document.body.appendChild(oimg); &#125;&#125; cdn 缓存服务器请求资源的时候，先找到最近的cdn，如果没有，再到总的服务器找所需要的资源。（网络课详细讲）。CDN的多少，确定世界各地访问该资源的速度。我们有时候也需要往cdn上面放东西。 断点调试（重要） 在读html之前如果有js脚本会阻塞文本，如果这时候有有DOM操作会报错。例如: 1234567&lt;script&gt; var div = document.getElementsByTagsName(&apos;div&apos;)[0]; div.innerHTML = &quot;hehe&quot;;//报错，cannot read the property of undefined&lt;/script&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 这个时候我们可以使用断点调试。在浏览器的source可以进行调试。里面有很多行，如果在某一行点击一下，相当于断点，这个时候刷新，程序读到哪一行，就会停止。这个有助于我们一步一步排错。类似于我们在页面上写console.log。 文档碎片页面加载的时候，有重绘（painting）和重排（rendering），我们要减少重排的次数，把需要改变的东西放在文档碎片里面，最后整个文档碎片加到body里面。一个一个放到body里面很耗性能。避免多次重排。 123var df = document.createDocumentFragment();df.appendChild(xxx);document.body.appendChild(df); 这样就可以减小重排的操作了。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解网络的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js中的正则表达式","slug":"js中的正则表达式","date":"2018-09-30T12:17:49.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/30/js中的正则表达式/","link":"","permalink":"http://moreluckily.com/2018/09/30/js中的正则表达式/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中json的相关知识。 正则表达式正则表达式，人为的设定一些方法，用来处理字符串的，匹配某种特定的字符串。正则表达式，代表一定的规则。 铺垫转义字符“\\”：在一些特定的情况，我们需要在页面显示一些回车，反斜杠等，这个时候就需要用转义字符了。例如： “abc\\n”： 表示abc之后换行.在控制台可以显示出来。 其他用处，\\t 表示tab； \\r 表示行间字符 ；\\n 表示换行。 1234var str = &quot;abc\\nabc&quot;;//换行document.write(str);//不好使,换行就是空格console.log(str);//好使\\t表示tab 又有，如果我们想打印出双引号等特殊符号，就可以写成这样： 12var str = &quot; abc\\&quot;bc\\&quot;bd&quot;&apos;;//&quot;abc&quot;bc&quot;bd&quot;;var str2 = &quot;abc\\\\d&quot;; //&quot;abc\\d&quot; 如果我们想实现多行显示： 123456var str = &quot;\\ &lt;div&gt;\\ &lt;p class=&quot;demo&quot;&gt;123&lt;/p&gt;\\ &lt;/div&gt;\\&quot; //系统会识别成文本形式的回车。 正则表达式的作用正则表达式是进行字符串匹配检测的，当我们为了匹配特殊字符或有特殊匹配原则的字符的时候，正则表达式是最佳的选择。 正则表达式（RegExp）有两种创建方式： 1、直接量 1var reg1 = /abc/ //(字面量形式），直接量形式 2、构造函数 1var reg = new RegExp(&apos;abc&apos;); 12var reg = /abc/;var reg1 = RegExp(reg);//它俩是同一个,发生改变会同时改变 12var reg = /abc/;var reg1 = new RegExp(reg);//它俩不是同一个，发生改变不会同时改变 如果使用new的形式进行创建，第一个参数写的是正则，第二个参数表示属性（g,m,i）。通常都会采用字面量的形式。 属性1234var reg = new RegExp(&apos;abc&apos;);var reg1 = /abc/; //看是否含有abc这个字符串的片段var reg2 = /^a|c$/; //以a开头以c结尾 var str = &apos;abcd&apos;; ignore;忽略。如果在正则表达式写i属性，表示忽略大小写。12345var reg = /abc/;var reg1 = /abc/i;var str =&quot;ABC&quot;;reg.test(str); //falsereg1.test(str); //true global;全局；匹配到一个之后，会继续匹配，返回一个类数组。12345var reg = /abc/g;var str = &quot;abcquweabcdabc&quot;;console.log(str.match(reg)); //[&quot;abc&quot;,&quot;abc&quot;,&quot;abc&quot;]var reg1 = /abc/;console.log(str.match(reg1)); //[&quot;abc&quot;] m: mutiple; 多行匹配;针对多行，行首识别。12345var reg = /^ab/;var reg1 = /^ab/gm;var str = &quot;abddsd\\nabccds&quot;;console.log(str.match(reg)); //[&quot;ab&quot;]&quot;; 换行之后就不再匹配；注意，g也识别不了换行。console.log(str.match(reg1)); // [&quot;ab&quot;,&quot;ab&quot;];换行之后继续匹配。 表达式表达式，定义匹配的规则。一个表达式只匹配一位。/[abc][cd]/第一位匹配abc任意一位，第二位匹配cd任意一位。方括号里面的表示区间。 /[0-9]: 表示匹配数字：0-9； /[^abc] : 匹配任何不是abc的字符； /[a-z]/:匹配小写a到z； /[A-z]/:匹配大写A到小写z；//ASCII码排序 /[A-Z]/:匹配所有大写字母； 12345var reg = /[abc]/; //代表区间，可以是abc中的任一一位var str = &apos;a&apos;;var str1 = &apos;b&apos;;console.log(reg.test(str));//trueconsole.log(reg.test(str1));//true 123var reg = /[abc][cde][xyz]/;var str = &quot;qweooiracy&quot;;console.log(str.match(reg)); //[&quot;acy&quot;]; 123var reg = /[0-9][cde][xyz]/;var reg = /[a-z][cde][xyz]/;var reg = /[A-z][cde][xyz]/;//ASCII码排序 1var reg = /[a-z][^cde][xyz]/;//除了cde，其他的都符合要求 1234var reg = /(abc|bcd)d/ //abcd,bcdd都行var reg = /(abc|bcd)d/g;var str = &quot;abcd bcdd&quot;;console.log(str.match(reg));//[&quot;abcd&quot;,&quot;bcdd&quot;] 12str.match(reg)//打印字符串reg.test(str) //true,null 元字符元字符,也是一个表达式，只是封装好了，方便使用。 1234567891011var reg = /[A-z0-9_]/ // --&gt; \\w //就是查找单词字符\\w [A-z0-9_] 单词字符\\W [^A-z0-9_] 非单词字符\\d: [0-9] 查找数字\\D: [^0-9] 非数字\\s: [\\t\\v\\n\\r\\f ] //表示空白字符的集合\\S: 查找非空白字符\\b: 表示单词边界\\B: 非单词边界. :表示所有的字符，除了\\n 和\\r。\\uxxxx ：匹配汉字 12345var reg = /\\babc/;var reg2 = /\\babc\\B/;var str = &quot;abc bcd&quot; // 这个有两个单词，有四个单词边界str.match(reg) //&quot;abc&quot;`str.match(reg2) //null 量词1234567n+ : 表示匹配任何包含至少一个的字符串。n + [1, Infinity) 个 nn*: 表示匹配0到无穷多个字符串。n * [0, Infinity) 个 nn?: 表示匹配最多一个字符。n ? [0, 1] 个 n贪心匹配：能拿多少拿多少。在不能匹配的情况下， 123var reg = /a+/g;var str = &quot;aaabaaba&quot;;console.log(str.match(reg)); //[&quot;aaa&quot;, &quot;aa&quot;, &quot;a&quot;] 123var reg = /\\w+/g;var str = &quot;aaabaaba&quot;;console.log(str.match(reg));// [&quot;aaabaaba&quot;] 1234var reg = /\\W\\d*/g;var str = &quot; 123&quot;;console.log(str.match(reg));//[&quot; 123&quot;]//贪心匹配：能拿多少拿多少。在不能匹配的情况下， 1234var reg = /\\W\\d*/g;var str = &quot; !123&quot;;console.log(str.match(reg));//[&quot; &quot;, &quot;!123&quot;]d* //可以是0个,然后就拆开了 123var reg = /\\W\\d?/g;var str = &quot; !123&quot;;console.log(str.match(reg));//[&quot; &quot;, &quot;!1&quot;] 123var reg = /\\W\\d+/g;var str = &quot; 2442115112&quot;;//段首是空格str.match(reg) // &quot; 2442115112&quot; 123var reg = /\\W\\d?/gvar str = &quot; !1996&quot;;str.match(reg); // [&quot; &quot; ,&quot;!1996&quot;],能匹配多少匹多少 n{x} : 匹配 x 个n。 n{0,1} : 相当于n?. 这里要注意一点，只要能取到0 就可能出现空串。例如： 123var reg = /\\d&#123;0,3&#125;/g;var str = &quot; !123456&quot;str.match(reg); // [&quot;&quot;,&quot;&quot;,&quot;123&quot;,&quot;456&quot;,&quot;&quot;]取不了字符，就会匹配空串，利用0，如果改成1，就不会有空串。 打破贪心匹配: /\\d{1,}?/表示能取一绝不取多。 如果是这样：即/\\d??{1,}/。就是表示能取零绝不取1。 n$: 表示以n结尾。 ^n: 表示以n开头。 如果是写在表达式外面就是以。。。开头，如果写在表达式里面就是表示取反。 12^n 以n开头n$ 以n结尾 1234var reg = /\\d*?/g;var str = &quot; !123&quot;;console.log(str.match(reg));//[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]//能取空就不取数字 例四: 写一个表达式，检测首尾是否含有数字。 (或关系，首或尾有数字） 123var reg = /^\\d|\\d$/g;var str = &quot;1abc&quot;; // console.log(reg.test(str)); //true // 例五: 写一个表达式，检测首尾都含有数字。// . 除了\\r\\n 都有 12345var reg = /^\\d[\\w\\W]*\\d$/g;var str = &quot;1abc2&quot;; // console.log(reg.test(str)); //truevar str1 = &quot;1abc&quot;;console.log(reg.test(str1)); //false 例题： 12345var reg = /^abc$/g;var str = &quot;abcabc&quot;;console.log(reg.test(str)); // false;var str1 = &quot;abc&quot;;console.log(reg.test(str1));//true 得出结论：如果利用尖角号和dollar符用在同一个字符串上，确定长度的字符串。两头卡死了。 1234var reg = /^(abc|bcd)$/g;var str = &quot;abc&quot;;console.log(reg.test(str)); // true;//也卡死了，abc或者bcd 正则的属性reg.ignorecase: 检测是否有i。 reg.global: 检测是否有g。 reg.multiline: 检测是否有m。 reg.source: 正则源字符。 reg.lastindex：很重要 待会讲。 正则的方法1.reg.exec(): 很重要，待会讲。 2.reg.test()：检测是否跟目标正则匹配。 3.str.match(): 返回匹配的字符串。 返回的是一个类数组。（只展示索引位，数组方法splice），如果有g属性，就会额外返还几个属性，第一个属性是匹配到的字符串，第二个是第一个字表达式匹配到的第一个字符串，第三个匹配到第二个字符串，，index属性就是匹配位置。input就是该字符串。如果没有g属性就只能有匹配到的字符串。 4.str.serach(): 检测匹配到的字符串的索引.可以填字符串，也可以填正则。 5.str.split(): 分割字符串，利用正则。正则表达式表示空：(/d{0}/); str.split(/\\d{0}/);//空截取 6.str.replace: 如果直接写字符串，没有全局找的功能，只能把第一个匹配到的东西进行替换。填正则表达式，利用g就可以进行全局匹配。 123var str = &quot;abcda&quot;;str.replace(&quot;a&quot;,&quot;s&quot;) // &quot;sbcda&quot;str.replace(/a/g,&quot;x&quot;) //“xbcdx” 7.n(?=xxx) 正向预查（正向断言） 123var reg = /x(?=abc)/g;var str = ‘xabcxbcdaabc’; console.log(str.match(reg)); // x 后面是abc的那个n，匹配的是n，后面有abc是一种条件。 123var reg = /(?=abc)/g;var str = ‘xabcxbcdaabc’; console.log(str.match(reg)); // [“”, “”] 如果n是一个空，那么就查找后面是abc的a前面那个空串了。 8.反向引用：括号表示一个子表达式，“\\1”表示引用之前的第一个子表达式匹配到的东西。 12345678var reg = /(\\w)\\1/;var str = &quot;bb&quot;;var str1 = &quot;aaaabbbbbcccc&quot;;var reg2 = /(\\w)\\1+/g;reg.test(str) ;// true;reg2.test(str1); // truevar str2 = &quot;ab&quot;;reg2.test(str2); //false 1234567例一：1，匹配“xyyx”形式的字符串,2，调换字符串顺序 3,形式转换“abbba”转化为“baaab”1. var str = “abba”; var reg = /(\\w)(\\w)\\2\\1)/g; str.match(reg) //[abba];2. var str = “aabb”; var reg = /(\\w)(\\w)/g; str.replace(reg,”$2$2$1$1”) //”bbaa”;3. var str = “abbba”; var reg = /(\\w)(\\w)\\2&#123;2&#125;\\1/g; str.replace(reg,”$2$1$1$1$2”); 123var str = &quot;abba&quot;;var reg = /(\\w)(\\w)\\2\\1/g;console.log(str.match(reg)); //[&quot;abba&quot;] 123var str = &quot;abbacddc&quot;;var reg = /(\\w)(\\w)\\2\\1/g;console.log(str.match(reg)); //[&quot;abba&quot;, &quot;cddc&quot;] 123var str = &quot;abbba&quot;; var reg = /(\\w)(\\w)\\2&#123;2&#125;\\1/g;console.log(str.replace(reg, &quot;$2$1$1$1$2&quot;));//baaab 或者 123console.log(str.replace(reg, function ($, $1, $2) &#123; return $2 + $1 + $1 + $1 + $2;&#125;))//baaab 例：将字符串转化形式，the-first-name转化为小驼峰式。（toUpperCase()转大写） 12345var str = &quot;the-first-name&quot;;var reg = /-(\\w)/gconsole.log(str.replace(reg,function ($,$1)&#123; return $1.toUpperCase()&#125;)) //theFirstName exec方法（ 执行 完成 履行）reg.exec(str): 如果没有g，跟match是一样的。如果有g属性，它就不一样了。它有个特点就是会接着上次的匹配结果再执行。就像有一个游标存在，匹配一次，游标就移动一次。匹配完之后，他会继续循环匹配。该游标属性就是lastIndex。看以下例子： 1234567891011var str = &quot;the-first-name&quot;;var reg = /-(\\w)(\\w)/g;console.log(reg.lastIndex); // 0console.log(reg.exec(str)); //[&quot;-fi&quot;, &quot;f&quot;, &quot;i&quot;, index: 3, input: &quot;the-first-name&quot;]console.log(reg.lastIndex); //6 从第六位开始匹配console.log(reg.exec(str)); //[&quot;-fi&quot;, &quot;n&quot;, &quot;a&quot;, index: 9, input: &quot;the-first-name&quot;]console.log(reg.lastIndex); //12console.log(reg.exec(str)); //nullconsole.log(reg.lastIndex); //0console.log(reg.exec(str)); //[&quot;-fi&quot;, &quot;f&quot;, &quot;i&quot;, index: 3, input: &quot;the-first-name&quot;]console.log(reg.lastIndex); //6 从哪个位置开始匹配，是由lastIndex决定的。如果手动将lastIndexOf变成12，那么下次就是匹配reg.exec(str)就是null。 从哪个位置开始匹配，是由lastIndex决定的。如果手动将lastIndexOf变成12，那么下次就是匹配reg.exec(str)就是null。 ”?:” ： 表示忽略此子表达式。例如：要求把第一个x添加到后面。 123456var str = &quot;xbcy&quot;;var reg = /(?:abc|(\\w)bc)y/gconsole.log(str.replace(reg, function ($,$1)&#123; return $ + $1;&#125;));//xbcyx//?:abc ,根本没有记录这个内容 ”?:”告诉引擎，不要将后面的内容记录为表达式。 正向预查：添加一个修饰条件，必须符合一定条件才能被匹配到。 12var reg = /abc(?=x)/ //匹配x后面的abcvar reg = /(?=x)abc/ //匹配空后面是x加abc，这个是永远不可能的，所以正向预查得写后面。 1234var reg = /abc(?=x)/ //匹配x后面的abcvar str = &quot;abcxab&quot;;console.log(reg.test(str));//trueabc后面的x 如果想使用$ 这个字符串，不能直接用$,要这样写“$$”,如果想匹配“?”，需要这要转义一下”/\\?/”。 例一：连续字符串去重。 123var str = &quot;aaaaabbbbbcccccaaaa&quot;;var reg = /(\\w)\\1*/g;str.replace(reg,&quot;$1&quot;); // abca 例二：将字符串按规定打点。三位打点。 123var str = &quot;100000000&quot;;var reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/g; //空后面跟3的倍数位的数字而且该数字是非单词边界，从后往前查，以空后面跟的数字结尾str.replace(reg,&quot;.&quot;); // 100.000.000 例三：写一个邮箱密码验证的正则。123456789101112131415161718&lt;input type=&quot;password&quot; style=&quot;border:1px solid black&quot;&gt;&lt;span style=&quot;display:none;color:#f40;font-size:12px;&quot;&gt;you password is not right!&lt;/span&gt;var input = document.getElementsByTagName(&apos;input&apos;)[0];var span = document.getElementsByTagName(&apos;span&apos;)[0];input.onchange = function() &#123; var str = input.value; var reg = /^[0-9A-z]&#123;6,18&#125;$/g; if(!reg.test(str))&#123; console.log(&quot;please check your e-mail&quot;); span.style.display = &apos;block&apos;; &#125;else&#123; console.log(&quot;smart people!&quot;); span.style.display = &apos;none&apos;; &#125;&#125; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS的最后一节课的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的JSON格式","slug":"js的JSON格式","date":"2018-09-29T11:04:25.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/29/js的JSON格式/","link":"","permalink":"http://moreluckily.com/2018/09/29/js的JSON格式/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中json的相关知识。 json格式先介绍一下JSON： 我们传输数据就两种格式：xml和json。 xml是以html为模板，自定义标签名作为数据名来传递数据，书写起来很麻烦，现在多用json，很少使用xml。 json是传输数据的另一种格式，它是以对象为模板（本质上就是对象，但是用途有所区别，对象是本地使用，json是用来传输数据）。 json对象跟我们平常的对象主要区别是属性名必须要使用双引号。 json是可以解析的，有两个方法。一般情况下，正常的数据传输都是会转化为二进制的文件或数据，多数都是字符串，我们需要对字符串进行操作。 不过我们传输数据的时候并不能将一个json对象直接传过去，我们只能传过去json形式的字符串，这个时候我们就需要用到JSON上的两个方法了。 12JSON.parse() —&gt; string-&gt;jsonJSON.stringify() —&gt; json-&gt;string 通过JSON上的这两个方法，我们就可以进行数据传输了。 12345678var obj = &#123; &apos;name&apos;: &apos;scarlett&apos;, &apos;age&apos;: 18&#125;;var string = JSON.stringify(obj);console.log(string); // ‘&#123;“name”:”scarlett”,”age”:18&#125;’var data = JSON.parse(string);console.log(data); // Object &#123;name: “scarlett”, age: 18&#125; 将json类型的字符串转化为json类型的对象。（把接收过来的信息转化为json）必须注意： 1var stjson = &apos;&#123; &quot;name&quot; : &quot;xiaozhang&quot;,&quot;age&quot; : &quot;20&quot;&#125;&apos; 字符串不能手动写成多行，字符串必须是一行。否则会报错。 可以这样来写： 1234var json1 = &apos;&#123; \\ &quot;name&quot; : &quot;xiaozhang&quot;,\\ &quot;age&quot; : &quot;20&quot;\\ &#125;&apos;; 异步加载JStml加载的时候是一边加载一边解析。当我们加载到script标签的时候会阻塞页面。在我们正常编程的时候，有很多script，css文件。当我们script过多的时候，有很多方法库，类库等会阻塞很久，如果有个文件发生错误，下面的所有文件都会瘫痪掉。这时候，我们需要将JavaScript文件（库文件，不用执行的方法）一部分异步加载出来，就是一边加载JavaScript一边加载html、css等。 总结一下，归于以下两点： js加载的缺点：加载工具方法也阻塞文档，过多js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。 有些工具方法需要按需加载，用到再加载，不用不加载。 我们需要对某些JavaScript文件，进行按需加载，需要的时候才加载，不需要的时候不加载。 异步加载js的方法文档解析的时候，先解析html结构和css文件，形成DOM树和css树，然后两个树拼在一起，形成渲染树randerTree。然后在这个过程中有几个状态： 这里先讲一个状态，dom树解析完毕。把标签都放在DOM树上，不用看完里面的内容，就可以把它挂在树上。这就叫解析完成。在DOM树加载完毕之前是先解析完毕。 defer异步加载我们在script标签的行间写一个defer=“defer”或者直接写defer，就可以让这个script变成异步加载了。但是这种异步只是针对下载方面，只有等DOMTree全部解析完成（不包括下载完里面的资源）后才会异步执行。而且这个方法只有IE和一些高版本的firefox和chrome可以用。 123&lt;script src=&quot;xx.js&quot; defer&gt; console.log(&apos;a&apos;);&lt;/script&gt; 不过这一种方式可以在script标签里面写代码。 注意：IE6和IE7的异步加载最多只能有2个，当多余两个的时候必须等前两个加载完才会加载第三个。 所有defer的js代码都保证按照顺序执行。 async异步加载async是asynchronous的缩写,是异步的缩写，它是html5的标准，下载完成之后就会立即异步执行，这种方法除了IE6-IE8其他的浏览器都好用。 asynchronous javascript and XML就是ajax的缩写。 1&lt;script type=“text/javascript” async=“async”&gt;&lt;/script&gt; 不过这种方式不能把代码写在script标签里面，只能引用。（虽然标准是这么写的，但是现在随着内核升级，async里面也可以写代码了，在没有src的情况下）。 而且async的js代码不能保证是顺序执行的。 • 这两个属性不能一起使用！ 我们现在看个例子： 12&lt;script async src=&quot;demo.js&quot;&gt;&lt;/script&gt;//demo.js里面有test函数&lt;script&gt; test()&lt;/script&gt;//test执行 当执行到第一个script的时候主线程会继续向下解析，并开一个新线程解析demo.js，当解析到第二个script的时候，因为不是异步的，就会阻塞所有进程，这个时候的demo.js可能已经解析完，但是没有下载完，这个时候就会报错，因为test还没有下载完就执行了。 以上两种方法不能做到按需加载，只能做到异步加载。通常开发，我们使用第三种方法。 动态添加script标签w3c的标准规定：动态添加的script标签是异步的。 创建script，插入到DOM中，加载完毕后callBack回调。 1234var script = document.createElement(&apos;script&apos;);script.src = &quot;demo.js&quot;;document.boddy.appendChild(script);test() //报错，因为这个是异步加载，还没加载完就执行，报 test is not defined 这种方法可以实行按需加载，异步加载。但是这个时候，我们需要知道异步加载js的加载完成时间，告诉我们js文件已经加载完成。这个时候就有一个很人性化的方法：load事件。（IE没有load事件） 123script.onload = function () &#123; //加载完之后需要进行的操作，写在里面&#125; IE上面的方法用readyState 有两个状态，loading表示正在加载，如果加载完成就会变成complete或loaded。还有一个事件就是onreadystatechange，是用来检测readystate状态的变化，如果变化了就会触发这个事件。 1234567891011121314151617function loadScript(url) &#123; var script = document.createElement(&apos;script&apos;); script.src = url; document.body.appendChild(script); if(script.readyState)&#123; script.onreadystatechange = function () &#123; if(script.readyState == &quot;complete&quot; || script.readyState == &quot;loaded&quot;)&#123; test(); &#125; &#125; &#125;else&#123;//Safari firefox goole chrome opera scripte.onload = function () &#123; test(); &#125; &#125;&#125;loadScript(&apos;dome.js&apos;); 以上就是最常用的异步记载，按需加载的方法。但是如果下载的非常快，解析完成的时候，马上就下载完，这个时候，onreadystatechange马上变成最终状态，我们还没检测，它已经变化完毕了，所以我们需要调换一下顺序。最后才插入脚本。 1234567891011121314151617function loadScript(url) &#123; var script = document.createElement(&apos;script&apos;); script.src = url; if(script.readyState)&#123; script.onreadystatechange = function () &#123; if(script.readyState == &quot;complete&quot; || script.readyState == &quot;loaded&quot;)&#123; test(); &#125; &#125; &#125;else&#123;//Safari firefox goole chrome opera scripte.onload = function () &#123; test(); &#125; &#125; document.body.appendChild(script);&#125;loadScript(&apos;dome.js&apos;); 最后要变成一个传参形式，自定义函数，注意不能直接写函数名，否则会报错。 12345678910111213141516171819202122var obj = &#123; test : function ()&#123; &#125; &#125;//写在demo.js文件里面function loadScript(url,callback) &#123; var script = document.createElement(&apos;script&apos;); script.src = url; if(script.readyState)&#123; script.onreadystatechange = function () &#123; if(script.readyState == &quot;complete&quot; || script.readyState == &quot;loaded&quot;)&#123; script.onreadystatechange = null;//降低性能，不用时刻监听 obj[callback](); &#125; &#125; &#125;else&#123;//Safari firefox goole chrome opera script.onload = function () &#123; script.onload = null; //降低性能，不用时刻监听 obj[callback](); &#125; &#125; document.body.appendChild(script);&#125;loadScript(&apos;dome.js&apos;,&quot;test&quot;); 这就是完整的整个方法，实行按需异步加载。 • 异步加载js不允许使用document.write这个方法。它会清除文档流，一旦执行就会把全部的标签都清除掉，包括自身的script标签。 JS加载时间线（performace timing line）1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。 2、遇到link外部css，创建线程加载，并继续解析文档。 3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。 4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()） 5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 6、当文档解析完成，document.readyState = ‘interactive’。 7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write(); 8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。 10、从此，以异步响应方式处理用户输入、网络事件等。 要注意的是，任何情况都禁止使用document.write()，因为它能够清除文档流（如果文档流没有加载完毕，不会清楚，而是跟着加载了的文档后面），所有标签都清除。 12345678&lt;div&gt;&lt;/div&gt;&lt;script&gt; console.log(document.readyState);//loading&lt;/script&gt;&lt;span&gt;&lt;/span&gt;&lt;script&gt; console.log(document.readyState);//loading,script也是标签，这里不是interactive&lt;/script&gt; JS的时间线是非常重要的知识点，希望大家能背下来这一块。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中正则表达式的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的鼠标和键盘事件","slug":"js的鼠标和键盘事件","date":"2018-09-29T11:03:30.000Z","updated":"2018-10-23T02:43:15.630Z","comments":true,"path":"2018/09/29/js的鼠标和键盘事件/","link":"","permalink":"http://moreluckily.com/2018/09/29/js的鼠标和键盘事件/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中鼠标事件和键盘事件的相关知识。 鼠标事件鼠标事件有很多：click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout。这些方法的语义化都很好，大家看名字基本都懂是什么意思。 其中，contextmenu是右键出现菜单事件，并不是右键事件。 click是一个完整的点击事件，包括mousedown和mouseup。 mouseover和mouseout是一组事件，对应于鼠标的移入移出事件。 • 所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。 • 左键点击的顺序是：mousedown、mouseup、click 我们先来写一个简单的拖拽，思路：鼠标每移动一次，记录一下数据 123456789101112131415161718&lt;div style=&quot;width:100px;height:100px;background-color: red;position: absolute;left: 0;top: 0;&quot;&gt;&lt;/div&gt; var div = document.getElementsByTagName(&apos;div&apos;)[0];var disX, disY;div.onmousedown = function (e) &#123; disX = e.pageX - parseInt(div.style.left); // disY = e.pageY - parseInt(div.style.top); document.onmousemove = function (e) &#123; // 绑定在div上面的话，只有在div身上移动的时候，才会触发事件，而检测事件是有系统监控的，如果刷新频率跟不上移动的速率，这个时候，就会造成，鼠标移动了，但是方块没移动，就是掉帧。所以要绑定在document上面。 var event = e || window.event; div.style.left = e.pageX - disX + &quot;px&quot;; //以中心点为移动中心 div.style.top = e.pageY - disY + &quot;px&quot;; &#125; div.onmouseup = function () &#123; div.onmousemove = null; &#125;&#125; div.setCapture()；捕获页面上的所有地方的事件，获取到div身上，获取完之后要释放，利用div.releaseCapture(),不然在其他地方都用不了事件。 mousedown：鼠标按下事件 mouseup：鼠标抬起事件 click: 鼠标点击事件。等于mousedown + mouseup 。先down后up再click。 mouseover/mouseenter：鼠标进入事件， mouseout/mouseleave：鼠标离开事件 123456789document.onclick = function (e) &#123; console.log(‘click’);&#125;document.onmousedown = function (e) &#123; console.log(‘mousedown’);&#125;document.onmouseup = function (e) &#123; console.log(‘mouseup’);&#125; 输出的结果是mousedown、mouseup、click。 • 当我们同时绑定了click事件和mousedown事件后，如何解决mousedown和click的冲突问题？ 其实方法很简单，我们可以通过按下鼠标的事件来判断是执行click还是mousedown事件。 利用button来区分左右键。只能用mouseup和mousedown来区分。当我们触发mousedown的时候，事件对象会有一个属性叫做“button”，如果返回的是2，那么就是右键，如果是返回0，那么就是左键。中间滚动轮为1. click事件永远都是左键，有左键和右键的区别的是mousedown事件。 123456789document.onmousedown = function (e) &#123; if (e.button == 0) &#123; console.log(‘left’); &#125;else if (e.button == 1) &#123; console.log(‘mid’); &#125;else &#123; console.log(‘right’); &#125;&#125; 练习：区分拖拽事件和点击事件，通过时间差。大于一定时间为拖拽，否则就是点击。 1234567891011121314151617181920212223var key = false; //开关，判断走哪个代码块var firstTime, lastTime;div.onclick = function (e)&#123; if(key)&#123; console.log(&apos;click&apos;); &#125;&#125;div.onmousedown =function (e)&#123; firstTime = new Date().getTime();&#125;div.onmouseup = function (e)&#123; lastTime =new Date().getTime(); if(lastTime - firstTime &gt; 200)&#123; key = false; &#125;else&#123; key = true; &#125;&#125;div.onmousemove = function (e)&#123; console.log(e.pageX + &quot;&quot; + e.pageY) &#125; 针对鼠标帧频过快的问题，IE中有一个也可以说是另一种事件捕获的方法——domEle.setCapture()。 调用这个方法之后，页面后续的所有操作就会全部都归于这个domEle上，比如div有一个拖拽事件，不过mousemove绑定在div上，只要调用了这个方法，当鼠标拖拽过程中鼠标移出了div，这个时候有效的鼠标移动就变成了document上的mousemove事件了，但是它还是归于了div上，因此div还是可以跟着鼠标移动。 同时还有一个domEle.releaseCapture()方法可以来释放这个捕获行为。 键盘事件键盘事件主要有三个：keydown、keypress、keyup。 触发顺序分别是keydown、keypress、keyup。 123456789document.onkeydown = function (e) &#123; console.log(‘keydown’);&#125;document.onkeypress = function (e) &#123; console.log(‘keypress’);&#125;document.onkeyup = function (e) &#123; console.log(‘keyup’);&#125; 输出的结果是keydown、keypress、keyup。 keydown和keypress可以响应连续操作，我们一直按着键盘就会一直触发事件。 keypress的范围和keydown有所区别： keydown可以响应任意键盘按键，keypress只能响应字符类按键，也就是有ASCII码的字符的按键，像字母数字回车空格之类的。 事件对象的属性方面： 只有keypress有charCode属性，这个属性代表的我们输入的这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。 keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。 • String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。 123document.onkeypress = function (e) &#123; console.log(String.fromCharCode(e.charCode));&#125; 文本类操作事件123input.oninput = function (e) &#123; console.log(this.value);&#125; 检测文本框里面的信息，只要有变化就会触发事件，就会打印出来。 123input.change = function(e) &#123; console.log(this.value);&#125; 检测文本框里面，状态是否发生变化，变化了，失去鼠标焦点的时候就会触发，如果没有变化，失去鼠标焦点不会发生变化。 写一个类似于新浪的输入框功能： 123456&lt;input type=&quot;text&quot; value=&quot;请输入用户名&quot; style=&quot;color:#999&quot; onfocus=&quot;if(this.value==&apos;请输入用户名&apos;)&#123;this.value=&apos;&apos;;this.style.color=&apos;#424242&apos; &#125;&quot; onblur=&quot;ifif(this.value==&apos;&apos;)&#123;this.value=&apos;请输入用户名&apos;;this.style.color=&apos;#999&apos;&quot;&gt; //鼠标聚焦，一行字没了，鼠标离开，一行字又回来了 窗体类事件（window上的事件）scroll ：当滚动条滚动，就会触发该事件，利用这个我们可以模拟一个position：fix，IE里面没有fix。利用这个模拟一个定位。 1234567891011function fixed (elem)&#123; var posX = parseInte(getStyle(elemm &apos;left&apos;)); var posY = parseInt(getStyle(elemm &apos;top&apos;)); window.onscroll = function() &#123; var disX = getScrollOffset().x; var disY = getScrollOffset().y; console.log(disX + &apos;&apos; + disY); elem.style.left = parseInt(getStyle(elem,&apos;left&apos;)) + disX + &apos;px&apos;; elem.style.top = parseInt(getStyle(elem,&apos;top&apos;)) + disY + &apos;px&apos;; &#125;&#125; window.onload事件：解析文档的时候，html和css是一起解析的，html会形成一个DOM树，css会形成一个css树，当两个树拼到一起会形成一个渲染树（renderTree） ，然后开始进行渲染。如果碰到img标签，会先挂到树上，不着急下载，在解析的时候，会多开一个线程，并行地下载img。当所有html标签都解析完之后，JavaScript就开始解析了。但是window.onload是等所有资源解析并下载万才能触发该事件。效率非常低。这个事件通常是用来提醒加载完毕。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中JSON格式的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js中的事件","slug":"js中的事件","date":"2018-09-28T15:43:35.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/09/28/js中的事件/","link":"","permalink":"http://moreluckily.com/2018/09/28/js中的事件/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中事件的相关知识。 事件事件是交互体验的核心功能，非常非常重要。 事件是每一个浏览器本来就有的，我们只是给相应的事件添加了一个回调函数。 事件是一个动作，给它一个信号，它会给我们一个反馈。这样的交互就叫做事件。例如： 12345&lt;div style=&quot;width:100px;height:100px;background-color:red;&quot;&gt;&lt;/div&gt;var div = document.getElementByTagName(&apos;div&apos;)[0]; div.onclick = function() &#123; console.log(&apos;a&apos;);&#125; 这样每次点击一下div就会打印出一个a，要注意的是，就算没绑定事件，该元素还是天生就自带事件的，只是我们没看见而已。我们只是给他加了一个绑定的处理函数而已。 这个函数就叫做事件处理函数，也称回调函数，当我们点击事件触发的时候，就会执行后面的处理函数。 事件可以持续监听，并不是执行完一次就失效，因此这个事件监听部分并不属于js引擎，因为js引擎是单线程的，事件监听属于内核的其他模块部分，一旦事件触发，事件监听就会把处理函数放入执行队列，等待js引擎来执行。 绑定事件句柄绑定方式1ele.onXXX = function () &#123; &#125;; //句柄绑定方式。 虽然句柄方式的兼容性很好，但是一个元素的一种事件只能绑定一个函数。 它等同于写在行间的事件。 1&lt;div onclick=&quot;console.log(&apos;a&apos;);&quot;&gt;&lt;/div&gt; 一些比较简单的函数可以用这种方式来写。 ele.addEventListener(type, handle, false)方法。这里面有三个参数，第一个参数是事件类型，第二个参数是处理函数，第三个参数是是否捕获。 处理函数可以直接在addEventListener方法里面写一个匿名函数，也可以在外面写一个命名函数，然后在放法里面写函数的引用。 这种方法更加通用常见，而且一种事件可以绑定多个函数，但是同一个处理函数只能绑定一次。 123456789101112div.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;a&apos;);&#125;, false);div.addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;a&apos;);&#125;, false);//打印出两个afunction test() &#123; console.log(&apos;a&apos;);&#125;div.addEventListener(&apos;click&apos;, test,false);div.addEventListener(&apos;click&apos;, test,false);//打印出一个a； 这是唯一一个有事件捕获的方法。 注意：即使函数体相同，两个函数也不是一个函数。 不过很遗憾的是，这种方法在IE9以下不兼容。 ele.attachEvent(‘on’ + type, handle)这个方法是IE独有的方法，一个事件同样可以绑定多个处理函数。 123div.attachEvent(‘onclick’, function ()&#123; console.log(‘a’);&#125;); 基本和addEventListener差不多，但是有一点区别是，当同一个函数绑定多次的时候，addEventListener是只执行一次，但是attachEvent会绑定几次执行几次。在Google浏览器中会不好使。 12345function test () &#123; console.log(‘a’);&#125;div.attachEvent(‘onclick’, test);div.attachEvent(‘onclick’, test); 现在这里有一个笔试常考的绑定事件的题：使用原生js，addEventListener，为每一个li绑定一个点击事件，输出他们的顺序。 这里就要注意这个题考察的不仅仅是绑定事件，更多的是闭包的运用。 12345var liCol = document.getElememntsByTagName(&apos;li&apos;), len = liCol.length;for(var i = 0; i &lt; len; i++)&#123; console.log(i)&#125; 这个会发现，无论点击哪个，都会打印的都是4.因为产生了闭包，这个时候，老规矩，我们需要利用立即执行函数进行修改。 12345678910var liCol = document.getElememntsByTagName(&apos;li&apos;), len = liCol.length;for(var i = 0; i &lt; len; i++)&#123; (function (i) &#123; liCol[i].addEventListener(&apos;click&apos;,function () &#123; console.log(i); &#125;,false); &#125;(i))//点击第一个打印0，...&#125; 在我们在绑定事件的时候，如果利用for循环，就要考虑是否产生闭包，当然，如果没有用到for循环里面的变量，就没事，如果用到了for循环里面的东西就会产生闭包。要使用立即执行函数。 事件处理程序的运行环境1.句柄绑定方式中，函数里面的this指向元素本身。 2.addEventListener方式中，函数里面的this也是指向元素本身。 3.attachEvent中，函数里面的this指向的是window而不是元素本身，这算是IE的一个BUG。针对这种情况，我们就需要把函数提取出来，然后在attachEvent的时候用call来改变函数内部this的指向。 123456div.attachEvent(&apos;onclick&apos;,function () &#123; handle.call(div) //间接地，将函数放到外部，通过call改变指向&#125;);function handle() &#123; //code&#125; 有了以上的知识，我们就可以封装一个兼容性的事件绑定函数了。 1234567891011function addEvent(elem, type, handle)&#123; if(elem.addEventListener)&#123; elem.addEventListener(type, handle, false); &#125;else if(elem.attachEvent) &#123; elem.attachEvent(&apos;on&apos; + type, function () &#123; handle.call(elem); &#125;) &#125;else&#123; elem[&apos;on&apos; + type] = handle; &#125;&#125; 解除事件处理程序1.句柄方式 ele.onclick=null 这样很简单的就可以解除绑定的事件处理函数了。 2.ele.removeEventListener(type, handle, false) 针对的addEventListener的解除绑定。 但是这里要注意，只有命名函数才可以解除绑定，当绑定的函数是匿名函数的时候，是没有办法解除绑定的。 12div.addEventListener(‘click’, function ()｛console.log(‘a’);｝, false);div.removeEventListener(‘click’, function ()｛console.log(‘a’);｝, false); 这是没有办法解除绑定的，因为这是两个匿名函数。 12345function test() &#123; console.log(‘a’);&#125;div.addEventListener(‘click’, test, false);div.removeEventListener(‘click’, test, false); 必须改成这种方式才可以解除绑定。 3.ele.detachEvent(‘on’ + type, handle) 针对IE的attachEvent的解除绑定。 也是同一个函数才可以解除绑定，匿名函数无法解除绑定。 封装兼容性的解除绑定函数： 123456789function remvoeEvent(ele, type, handle) &#123; if(ele.removeEventListener) &#123; ele.removeEventListener(type, handle, false); &#125;else if (ele.detachEvent) &#123; ele.detachEvent(‘on’ + type, handle); &#125;else &#123; ele[‘on’ + type] = null; &#125;&#125; 事件处理模型——事件冒泡、事件捕获先写一个三层div嵌套的结构并且给每一个div都加一个点击事件。 123456789101112131415161718192021.wrapper&#123; width:300px; height:300px; background: red;&#125;.content&#123; width:200px; height:200px; background: green;&#125;.box&#123; width:100px; height:100px; background:yellow;&#125;&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 123456var wrapper = document.getElementsByTagName(&apos;div&apos;)[0];var content = document.getElementsByTagName(&apos;div&apos;)[1];var box = document.getElementsByTagName(&apos;div&apos;)[2];wrapper.addEventListener(&apos;click&apos;,function (console.log(&apos;wrapper&apos;) &#123;&#125;,false);content.addEventListener(&apos;click&apos;,function (console.log(&apos;content&apos;) &#123;&#125;,false);box .addEventListener(&apos;click&apos;,function (console.log(&apos;box&apos;) &#123;&#125;,false); 这段代码，给每一个方块都绑定了一个点击事件，点击该方块，就会打印出对应的名字。 现在我们点击最外层的wrapper，控制台打印的wrapper。 点击box，却打印出来box和wrapper 点击content打印出来content、box、wrapper 这个现象就是我们所说的事件冒泡。 什么叫冒泡？ 在结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，子元素冒泡向父元素，结构上的自底向上。（这里的底是结构上的底，视觉上是自顶向下） 大部分事件都有事件冒泡现象，并且所有的浏览器都有事件冒泡。 结构上的冒泡，和视觉的位置没有关系，我们看一下三个方块视觉上分开。 当我们将他们的嵌套从视觉上将他们分开之后，在重复上面的操作。 和上面的情况是一样的。结构上而非视觉上。 并不是所有的事件都有冒泡，focus、blur、change、submit、reset、select等方法就没有事件冒泡现象。 事件捕获： 结构上（非视觉上）嵌套关系的元素，会存在事件捕获功能，即同一事件，自父元素捕获至子元素（事件源元素），结构上的自顶向下。 addEventListener最后一个参数就是是否开始事件捕获，当我们填true的时候，就代表开启了事件捕获。只要开启了事件捕获，就不会冒泡了，如果不捕获的话，就遵循事件冒泡。 因为addEventListener只有chrome有，因此事件捕获也只有chrome浏览器有。 依然是上面的那个例子： 123456789101112var wrapper = document.getElementsByClassName(‘wrapper’)[0], box = document.getElementsByClassName(‘box’)[0], content = document.getElementsByClassName(‘content’)[0];wrapper.addEventListener(‘click’, function (e) &#123; console.log(‘wrapper’);&#125;, true);box.addEventListener(‘click’, function (e) &#123; console.log(‘box’);&#125;, true);content.addEventListener(‘click’, function (e) &#123; console.log(‘content’);&#125;, true); 现在点击content之后，顺序是wrapper、box、content。 当事件冒泡和事件捕获同时存在的时候，事件冒泡和事件捕获的触发顺序则为：先捕获，再冒泡。 1234567891011121314var wrapper = document.getElementsByClassName(‘wrapper’)[0], box = document.getElementsByClassName(‘box’)[0], content = document.getElementsByClassName(‘content’)[0]; wrapper.onclick = function () &#123; console.log(‘wrappeBubbler’); &#125; box.onclick = function () &#123; console.log(‘boxBubble’);&#125;content.onclick = function () &#123; console.log(‘contentBubble’);&#125;wrapper.addEventListener(‘click’, function (e) &#123; console.log(‘wrapper’);&#125;, true);box.addEventListener(‘click’, function (e) &#123; console.log(‘box’);&#125;, true);content.addEventListener(‘click’, function (e) &#123; console.log(‘content’);&#125;, true); 结果是先捕获再冒泡。 但是当我们把捕获写到冒泡前面的时候，顺序好像发生了变化。 wrapper–&gt;box–&gt;contentBubble–&gt;content–&gt;boxBubble–&gt;wrapperBubble 这里是因为点击content，并不属于冒泡，而是属于事件执行，我们先绑定的boxBubble，所以就先捕获，再事件执行，再冒泡，这与我们的结论没有冲突。 取消冒泡和阻止默认事件有时候冒泡或者默认事件会对我们的功能造成影响，因此我们需要适时地取消冒泡和默认事件。 我们绑定事件的处理函数的时候，可以传递一个形参，代表我们的事件对象，一般是e或者event，系统会自动帮我们捕获事件源对象并且把事件源对象传入。 取消冒泡的方法 w3c标准方法：event.stopPropagation()1234567var wrapper = document.getElementsByClassName(‘wrapper’)[0], box = document.getElementsByClassName(‘box’)[0], content = document.getElementsByClassName(‘content’)[0];content.onclick = function (e) &#123; console.log(‘content’); e.stopPropagation();&#125; 现在我们点击content之后就没有冒泡了，但是点击box还是有冒泡的，因为我们没有取消box的冒泡。 IE9以及以下的版本不支持这个方法。 event.cancelBubble = true这个属性是IE的，不过一些高版本的浏览器也有这个属性，只要让这个属性的值等于true，同样也可以取消事件冒泡。 封装一个兼容性的取消事件冒泡的方法： 1234567function stopBubble(event)&#123; if(event.stopPropagetion)&#123; event.stopPropagetion(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 默认事件当我们在浏览器中点击右键，会弹出一个菜单，这就是一个默认事件contextmenu。还有a标签，即使我们不写跳转的页面，也会自动刷新页面，这也是一个默认事件。 移动端的默认事件更多。 默认事件有好的也有不好的，这就需要我们把不需要的默认事件阻止掉。 阻止默认事件 return false我们只要在处理函数最后写上 return false就可以阻止默认事件了。 1234document.oncontextmenu = function () &#123; console.log(‘menu’); return false;&#125; 现在我们在页面上右键就不会出现菜单了。 不过要注意的是，这种写法只能用在句柄方式绑定的事件上。 e.preventDefault()1234documet.addEventListener(‘contextmenu’, function (e) &#123; console.log(‘menu’); e.preventDefault();&#125;,false); 这是w3c标准的阻止默认事件的方法，句柄也同样可以使用。 不过IE9以下不兼容。 e.returnValue = false这个是IE的方法，事件源对象上的属性returnValue代表是否有默认事件，直接返回false就可以阻止默认事件了。现在高版本的浏览器也有这个属性。 123document.attachEvent(‘oncontextmenu’, function (e) &#123; e.returnValue = false;&#125;); 现在我们也可以封装一个兼容性的阻止默认事件的方法了： 1234567function cancelHandler(event) &#123; if(event.preventDefault) &#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 举一个小例子：阻止a标签不跳转 1234var a = document.links[0];a.addEventListener(‘click’, funciton (e) &#123; e.cancelHandler(e);&#125;,false); 这样a标签就不会跳转了。 同时我们还可以用a标签的第四个用处，协议限定符来阻止默认事件。 1&lt;a href=“javascript: void(0); “&gt;www.baidu.com&lt;/a&gt; 不仅仅是0，只要填写一个代表false的值，就可以取消掉默认事件。 事件对象在IE中，系统不会把事件对象传到方法中，因此我们的参数e或者event在IE中是不好用的，IE会把事件对象传递到window.event上，所以当我们使用事件对象的时候，就要写兼容性的写法： 1var event = e || window.event; 这样就可以正常地获取到事件对象了。 事件委托事件源对象我们现在有一个ul，下面有十万个li，当我们给父级的ul添加第一个点击事件之后，由于事件冒泡的存在，不论我们点击哪一个li都会调用父级的点击事件处理函数，这个时候触发父级ul的点击函数的那个li就被称之为事件源对象。 event.target 是火狐的获取事件源对象 event.srcElement 是IE的获取事件源对象 chrome两种都有 因此我们在获取事件源对象的时候也需要写兼容性写法， 配合刚才的事件对象的兼容性写法就是这个样子的： 12345oUl.addEventListener(‘click’, function (e) &#123; var event = e || window.event; var tar = event.target || event.srcElement; console.log(tar); &#125;, false); 我们利用事件源对象和事件冒泡来处理的方式就叫做事件委托。 12345oUl.addEventListener(‘click’, function (e) &#123; var event = e || window.event; var tar = event.target || event.srcElement; console.log(tar.innerHTML); &#125;, false); 事件委托的优点： 1.性能 不需要循环所有的子元素一个个绑定事件 2.灵活 当有新的子元素被加入的时候不需要重新绑定事件 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中鼠标事件和键盘事件的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的脚本化CSS","slug":"js的脚本化CSS","date":"2018-09-28T08:46:45.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/28/js的脚本化CSS/","link":"","permalink":"http://moreluckily.com/2018/09/28/js的脚本化CSS/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中脚本化CSS的相关知识。 读写css属性每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。 注意： 1.我们碰到float这样的关键字属性的时候，前面要加一个css前缀。 float—&gt;cssFloat 2.复合属性必须拆解 border: 1px solid red; 这种属性是不允许出现的，只能写border-width、border-color、border-style。 3.当css中的样式是用“-”连接起来的时候，我们要变成小驼峰式写法。 background-color —&gt; backgroundColor; 这个属性只能读写行间样式，我们写在css的样式是不能获取的，因此我们通过这个属性加样式的时候要注意权重值问题。 同时，我们在js中写样式只能往行间里写，永远也写不到css文件里面。 查询计算样式window上面有一个方法叫做getComputedStyle可以来获取元素的计算样式，也就是css样式。 1window.getComputedStyle(ele. null); 这里的样式是取优先级最高的，不只是行间样式，所有的只要是表现出来的样式都可以获取出来。 同时，返回的计算样式的值都是绝对值，没有相对单位。 我们写的background-color: red会返回rgb(255,0,0)，em单位或者百分比的单位都会化成具体的像素值返回。 这个方法有两个参数，第一个参数是我们要获取的元素。 第二个参数是一个字符串，代表我们是否要获取这个元素上面的某一个伪元素，如果不的话，就填写null，否则就填写要获取的这个元素的哪一个伪元素。例如：用来选取伪元素的样式，after和before， 12345678910111213div&#123; width:10em;&#125;div::after&#123; content:&quot;&quot;; width:10px; height:10px; background-color:green; display: inline-block;&#125;var div = document.getElementsByTagName(&apos;div&apos;)[0];window.getComputedStyle(div,&quot;after&quot;) //10px 但是很遗憾的是IE8以及以下的版本不兼容这个方法。 IE8有一个特殊的样式currentStyle。 dom.currentStyle也会返回一个样式表，和上面的基本一样，唯一的区别在于返回的计算样式的值不是经过转换的绝对值，而是我们写什么值就会返回什么值。 现在有了这些方法和属性，我们就可以封装一个兼容性的获取样式的函数了。 12345678function getStyle(obj, prop, fake) &#123; var fake = fake || null; if(obj.currentStyle) &#123; return obj.currentStyle[prop]; &#125;else &#123; return window.getComputedStyle(obj, fake)[prop]; &#125;&#125; 脚本化样式表在document上有一个属性叫做styleSheets，这个属性储存了一个html文档所有的css样式表的集合，我们可以来操作style标签，不过在实际中基本是用不到的，所以这里就不过多介绍了。 最后我们可以写一个让小方块运动的函数： 12345678910111213141516div#demo &#123; width: 100px; height: 100; position: absolute; left: 0; top: 0;&#125; var div = document.getElementById(‘demo’);var timer = window.setInterval(function () &#123; div.style.left = parseInt(getStyle(div, ‘left’)) + 1 + ‘px’; ifparseInt((getStyle(div, ‘left’)) &gt; 1000) &#123; clearInterval(timer); &#125;&#125;, 10); 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的事件的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的滚动条和元素尺寸","slug":"js的滚动条和元素尺寸","date":"2018-09-28T08:45:44.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/28/js的滚动条和元素尺寸/","link":"","permalink":"http://moreluckily.com/2018/09/28/js的滚动条和元素尺寸/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中滚动条与元素尺寸的相关知识。 滚动条这里需要记住一个常识：所有的W3C标准，IE9以下的浏览器都时具有兼容性问题的。 window.pageXOffset/window.pageYOffset这个方法可以查看滚动条的横轴和纵轴的滚动距离，但是很遗憾的是IE8以及以下的版本不兼容。 因此针对于IE，我们就需要有第二套方法： 123document.body.scrollLeft/doucment.body.scrollTopdocument.documentElement.scrollLeft/document.documentElement.scrollTop 虽然IE可以使用这两个方法，但是这两个方法不仅仅是IE才可以使用。 这里要说明的是，这两种方法要一起使用，因为浏览器的兼容性问题，有的浏览器是document.body有值，有的是document.documentElement有值，但是所有的浏览器都只有一个有值，不会两个都有或者一个都没有，而且这里的没有值不代表是null，而是0，因此我们使用的时候一般都是两个一起使用。 针对兼容性的问题，我们现在就可以封装一个函数，求滚动条滚动距离的方法。 1234567891011121314function getScrollOffset()&#123; if(window.pageXOffset)&#123; return &#123; //w3c标准 x : window.pageXOffset, y : window.pageYOffset &#125; &#125;else&#123; return &#123; x : document.body.scrollLeft + document.documentElement.scrollLeft, Y : document.body.scrollTop + document.documentElement.scrollTop &#125; &#125;&#125;console.log(getScrollOffset())//打印当前的滚动条 查看视口的尺寸视口就是我们的可视区，因为我们改变浏览器的大小的时候会改变可视区的大小，那么我们如何来查看当前浏览器的可视区大小？ 这里我们依然有两套方法： 1window.innerHeight/window.innerWidth; 这个方法可以直接获取到当前可视区的宽高，但是依然很遗憾的是IE8以及以下的版本不兼容。 这个时候就需要第二套方法了： 在标准模式下， 1doucment.documentElement.clientWidth/document.documentElement.clientHeight 在任何浏览器都兼容。 在怪异模式（混杂模式）下， 1document.body.clientWidth/document.body.clientHeight 才能查看视口大小，而不能使用上面标准模式下的方法。 我们如何变成怪异模式呢？ 其实很简单，只需要把我们html代码的第一行的&lt;!DOCTYPE HTML&gt;去掉就可以变成怪异模式了，而加上这一行代码就可以变成标准模式。 如何判断怪异模式还是标准模式？ document上中有一个方法叫做compatMode，当浏览器处于怪异模式的时候会返回字符串“BackCompat”，在标准模式下可以返回“CSS1Compat”，通过这个方法我们就可以判断了。 知道了什么是标准模式和怪异模式以及如何判断的情况下，我们就可以封装一个兼容性的函数，返回浏览器的视口大小。 12345678910111213141516function geteViewpotOffset() &#123; if(window.innerWidth)&#123; return &#123; w : window.innerWidth, h : window.innerHeight &#125; &#125;else if(document.compatMode == &quot;BackCompat&quot;)&#123; return &#123; w : document.body.clientWidth, h : document.body.clientHeight &#125;else&#123; return &#123; w : document.documentElement.clientWidth, h : document.documentElement.clientHeight &#125;&#125; 需要写一个函数，来判断各种数据类型，包括包装类。123456789101112131415161718192021222324function type(target)&#123;var typeStr = typeof(target), toStr = Object.prototype.toString, objStr = &#123; &quot;[object Object]&quot; : &quot;object - Object&quot;, &quot;[object Array]&quot; : &quot;array - Object&quot;, &quot;[object Number]&quot; : &quot;number - Objcet&quot;, &quot;[object Boolean&quot; : &quot;boolean - Object&quot;, &quot;[object String]&quot; : &quot;string - Object&quot; &#125;if(target === null) &#123;//判断null直接 看是不是等于 null即可，利用call会报错 return null;&#125;else if(typeStr === &quot;function&quot;)&#123; return &quot;function&quot;;&#125;if(typeStr === &quot;function&quot;)&#123; return &quot;function&quot;;&#125;if(typeStr !== &quot; object&quot;)&#123; return typeStr;&#125;else &#123; return objStr[toStr.call(target)]; //判断最后的对象 对应的类型。&#125; 查看元素的几何尺寸domEle.getBoundingClientRect()在获取的dom元素上，有一个getBoundingClientRect方法，这个方法可以获取到元素的宽高和左上点的位置以及有下点的位置（width、height、top、left、right、bottom），注意这里的宽高是指除去了margin的盒子模型的宽高。 但是老版本的IE浏览器没有实现width和height，那么我们在老版本的IE计算宽高的时候就需要用bottom-top和right-left来计算宽高值了。 还有一点需要注意的是，这里的宽高也不是实时更新的，数据只是一个副本。 我们依然可以封装一个函数，可以返回元素的宽高。 1234567891011121314Element.getElementOffset() &#123; var objData = this.getBoundingClientRect(); if(objData.width) &#123; return &#123; w: objData.width, h: objData.height &#125; &#125;else &#123; return &#123; w: objData.right - objData.left, h: objData.bottom - objData.top &#125; &#125;&#125; 滚动条滚动让滚动条滚动的方法有三个：scroll、scrollTo、scrollBy。 这三个方法都有两个参数，分别是x值和y值。前两个方法的作用一模一样，都是让滚动条滚动到（x，y）的位置，但是最后一个scrollBy有一些区别，它是让滚动条相对于上一个位置滚动多少距离。 我们可以简单的用这个方法来实现一个自动阅读的功能： 123456789101112131415161718192021222324252627&lt;button style=&quot;width:50px;height:50px;border-radius:50%;box-shadow:1px 2px 3px #000;background:red;opacity:0.7;position:fixed;bottom:150px;right:50px;&quot;&gt;start&lt;/button&gt;&lt;button style=&quot;width:50px;height:50px;border-radius:50%;box-shadow:1px 2px 3px #000;background:yellow;opacity:0.7;position:fixed;bottom:50px;right:50px;&quot;&gt;stop&lt;/button&gt;&lt;button style=&quot;width:50px;height:50px;border-radius:50%;box-shadow:1px 2px 3px #000;background:orange;opacity:0.7;position:fixed;bottom:250px;right:50px;&quot;&gt;speed&lt;/button&gt; var start = document.getElementsByTagName(&apos;button&apos;)[0];var stop = document.getElementsByTagName(&apos;button&apos;)[1];var su = document.getElementsByTagName(&apos;button&apos;)[2];var speed = 1;var timer = 0;var key = true;start.onclick = function()&#123; if(key) &#123; timer = setInterval(function()&#123; window.scrollBy(0, speed); &#125;, 50); key = !key; &#125;&#125;stop.onclick = function () &#123; clearInterval(timer); key = true;&#125;su.onclick = function () &#123; if(speed &lt; 5) &#123; speed ++; &#125;&#125; 得到的效果图如下： 可以操控按钮去控制自动阅读，可以加速和停止等操作。 另一个查看元素尺寸的方法dom.offsetWidth/dom.offsetHeight虽然前面有一个ele.getBoundingClientRect()方法，但是由于这个方法名字是在太长了，因此用的并不是非常多，相比较而言，这两个dom元素的属性用的更多一些。 这里获取的宽高值和上面的一样，都是除去margin后的盒子模型的宽高。 查看元素的位置dom.offsetLeft/dom.offsetTop这两个值分别是元素距离左侧和上侧的距离，这里的值是相对于有定位的父级而言的，如果没有有定位的父级的话，才是相对于文档的坐标。 那么现在就来了一个问题：如何找到有定位的父级呢？ domEle上面还有一个属性是offsetParent，这个属性可以查看到元素的有定位的父级，如果没有的话就会返回body，而body的offsetParent则是null。 我们利用上面的信息，可以来封装一个函数，求元素的相对于文档的坐标。 1234567891011121314151617181920Element.prototype.getPosition = function ()&#123; if (!this.offsetParent)&#123; return &#123; “w”: this.offsetLeft, “h”: this.offsetTop &#125; &#125; var width = this.offsetLeft, height = this.offsetTop, ele = this.offsetParent; while (ele.offsetParent)&#123; width += this.offsetParent.offsetLeft; height += this.offsetParent.offsetTop; ele = ele.offsetParent; &#125; return &#123; “w”: width, “h”: height &#125;&#125; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的脚本化CSS相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的日期和定时器","slug":"js的日期和定时器","date":"2018-09-28T08:43:38.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/28/js的日期和定时器/","link":"","permalink":"http://moreluckily.com/2018/09/28/js的日期和定时器/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中日期对象和定时器的相关知识。 封装一个函数insertAfter(),功能类似于insertBefore()上篇的blog说过了关于insertBefore(a,b)的方法，父级调用，在a之前插入b.那么对于这个insertAfter(a,b)方法也是类似的，也是有父级调用，在a后面插入b。了解了功能之后，我们就要开始实现了。由于手头上方法，也就那么一个 insertBefore()，利用它我们可以进行插入的操作。但是，在插入之前，我们需要找到插入节点的位置，那么我们怎样才能找到需要进行插入操作得节点呢？请看以下分析： 12345&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;a&gt;&lt;/a&gt;&lt;/div&gt; 如果我们需要在em标签后面插入节点，就相当于在a标签之前插入节点，他们两个是等价的，所以，我们就可以利用这个思维，先找到想插入的节点a的下一个兄弟节点b，然后对b节点调用insertBefore方法，在b之前插入目的节点，那么就相当于在a之后插入了一个目标节点了。 明白了这个问题之后，我们还需要判断他是否有兄弟节点，如果存在，就调用insertBefore，如果没有就进行appendChild即可。代码如下： 12345678Element.prototype.insertAfter = function (target,afterNode)&#123; var siblingNode = afterNode.nextElementSibling; if(siblingNode)&#123; this.insertBefore(target, siblingNode); &#125;else&#123; this.appendChild(target); &#125;&#125; 我们来实验一下，看一下这个封装的方法对不对。 12345678910var p = document.createElement(&apos;p&apos;);//创建一个p标签var div = document.getElementsByTagName(&apos;div&apos;)[0];var span = document.getElementsByTagName(&apos;span&apos;)[0];var em = document.getElementsByTagName(&apos;em&apos;)[0];var a = document.getElementsByTagName(&apos;a&apos;)[0];div.insertAfter(p, a);//p标签去a标签的后面console.log(div);//p标签去a的后面了div.insertAfter(p, span);console.log(div);//p标签去span的后面了 封装remove()函数，使得child.remove()可以销毁自身。在原型链上对其进行操作：1234Element.prototype.remove = function () &#123; var parent = this.parentNode; parent.removeChild(this);&#125; 这个问题的代码其实很简单，只要找到这个元素的父级，然后让父级删除掉这个元素就可以了。 将目标节点内部的节点顺序逆序。123&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt; --&gt; (逆转)&lt;div&gt;&lt;a&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; 对于这个题目，是利用我们插入的元素如果是本身就存在的，那么就会剪切到新的位置上这个特性来做的。 其实就是将倒数第二个标签，放在最后一个位置，然后倒数第三个标签其实还在倒数第三个标签的位置，然后将倒数第三个标签放在最后一个位置。依次类推： 12345678910111213Element.prototype.reverseElement = function()&#123; var len = this.childNodes.length, child, first = this.firstChild; for (var i = 0; i &lt; len - 1; i++)&#123; child = this.lastChild; this.insertBefore(child, first); &#125;&#125;var p = document.getElementsByTagName(&apos;p&apos;)[0];var div = document.getElementsByTagName(&apos;div&apos;)[0];var a = document.getElementsByTagName(&apos;a&apos;)[0];console.log(div.reverseElement());//就会逆序 静态类JavaScript慢慢发展向面向对象，朝向Java方向，原型，继承等都是面向对象的，慢慢就摒弃面向过程编程。当我们想使用某些方法的时候，通常可以使用new进行构造出来，或者直接使用 原型链上的方法，这种形式的就叫动态的方法。例如： 12345function Person()&#123; this.aaa = function() &#123; &#125;;&#125;var demo = new Person();demo.aaa();//调用方法 这种就叫做动态类。 后来有些方法不需要这么麻烦的方法，每次都去生成一个对象。有些很简单的就不需要这样操作。例如Math方法：Math.random,Math.sqrt。这样的方法其实是直接挂在一个对象上面可以直接调用。 12345Math = &#123; random: function() &#123; &#125;, sqrt: function() &#123; ], .........&#125;//可以直接调用 日期对象日期对象的各种方法和用法在w3c上有详细的介绍。 日期对象也是javascript的内置对象之一，我们可以直接使用。 123var data = new Data();Date();// &quot;Fri Sep 28 2018 11:23:56 GMT+0800 (中国标准时间)&quot; |Date()|返回当日的日期和时间。|//date.getDate()//28|getDate()|从 Date 对象返回一个月中的某一天 (1 ~ 31)。||getDay()|从 Date 对象返回一周中的某一天 (0 ~ 6)。||getMonth()|从 Date 对象返回月份 (0 ~ 11)。|//要自己加一|getFullYear()|从 Date 对象以四位数字返回年份。||getYear()|请使用 getFullYear() 方法代替。||getHours()|返回 Date 对象的小时 (0 ~ 23)。||getMinutes()|返回 Date 对象的分钟 (0 ~ 59)。||getSeconds()|返回 Date 对象的秒数 (0 ~ 59)。||getMilliseconds()|返回 Date 对象的毫秒(0 ~ 999)。||getTime()|返回距1970年1月1日凌晨的毫秒数| |getTime()|返回距1970年1月1日凌晨的毫秒数|纪元时间,计算机查现在到这个时候得时间,然后返回今天的时间.通常是两个getTime联合使用，求时间差。 123456var firstTime = new Date().getTime;for(i = 0; i &lt; 100000000; i++)&#123;&#125;var lastTime = new Date().getTime;console.log(lastTime - firstTime)//这个可以求出来程序的执行时间。 第二个作用就是作为时间戳：每一次发的请求都是不一样的，利用它可以做唯一表识。 Date.parse( ) : 注意它是用Date作为调用对象，参数是必须的，将参数转化为毫秒数。 |setDate()|设置 Date 对象中月的某一天 (1 ~ 31)。||setMonth()|设置 Date 对象中月份 (0 ~ 11)。||setFullYear()|设置 Date 对象中的年份（四位数字）。||setYear()|请使用 setFullYear() 方法代替。||setHours()|设置 Date 对象中的小时 (0 ~ 23)。||setMinutes()|设置 Date 对象中的分钟 (0 ~ 59)。||setSeconds()|设置 Date 对象中的秒钟 (0 ~ 59)。||setMilliseconds()|设置 Date 对象中的毫秒 (0 ~ 999)。||setTime()|以毫秒设置 Date 对象。| 123456789设置时间，在哪个时间干别的事var date = new Date();date.setSeconds(date.getSeconds() +20); //设定时间 setInterval(function () &#123; if(Math.abs(new Date().getTime() - date.getTime()) &lt; 500 )&#123; console.log(&apos;coming&apos;); &#125;&#125;, 500);//程序到了规定时间将会打印出coming。 Js定时器一个常识：浏览器会每隔16毫秒刷新页面一次 setInterval(); //定时clearInterval(); //清除定时 这些方法都是定义在window对象上面的，因此我们写window.setInterval和解setInterval的意思是一样的，前面的window可以省略掉。 setInterval这个定时器的功能是每过一段时间，就把我们想要执行的函数放到js的执行队列中等待执行。因为执行队列不一定是空的，需要等执行队列中的所有任务都执行完之后才会执行我们的函数，因此这个函数执行的时间也会有细微的差别。 这个方法的语法是： 1setInterval(function () &#123;&#125;, 1000); 第一个参数是我们要执行的函数，第二个参数是每过多长时间把函数放入执行队列。 这里要说明的是，第一个参数的那个函数，不能带有参数。其次，里面的this默认指向window，因为前面提到过，谁调用方法，方法里面的this就指向谁，setInterval其实前面省略了window，因此里面的this默认一定指向window，不论这个setInterval是否是一个对象的方法。 setInterval其实很消耗内存，这个定时器一旦执行，就不会终止，因此需要我们的内核一直监听这个函数。 这个时候我们就需要一个方法来清除定时器了：clearInterval。 定时器其实会返回一个标记，我们可以通过定时器的这个标记来清除掉相对应的定时器。 1234567var i = 0;var timer = setInterval(function () &#123; console.log(i++); if(i &gt; 10)&#123; clearInterval(timer);//清除定时器 &#125;&#125;, 1000); //在1000ms左右 这个函数的功能就是每1000ms打印一个数字i，当i大于10时，就会清除定时器，也就是打印出了0~10。 这里有一点需要特别强调：凡是写定时器，一定要清除定时器！ 还有一点需要注意的是，定时器是先等待再执行。 有时候我们只需要这个函数延迟一段时间执行，并不需要专门开启一个定时器，这个时候就需要用到setTimeout了。 setTimeout是延迟执行的意思，语法和用法和setInterval一样，只是这个方法只是把函数延迟一段时间之后执行一次而已。比较常见的就是看电影的试看功能。 同时它也有clearTimeout，当我们不想让这个函数执行了，提前把它clear掉就可以了。 其实setInterval和setTimeout的第一个参数不一定非要是一个函数，它也可以是一串字符型的js代码。 1setInterval(“console.log(1);”, 100); 这段代码同样可以执行，定时器每100ms给我们打印一个1。 通过这个特性，我们不一定要把函数写在定时器里面，大部分时间我们都是在外部把函数定义好了，然后直接把函数名传进去就可以了。 12function test () &#123;&#125;setInterval(test, 1000); 写一个计时器，到三分钟停止123456789101112131415161718192021222324252627&lt;style&gt; input&#123; border: 1px solid rgba(0,0,200,0.5); text-align: right; &#125;&lt;/style&gt;minute:&lt;input type=&quot;text&quot; value=&quot;0&quot;&gt; second:&lt;input type=&quot;text&quot; value=&quot;0&quot;&gt; var minuteNode = document.getElementsByTagName(&apos;input&apos;)[0];var secondNode = document.getElementsByTagName(&apos;input&apos;)[1];var minute = 0;var second = 0;var timer = 0;timer = setInterval(function() &#123; second ++; if(second == 60) &#123; minute += 1; second = 0; &#125; minuteNode.value = minute; secondNode.setAttribute(&apos;value&apos;,second); if(minute == 3)&#123; clearInterval(timer); &#125;&#125;, 10); 得到的结果如下图所示： 就是右边的没个10ms计一个数，当超过60个数时，左边的数加一，右边的数又从0开始计数，等左边的数为3使，停止计数。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的滚动条与元素尺寸相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的DOM操作续","slug":"js的DOM操作续","date":"2018-09-27T15:25:10.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/27/js的DOM操作续/","link":"","permalink":"http://moreluckily.com/2018/09/27/js的DOM操作续/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中DOM基本操作续的相关知识。 DOM基本操作续createElement创建元素节点: 我们可以通过:1document.createElement(‘div’); 这个方法来创建一个元素，里面的参数填写我们要创建的标签名称，像div、p、span等等。 createTextNode创建文本节点: 我们可以通过:1document.createTextNode(‘abcd’) 方法来创建一个文本节点，里面的参数填写我们的文本内容。 createComment创建注释节点: 我们可以通过:1document.createComment(‘comment’); 方法来创建一个注释节点，参数写我们要写的注释内容。 createDocumentFragment这个方法可以创建一个文档碎片，有关提高性能的部分会用到这个方法。 插入操作appendChild(child);这个是父级调用的方法，它会将child元素插入到父级里面，而且是放到逻辑后面的位置上。 12div.appendChild(text);div.appendChild(comment); 这里如果是我们创建的元素，那么appendChild就是把新元素插入进去，但是如果是DOM里面已经存在的元素，那么appendChild就是把这个已经存在的元素给剪切掉，然后放到新的位置上。 insertBefore(a, b);这个依然是父节点调用的方法，它的意思是将a插入到b前面的位置上，其中b要求是这个父级的子节点。这个方法可以记作为 insert a before b; 12var span = document.createElement(‘span’);div.insertBefore(span, comment); 这样我们就把一个span元素插入到了刚才的注释文本前面。 删除操作removeChild这个方法依然是父级调用的，参数就是要删除的子节点，其实实际上是剪切，这个方法会把我们删除掉的元素给返回，我们可以用一个变量去保存这个被删除的元素。 1var div = document.body.remove(div); 这样我们的div变量就可以保存刚才被删除的div这个元素。 替换操作replaceChild(new, origin)这个方法同样是父级调用，用新的元素new来替换原来的origin元素，原来的被替换掉的元素可以被返回，我们可以像删除操作那样用一个变量来保存。 现在我们就可以通过以上这些方法来动态创建一棵DOM树了。 下面介绍一些Element节点的属性和方法： innerHTML这个属性可以用字面意思来理解，元素里面的HTML结构。 1div.innerHML = ‘&lt;div&gt;123&lt;/div&gt;’; 我们可以直接通过这个属性来改变元素内部的结构和内容，不过注意它会直接删除掉以前的所有结构，如果以前内容还有其他的节点的话，使用的时候就要小心了。 1234demo.innerHTML = &apos;&lt;p&gt;\\ &lt;span&gt;&lt;/span&gt;\\&lt;/p&gt;&apos;;//不能有空格，加\\ 拷贝的时候注意，不能有空格。 innerText/textContentinnerText老版本的火狐浏览器不兼容，textContent老版本的IE浏览器不兼容。 这个属性可以直接调出来元素内部的文本信息，若果这个元素还有很多的子元素的话，那么会把子元素里面的文本信息一起返回。 不过需要注意的是，如果我们要改写innerText或者textContent的话，它会像innerHTML一样，先把内部的所有html结构先删除掉，然后再写入text文本，因此里面有html结构的时候写入也要小心。 这里提一下，如果我们有很多字符串要添加到一个元素的内部的话，虽然用innerHTML或者innerText方法，但是却不是用innerHML += str的方法，因为+=操作符的效率极低，当字符串很多的时候会非常非常消耗性能。 遇到这种情况我们一般是用数组的join方法将字符串全部连接成一个字符串，然后一次性写入innerHTML。 ele.setAttribute();这个方法可以设置元素的属性（特性），比如class、id等一些行间属性。 1div.setAttribute(‘id’, ‘demo’); 这个操作就可以给div这个元素设置一个叫做demo的id。 ele.getAttribute();这个方法是获取元素的行间属性。同样这里需要提一下，每个元素自带的行间属性都有自己特殊的功能，而我们通过自己给他们设置的属性并没有任何功能，因此我们可以来赋予他们功能和用处。还有一点，我们在后面改变元素的样式的时候，通常不是直接修改他的css样式，而是事先写好它应该变成的样式，然后装进一个class里面，我们直接修改他的类名而不是css样式。 12345&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;demo.setAttribute(&apos;sex&apos;, &apos;male&apos;);demo.setAttribute(&apos;clickTimes&apos;, &apos;10&apos;);console.log(demo.getAttribute(&apos;id&apos;));//democonsole.log(demo.getAttribute(&apos;clickTimes&apos;));//10 请编写一段JavaScript脚本生成下面这段DOM结构。要求：使用标准的DOM方法或属性。其实就是用DOM动态生成这样一个结构： 123&lt;div class=”example”&gt; &lt;p class=”slogan”&gt;HelloWorld&lt;/p&gt;&lt;/div&gt; 比较麻烦的写法就是： 12345678var div = document.createElement(‘div’),p = document.createElement(‘p’),text = document.create(‘HelloWorld’);div.setAttribute(‘class’, ‘example’);p.setAttribute(‘class’, ‘slogan’);p.appendChild(text);div.appendChild(p);document.body.append(div); 不过这里有点小提示，节点的className属性可以读写操作class。 因此这里我们为标签赋类名的值的时候可以不用setAttribute，可以直接用className。 12div.className = ‘example’;p.className = ‘slogan’; 不过，还有一个最取巧的办法，那就是直接用innerHTML。 1div.innerHTML = &lt;p class=“slogan”&gt;HelloWorld&lt;/p&gt; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的日期对象相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的DOM结构树","slug":"js的DOM结构树","date":"2018-09-27T15:24:27.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/27/js的DOM结构树/","link":"","permalink":"http://moreluckily.com/2018/09/27/js的DOM结构树/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中DOM结构树的相关知识。 DOM结构树 这个图表中说明了每一个对象的父级。 123456//Document -&gt; 是一个构造函数 -&gt; 但是用户不能newdocument.__proto__ === HTMLDocument.prototype; //true//HTMLDocument.prototype -&gt; &#123;__proto__: Document.prototype&#125;//Document.prototype -&gt; &#123;__proto__: Node.prototype&#125;Node.__proto__.__proto__.__proto__ --&gt; object 浏览器除了可以处理html页面外，还可以处理xml和xhtml等页面。 我们发现HTMLDocument继承自HTMLDocument.prototype，我们在原型上定义一个属性来测试一下。 123HTMLDocument.prototype.abc = 123;document.abc; // 123document.getElementById(‘demo’).abc; // 报错 由此可见，HTMLDocument确实继承HTMLDocument对象的属性，但是相对的Element上面并没有这个方法。 这里的Node上面也还是有父级的，我们可以通过Node.prototype来查看，这里就不举例了。Node的原型链终端指向我们熟悉的Object。 Element：构造出html元素，包括各种head标签，body 元素等，它们的元素都继承自对应的父级的方法，意思是，HTMLheadelement的方法，只能允许HeadElement使用，其他元素节点不可以使用。 下面是一些DOM结构树的总结： DOM树总结*1、getElementById方法定义在Document.prototype上，意思就是document下的所有元素的都能使用，其他层级下就不行，例如Element节点上不能使用。 2、getElementByName方法定义在HTMLDocument.prototype上，非html中的document不能使用(xml document、Element); 3.getElementsByTagName方法定义在Document.prototype和Element.prototype上，也就是document和元素都可以用这个方法。 4.HTMLDocument.prototype上定义了一些常用的属性，body、head分别代指HTML文档中的bode,html标签。 12document.body //直接能用document.head // 直接能用 5.Document.prototype上定义了documentElement属性，指代文档的根元素，在html文档中，它总代指html元素。 1docuent.documentElement //特指html 6.getElementByClassName、querySelectorAll、querySelector在Document、Element类中均有定义。 DOM的基础练习代码前面介绍了DOM的一些基础的知识，整理一下有关其知识点的封装函数。 遍历元素节点树，要求不能用children属性123456789101112function retChildren(node)&#123; var child = node.childNodes; var len = child.length; var arr = []; for (var i = 0; i &lt; len; i++)&#123; if(child[i].nodeType === 1)&#123; arr.push(child[i]); &#125; &#125; return arr;&#125; 拿出一层树，循环遍历父节点，求子节点的的子节点，层层递归即可 封装函数，返回元素e的第n层祖先元素。123456789101112131415&lt;div&gt; &lt;strong&gt; &lt;em&gt; &lt;span&gt;123&lt;span&gt; &lt;/em&gt; &lt;/strong&gt;&lt;/div&gt;var span = document.getElementsByTagName(&apos;span&apos;)[0];function retParent(e, n)&#123; while(e || n)&#123; //如果n太大，e为null，为了兼容，先判断e是否存在。 e = e.parentElement;//寻找父节点,并赋值给自己，下一圈循环直接使用。 n --; &#125; return e;&#125; 封装成函数： 12345678910function retParent(e, n) &#123; var n = n || 0; // 进行简单的容错检测 if(n === 0) &#123; return e; &#125; for(var i = 0; e &amp;&amp; i &lt; n; i++) &#123; e = e.parentNode; &#125; return e;&#125; 封装函数，返回元素e的第n个兄弟元素节点，如果n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己123456789101112131415161718192021function retSibling(e,n)&#123;//兼容IE var nodeSibling = e; while (nodeSibling &amp;&amp; n)&#123;//利用循环控制圈数 if (n&gt;0) &#123; if(nodeSibling.nextElementSibling)&#123;// 如果不是ie浏览器 nodeSibling = nodeSibling.nextElementSibling; &#125;else&#123; // 如果是ie浏览器 for(nodeSibling = nodeSibling.nextElementSibling; nodeSibling &amp;&amp; nodeSibling.nodeType !== 1; nodeSibling = nodeSibling.nextElementSibling); &#125;//利用for循环执行流程解决，判断是否为Element节点，而且判断存在的时候才能赋值（因为存在null的情况） n --; &#125;else&#123; if (nodeSibling.previousElementSibling) &#123; nodeSibling = nodeSibling.previousElementSibling; &#125;else&#123; for(nodeSibling = nodeSibling.previousElementSibling; nodeSibling &amp;&amp; nodeSibling.nodeType !==1;nodeSibling = nodeSibling.previousElementSibling); &#125; n ++; &#125; &#125; return nodeSibling;&#125; 封装函数，实现children功能，在原型链上编程123456789101112131415Element.prototype.myChildren = function () &#123; var myChildNodes = this.childNodes, len = myChildNodes.length, arr = &#123; //高级写法 仿一个类数组 length : 0, splice : Array.prototype.splice, push : Array.prototype.push, &#125;; for(var i = 0; i &lt; len; i++)&#123; if(myChildNodes[i].nodeType == 1)&#123; arr.push(myChildNodes[i]); &#125; &#125; return arr;&#125; 判断元素节点，非元素节点扔掉。 自己封装hasChildren()方法，不可用children属性12345678910Element.prototype.myChildren = function () &#123; var myChildNodes = this.childNodes, len = myChildNodes.length; for(var i = 0; i &lt; len; i++)&#123; if(myChildNodes[i].nodeType == 1)&#123; return true; &#125; &#125; return false;&#125; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中DOM基本操作续的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的DOM操作","slug":"js的DOM操作","date":"2018-09-27T15:24:10.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/27/js的DOM操作/","link":"","permalink":"http://moreluckily.com/2018/09/27/js的DOM操作/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中DOM的相关知识。 DOM什么是DOM呢？ DOM的全称是Document Object Model 文档对象模型，DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。 DOM对象即为宿主对象，由浏览器厂商定义，用来操作html的css功能的一类对象和集合。不过浏览器厂商之间大部分都遵循w3c标准。 简单来说，DOM就是用来操作html和css的，它是一系列对象的集合。 为什么要用DOM？JS不能直接操作html，但是浏览器提供了一类对象，这些对象可以作为js操作html的桥梁，也就是说这类对象中有方法和属性，对方法和属性的调用与修改都会映射到html对应的标签中。 DOM操作：按照文档对象模型 （这些固定的方法和规则）操作标签，这里首先要说一下document这个老大哥，它是JS操作HTML标签的开始，无论你是要获取标签还是创建新标签都需要它。 DOM如何操作HTMLdocument代表整个文档，它也是一个dom元素，我们dom对html的操作，即使对html的增删改查。下面我就介绍一下dom都是如何增删改查html的。 那么我们如何查看元素节点？ 我们知道css中有id、class、标签等选择器，同样，我们的document对象上也定义了很多类似的方法来查看元素节点。 getElementById1234&lt;div id=&quot;only&quot;&gt;&lt;/div&gt;document.getElementById(&apos;id&apos;);//或者document.getElementById(&apos;only&apos;); 通过元素的id来选择出相对应的元素的，因为id是唯一标示，所以方法名中是Element。通过id选出来的对象只有一个对象。 值得注意的是，在ie8以下的浏览器中，不区分大小写，而且标签的name属性也可以被当做id被选择出来。 12&lt;div name=&quot;only&quot;&gt;&lt;/div&gt;document.getElementById(&apos;only&apos;); 这里同样能把这个div选择出来了。 getElementsByClassNamedocument.getElementsByClassName(&#39;class&#39;); 获取到的是一个类数组，因为很多元素都可以有一个类名。我们可以通过[ ]的方式来选择到具体的哪一个元素。 123&lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;&lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;var div = document.getElementsByClassName(&apos;demo&apos;)[0]; 这样我们就可以选择到第一个div了。 那如果碰到下面这种情况怎么办呢？ 123&lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;&lt;div class=&apos;demo demo1&apos;&gt;&lt;/div&gt;&lt;div class=&apos;demo1&apos;&gt;&lt;/div&gt; 在这里，我们的getElementsByClassName其实后面可以填写多个类名。 1var div = document.getElementsByClassName(&apos;demo demo1&apos;)[0];//一定要选[ ] 这样，我们就可以选择出来第二个div了。 但是值得注意的是，ie8及以下的版本中没有这种方法。 getElementsByTagName1document.getElementsByTagName(&apos;div&apos;); 返回的是一个类数组。简单判断选择出来的是一个还是一组，可以看Element后面有没有s有就是一组，没有就是一个。当选出来是一组的话，想操作单个对象，就需要在后面加[ ]。 123456&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;var li = document.getElementsByTagName(&apos;li&apos;)[0]; //单独选出来第一个li元素。 getElementsByName1document.getElementsByName(); 只有部分标签的name可以生效，比如：表单、表单元素、img、iframe等。需要注意的是：div就是没有name属性的。 12&lt;input name=&apos;123&apos;&gt;document.getElementsByName(&apos;123&apos;)[0]; 同样是选择出来一组，不过这个方法不是很常用。有些情况要跟后端进行数据传输的时候就需要用到。 querySeletor()和querySelectorAll()12document.querySeletor();//选出一个document.querySelectorAll();//选出一组 我们知道选择元素最强的是css，而这两个里面写的参数就是我们css选择器的写法。 1234567&lt;div&gt; &lt;em class=&quot;abc&quot;&gt;&lt;/em&gt; &lt;span class=&apos;abc&apos;&gt; &lt;em class=&quot;abc&quot;&gt;123&lt;/em&gt; &lt;/span&gt;&lt;/div&gt;var emEle = document.querySelector(&quot;div .abc span em&quot;); 不过querySelector永远选择一组里面的第一个，所以返回的不是一个类数组而是一个具体的元素。 而我们如果要返回一个类数组的集合的话，那么就用第二个querySelectorAll()方法。 不过这两个方法的问题在于，他们返回的不像前面四个是一个实时改变的元素，而是一个副本。当我们用这两个方法选择出来元素之后，我们把本身那个元素修改一下，会发现我们选择出来的那个元素没有变化。 12345678&lt;div class=”content”&gt;111&lt;/div&gt;&lt;div class=”content”&gt;222&lt;/div&gt;&lt;div class=”content”&gt;333&lt;/div&gt;var div = document.querySelectorAll(‘.content’);var div1 = document.getElementsByClassName(‘content’)[0];console.log(div);div1.remove();console.log(div); 我们发现两次打印出来的都是[div.content, div.content, div.content]，也就是说我们实际删除的那个元素对用querySelector选择出来的那个副本没有影响。 不过，在ie7及以下的版本没有这两个方法。 1这里面我们我们最常用的是id和tag 节点节点类型我们页面里面的节点类型很多，比如元素节点、文本节点、注释节点、属性节点等等。 我们可以通过nodeType属性这个来查看这个节点的类型是什么。而nodeType返回的是一些数字，下面介绍几个基础的类型和数字的对应关系： 123456元素节点——1属性节点——2文本节点——3注释节点——8document——9DocumentFragment——11 节点的其他属性nodeName这个属性可以返回元素的标签名，以大写的形式表示，只读，不允许写入!!! 有几个特殊的节点返回的也不太一样： 123文本节点–&gt; #text注释节点–&gt; #commentdocument节点–&gt;#document nodeValueText节点或者Comment节点的文本内容，可以读写。能修改，能查询。 attributes把元素的行间属性都读取出来，放到一个对象里面返回，对象里面的每一个属性都是一个节点，这个节点就是我们前面提到的属性节点。 注意：对象里面的属性叫做property，而元素里面的属性叫attributes，实际应该叫特性。 1234&lt;div style=&quot;width: 100px; height: 100px;&quot; class=&quot;demo&quot; &gt;var div = document.getElementByTagName(&apos;div&apos;)[0];div.attributes // NamedNodeMap&#123; 0:style,1:class, length:2&#125;div.attbributes[0] //style = &quot;width:100px;height:100px;&quot; 节点还有一个方法： hasChildNodes( )可以检测是否有子节点。 遍历节点树parentNode 查找父节点123&lt;div&gt; &lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt; 这里strong的父节点就是p，p的父节点是div，div的父节点是body，body的父节点是html，html的父节点是document，document的父节点是null，在后面就没有了。 childNodes 子节点们childNodes 没有说明类型，那么就是说这个方法是把所有的子节点都返回。 123&lt;div&gt; &lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt; 我们div里面的childNodes其实有3个，第一个是前面的空格——文本节点，第二个是中间的p标签——元素节点，第三个是最后的空格——文本节点。 firstChild 第一个子节点lastChild 最后一个子节点nextSibling 下一个兄弟节点previousSibling 上一个兄弟节点以上这些方法的兼容性都很好，所有的浏览器都支持，但是下面这些就不行了。 基于元素节点树的遍历parentElement 返回当前元素的父元素节点，在这个方法上面，html上面的父元素节点就不是document而是null了。因为document自成一类，不是元素节点。 但是ie不兼容。 children所有子元素节点，这个方法所有的浏览器都兼容。 childElementCount1node.children.length === node.childElementCount 这个属性就是子元素节点的数量，不过更常用的是前面的那个。 nextElementSibling和previousElementSibling返回后一个/前一个兄弟元素节点（IE不兼容) firstElementChild和lastElementChild返回第一个/最后一个兄弟元素节点（IE不兼容) 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中DOM结构树的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的类数组","slug":"js的类数组","date":"2018-09-26T12:30:03.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/26/js的类数组/","link":"","permalink":"http://moreluckily.com/2018/09/26/js的类数组/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中类数组的相关知识。 类数组类数组本质上是一个对象，只是它用对象来模拟出数组的效果，我们把这种对象叫做类数组。我们前面提到的arguments实参列表就是一个类数组。类数组不具备数组的一些方法。举个例子： 12345function test()&#123; arguments.push(1);&#125;test(1,2,3,4,5,6)//会报错 它的原型指向的是Object。而数组原型指向的是Array。它只是长的像数组。 123456789var obj = &#123; &quot;0&quot; : 0, &quot;1&quot; : 1, &quot;2&quot; : 2, &apos;length&apos; : 2, &apos;push&apos; : Array.prototype.push&#125;obj.push(5); //&#123;0: 0, 1: 1, 2: 5, length: 3, push: ƒ&#125;obj[0]//0 我们会发现它自动改变了length值，这就非常神奇了。其实类数组的关键就在这个length属性上，如果没有length属性，那么就是一个普通的对象，即使有push方法也不能使用。 现在我们来模拟一下数组的push方法是怎么实现的： 123Array.prototype.push = function (num ) &#123; this[this.length++]. = num;&#125; push方法就是在数组的最后添加一个值，也就是说length的位置加一个元素，然后把length加1，这样我们也就不难理解为什么有了length属性的对象可以调用数组的push方法了，因为它本身带有一个合法的length属性。 现在再来举个例子： 123456789var obj = &#123; &quot;1&quot; : 2, &quot;2&quot; : 3, &apos;length&apos; : 2, &apos;push&apos; : Array.prototype.push&#125;obj.push(&quot;a&quot;);obj.push(&quot;b&quot;);//&#123;1: 2, 2: &quot;a&quot;, 3: &quot;b&quot;, length: 4, push: ƒ&#125; 这里的length是2，所以一开始push(‘a’)的时候把obj[2]改成了a，因为本身没有2这个下标，然后length变成了3，push(‘b’)之后，obj里没有’3’，就在这里加’3’，然后obj[3]变成了‘b’，，然后把length变成4。 三目运算符形式：判断语句? 若为真，执行，并返回结果：若为假，执行，并返回结果三目运算符其实就是简化版的if(){…}else{}语句 1234567var target = true;if (target) &#123; console.log(&apos;a&apos;);&#125;else &#123; console.log(&apos;b&apos;);&#125;&apos;a&apos; 1target?(target正确就返回这个):（不正确就返回这个） 举个例子： 123var target = &apos;1&apos;;target === &apos;1&apos; ? console.log(&apos;a&apos;) : console.log(&apos;b&apos;);//a 来个比较难的题吧。 12345var text = typeof(typeof(undefined)) == &quot;undefined&quot; ? (NaN == NaN ? 0 : 1) : !!false; &quot;undefined&quot; 0 false &quot;string&quot; 1 false 0 text false try…catchtry {} catch (e) {} finally {}一般是用来检测可能出错的问题的。 我们把可能出错的代码块放入try里面，然后把如果出错会产生的反应代码放到catch里面，finally就是挡catch走完之后再走一下finally代码块，finally的用处不是很大。 catch的参数e一定要写上，系统会自动传进去错误信息，错误信息一共有以下6种： 1.EvalError eval()的使用与定义不一致 2.RangeError 数值越界 3.ReferenceError 非法或不能识别的引用数值 4.SyntaxError 发生语法解析错误 5.TypeError 操作数类型错误 6.URIError URI处理函数使用不当 其中3和4比较常见。 当try里面的代码出错了，try里面出错代码后面的代码就不会执行了，但是在try外面的代码还是正常执行的。 12345678910try&#123; console.log(&apos;a&apos;); console.log(&apos;b&apos;); console.log(c); console.log(&apos;d&apos;);&#125;catch(e) &#123; //e是error的缩写 console.log(e.name); //ReferenceError console.log(e.message); //c is not defined&#125; console.log(&apos;d&apos;); //abd ES5严格模式es5的严格模式是一种全新的es5规范，在这个模式下，有一些es3的不标准的规则就不能使用了。 我们只要在代码的第一行写上“use strict”;这一行字符串就可以进入严格模式了，不会对不兼容严格模式的浏览器产生影响。 严格模式主要有两种用法： 1.全局严格模式 2.局部严格模式 全局模式就是我们在整个js代码的第一行写上字符串，而局部模式就是在函数里面的第一行写上字符串。 这里不推荐使用全局严格模式。 严格模式有什么作用？ 1.当我们的代码进入严格模式之后，就不允许使用with函数，arguments.callee方法，func.caller属性。 2.变量赋值之前必须声明。(不能使用未声明的变量) 3.局部的this使用前必须被赋值，除了全局的this默认指向window，其他的默认都是undefiend。而且在非严格模式下，Person.call(null/undefined)之后，里面的this还是指向window，但是如果是严格模式的话，那么传递null，this就指向null，传递undefiend，this就指向undefiend。 4.拒绝重复属性和参数。不过有一些浏览器的属性名可以重复。 1234567891011function text() &#123; console.log(this);//window&#125;text();&quot;use strict&quot;;function text() &#123; console.log(this);//undefined&#125;text();//局部this必须被赋值,赋值什么就是什么 下面介绍一下with方法是什么。 with () {} 的作用是改变作用域链，它可以把括号里面的执行期上下文或者作用域放在自己的作用域链的最顶端。 123456789101112var obj = &#123; a : &quot;abc&quot;&#125;var a = &quot;global&quot;;function test()&#123; var a = &quot;test&quot;; with(obj)&#123; console.log(a);//abc 这个时候，with直接到了obj取a变量。 &#125;&#125;test();//改变作用域链。直接看到最顶端，提供一个执行上下文。很浪费效率，很浪费性能。 用with之后，我们把obj放在了自身上面，成为了最上面的作用域，这样我们打印a，就会优先调用obj里面的a属性，如果有就用，没有的话再向下找第二层test函数的作用域。 好了，今天的这篇blog就到这里结束了，ECMAScript部分就先到这里结束了，后面的主要内容是DOM，大家和我一起加油吧。下节课为大家讲解JS中的DOM相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js中的数组","slug":"js中的数组","date":"2018-09-26T12:29:37.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/26/js中的数组/","link":"","permalink":"http://moreluckily.com/2018/09/26/js中的数组/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中数组的相关知识。 数组的创建数组的创建基本上只有两种： 1、数组字面量直接创建： 1var arr = [1,2,3]; 2、通过数组构造函数构造数组： 123var arr = new Array(1,2,3);//[1,2,3]var arr = new Array(20);//空数组都是，有20位,表示的是lengthvar arr = new Array(20.1);//会报错 要注意的是，如果我们在构造函数里面只写一个数字new Array(20);这个时候这个数字就不是第一个值是20的意思了，而是我们新创建的这个数组长度是20。 一般情况下都是使用第一种方法直接构建数组字面量。 数组的读写js的数组是弱数据类型的数组，不像其他语言那样严格。不可以溢出读： 12var arr = [1, 2];console.log(arr[3]); //undefined 但是数组是可以溢出写的： 12arr[4] = 4;console.log(arr);//1,2, , ,4 改变数组的方法改变原数组的方法主要有：reverse,sort,push,pop,shift,unshift,splice 1、push（） arr.push( );可以在数组的最后面直接添加数据，可以任意个数，任意类型。 12var arr = [];arr.push(1,2,3,[],&#123;&#125;) 知道了push，我们就可以写一个方法，和它的功能是一样的。 12345Array.prototype.push = function () &#123; for(var i = 0; i &lt; arguments.length; i++)&#123; this[this.length] = arguments[i];//加参数 &#125;&#125; 2、pop（） pop从数组后面剪切一位数据，同时返回这个被删除的数据，没有参数。只能一个一个剪切。 3、shift（） 和pop（）类似，在前面剪切数据，也只能一个一个的剪切。 4、unshift（） 和push（）类似，在前面加数据，也能传多个参数。 5、reverse（）将数组中的数据进行逆转，这个就不多说了。 6、splice（）* splice的英文意思是切片，剪切的意思。 123456789//splice(从第几位开始，剪切多少个长度,在切口处把该值添加进去)；var arr = [1,2,3];arr.splice(1, 1, 100, 200, 300);//[1,100,200,300,3]//剪切的也是一个数组//在1后面加一个0// var arr = [1,2,3];// arr.splice(1,0,0);arr = [1, 0, 2, 3]; 7、sort（）** 这个属性很重要，我们可以用它来进行排序。 1234567var arr = [1,2,4,5,0];arr.sort();//排序[0,1,2,4,5]，升序排列var arr = [1,12,3,4];arr.sort();//[1,12,3,4]//按ASCII码进行排序，不是大小排序 我们可以自定义排序，关注返回值，一旦返回值为负值，那么前面的参数代表的数据就在前面。一旦返回值为正值，那么前面的参数代表的数据就在后面。然后根据返回值，按照上述方法进行排序。 12345678910111213141516171819var arr = [1,12,2,3,4];//自己写一个规则，升序arr.sort(function (a,b) &#123; if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125;&#125;);//arr [1,2,3,4,12] 升序//自己写一个规则，降序 arr.sort(function (a,b)&#123; if(a &lt; b)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;);//arr [12,4,3,2,1]; 降序 这种比较的方式就是冒泡排序，将这些数随机的取2个数去对比(不是随机)，再进行排序,冒泡排序法（重点），冒泡排序法（重点)：我的理解是：先将第一个数和第二个数进行比较，取出较小值，然后将较小值放在第一个数，然后再和后面的比较，最小的放在第一位。然后将第二位的数和后面的每个数比较，取出较小值，一圈一圈的进行对比。…比完之后，就行了。 123456//简化的一种写法：var arr = [1,12,2,3,4];arr.sort(function (a,b) &#123; return a-b;//升序 return b-a;//将序&#125;); 给对象的某个属性进行排序，按ASCII码进行排序： 12345678910111213141516var arr = [ &#123;name:&apos;moreluckb&apos;,age:20&#125;, &#123;name:&apos;moreluckc&apos;,age:10&#125;, &#123;name:&apos;morelucka&apos;,age:30&#125;]//ASCII码进行排序，a&lt;b&lt;c&lt;d...arr.sort(function (a,b) &#123; if(a.name &gt; b.name)&#123; return 1; &#125;else&#123; return -1; &#125;&#125;);//升序排列// &#123;name:&apos;morelucka&apos;,age:30&#125;, &#123;name:&apos;moreluckb&apos;,age:20&#125;, &#123;name:&apos;moreluckc&apos;,age:10&#125; 将正序的数组进行随机打乱排序: 12345var arr = [1,2,3,4,5,6,7];arr.sort(function () &#123; return Math.random() - 0.5;&#125;); //Math.random();//返回随机数,(0,1)//每次比较都是不一样的，而且是乱的 不改变原数组1、concat（） 对两个数组进行连接。并且原数组是不会发生变化的。 1234//arr.concat(): 对两个数组进行连接。var arr = [1,2,3];var arr1 = [4,5,6];var arr2 = arr.concat(arr1); // [1,2,3,4,5,6] 当然我们如果要连接多个数组的话，那么concat里面的数组之间用逗号分隔即可。 12arr3 = [5, 5];arr = arr1.concat(arr2, arr3); 2、toString（） 将数组的每一位转化成字符串并返回。 12var arr = [&#123;&#125;,1,2,true];arr.toString(); // &quot;[object Object],1,2,true&quot; 3、slice（） 12345// arr.slice(第几位开始截，第几位结束)// arr.slice(第几位开始截到最后全部)，负数也可以，从后面开始到最后var arr = [1,2,3];var arr1 = arr.slice(0,1);//[1]var arr2 = arr.slice(1);//[2,3] 4、join（） 将数组按照传进去的符号进行连接，最后转化为字符串返回。默认是逗号连接。 12345//join将数组弄成字符串var arr = [&apos;more&apos;,&apos;&amp;&apos;,&apos;luck&apos;,&apos;&amp;&apos;,&apos;ily&apos;];console.log(arr.join(&quot;&quot;));//more&amp;luck&amp;ilyconsole.log(arr.join(&quot;,&quot;));//more,&amp;,luck,&amp;,ilyvar str = arr.join();//默认连接的是&quot;,&quot; 5、split（） 将字符串按照传进去的符号拆分为字符串形式数组。注意它是字符串的方法。但是它跟join操作是互逆的。 1234var str = &quot;the-first-name&quot;;console.log(str.split(&quot;-&quot;));//[&quot;the&quot;, &quot;first&quot;, &quot;name&quot;]console.log(str.split(&quot;&quot;));//[&quot;t&quot;, &quot;h&quot;, &quot;e&quot;, &quot;-&quot;, &quot;f&quot;, &quot;i&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;-&quot;, &quot;n&quot;, &quot;a&quot;, &quot;m&quot;, &quot;e&quot;]console.log(str.split(&quot;-f&quot;));//[&quot;the&quot;, &quot;irst-name&quot;]//以这个进行截 举个例子：12&apos;百度&apos;,&apos;alibaba&apos;,&apos;tencent&apos;,&apos;toutiao&apos;,&apos;wangyi&apos;把它们连接起来。 第一种方法： 12var str = &quot;&quot;;str += ...； 这种很耗性能，因为它属于栈操作。 第二种方法：12var arr = [&apos;百度&apos;,&apos;alibaba&apos;,&apos;tencent&apos;,&apos;toutiao&apos;,&apos;wangyi&apos;];arr.join(&apos;,&apos;); 堆内存散列操作，节省操作。栈内存，放进去容易，取出来容易，特别恶心。 数组去重问题这里有一个我们必须要掌握的方法：数组去重方法。 把数组中重复的元素去掉。 12345678910111213var arr = [1,1,1,1,2,3,3,2,3,2,undefined,undefined];Array.prototype.unique = function () &#123; var obj = &#123;&#125;, arr = [] for(var i = 0;i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; obj[this[i]] = &apos;abc&apos;; arr.push(this[i]); &#125; &#125; return arr;&#125;console.log(arr.unique());//[1, 2, 3, undefined] 这里我们运用了一个简单的哈希结构。当我们数组中的这个数据出现过一次之后，我们就在obj中将这个元素的值的位置标记成’abc’，后面如果出现相同的属性值，因为这个位置已经是’abc’了，所以就不会添加到新数组里面，从而达到了去重的效果。 ES5的数组方法刚才的那些常用的数组方法都是ES3中定义的，ES5中出现了一些新的方法。 1、forEach（） 这个方法会改变原数组，它让数组中的元素从头到尾遍历一遍，每一个都调用一下我们在forEach里面传递的方法，中间不会停止。 12345var arr = [1, 2, 3, 4];arr.forEach(function () &#123; arr[i] += 1;&#125;)console.log(arr); // 2 3 4 5 2、map（） 这个方法和forEach很像，只不过forEach会改变原数组，而map不会改变原数组，而是返回一个新的数组，它也是让传递一个指定的方法，让数组中的每一个元素都调用一遍这个方法。不过记得map方法最后有返回值。 123456var arr = [1, 2, 3];var test = arr.map(function (x) &#123; return x * x;&#125;);console.log(test); // 1 4 9console.log(arr); // 1 2 3 3、filter（） 这个方法是过滤的作用，它同样不会改变原数组，而是返回一个原数组的子集。我们同样会传递一个方法，每一个元素都会调用一下这个方法，但是只有返回true的元素才会被添加到新数组里面，返回false的不会被添加到新数组里面。 12345var a = [1 ,2 , 3, 4, 5];var b = a.filter(function (x) &#123; return x &gt; 2&#125;);console.log(b); // 3 4 5 同时，filter( )会跳过稀疏数组里面缺少的元素，它的返回数组总是稠密的。 12345var arr = [1,,,,,,3,4];var b = arr.filter(function () &#123; return true;&#125;)console.log(arr); // 1 3 4 4、every（） 和 some（） 这两个方法是数组的逻辑判定，他们对数组应用指定的函数进行判定，返回true或者false。 every是如果每一个元素经过传递的方法的判定之后都返回true，那么最后才返回true。 some是只要有一个元素返回true，那么就返回true。 123var arr = [1 ,2 ,3];console.log(arr.some(function (x) &#123;return x&lt;3;&#125;)); trueconsole.log(arr.every(function (x) &#123;return x&lt;3;&#125;)); false 5、reduce（） 和 reduceRight（） reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，最后变成一个值，reduce是从左向右，reduceRight是从右向左。有两个参数，第一个是方法，第二个是可选参数，即我们最后的这个值的初始值。 当我们没有设置初始值的时候，用数组的第一个元素的值作为初始值。不过当数组为空的时候，不带初始值就会报错。 当我们的数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值的情况下，reduce只是简单地返回那个值，而不会调用函数。 123456var arr = [1, 2, 3];var sum = a.reduce(function (x, y) &#123; return x + y&#125;, 0);// 0 + 1 + 2 + 3 = 6;var temp = [1];var temoOut = a.reduce(function (x, y) &#123;return x x y&#125;); // 1 不会调用这个函数，因为数组只有一个值，除非我们设置一个初始值 前面说的isArray()方法来检测是否是数组，其实是ES5里面的。 最好的检验数组的方法是： Object.prototype.toString.call(arr) === ‘[object Array]’ 这是最可靠的检测是否是数组类型的方法。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的类数组的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"对象的枚举和克隆","slug":"对象的枚举和克隆","date":"2018-09-26T12:29:19.000Z","updated":"2018-10-23T02:43:15.646Z","comments":true,"path":"2018/09/26/对象的枚举和克隆/","link":"","permalink":"http://moreluckily.com/2018/09/26/对象的枚举和克隆/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中克隆的相关知识。 对象的枚举我们知道要枚举一个数组的所有元素，只要用一个for循环从头到尾遍历一遍就可以了。 但是对象并不能用for循环来遍历属性，所以这里我们就要使用for-in操作了。 123456789101112var obj = &#123; name : &quot;abc&quot;, age : 123, sex : &quot;male&quot;&#125;for(var prop in obj) &#123;var prop , prop in obj，也可以这样写 console.log(obj[prop]); // 每一次prop都代表obj中的一个属性名 //obj.prop不行 //obj.prop --&gt;（电脑转化）--&gt;obj[&quot;prop&quot;]&#125; 能把对象中的每一个属性都打印出来。var prop 相当于声明一个变量，in obj，每次循环都会从obj中拿出来一个属性名，obj[prop]就可以得到每一个属性值。注意不能写obj.prop这个形式，因为系统会将它变成obj[‘prop’]属性，所以每次都是undefined。 而且可以把var prop写在外面。 但直接这样写会有错误，看下面的例子： 12345678910Person.prototype.name = &apos;abc&apos;;function Person() &#123; this.age = 123; this.sex = &apos;male&apos;;&#125;var person = new Person();for(var prop in person) &#123; console.log(person[prop]);&#125;//会打印出&quot;abc..... 它会把自己原型链的属性也会打印出来，这有时候就不是我们需要的，我们只需要它自己的属性。 下面我们来介绍三种操作符： 1 、hasOwnProperty 这个操作符的作用是查看当前这个属性是不是对象自身的属性，在原型链上的属性则会被过滤掉。如果是自身的，就返回true，否则返回false。 1234567891011Person.prototype.name = &apos;abc&apos;;function Person() &#123; this.age = 123; this.sex = &apos;male&apos;;&#125;var person = new Person();for(var prop in person) &#123; if(person.hasOwnProperty(prop))&#123; console.log(person[prop]); &#125;&#125; 这样，我们的for-in循环就会只打印自身的属性而不会去打印原型上的属性。 2、in操作符 这个操作符的作用是查看一个属性是不是在这个对象或者它的原型里面。 1234567var obj = &#123; name : &quot;abc&quot;, age : 123&#125;console.log(&apos;name&apos; in obj); //trueconsole.log(&apos;age&apos; in obj); //trueconsole.log(&apos;sex&apos; in obj); //false 3、instanceof 操作符 这个操作符的作用是查看前面的对象是不是后面的构造函数构造出来的，和constructor挺像的。 123456function Person() &#123;&#125;var person = new Person();console.log(person instanceof Person);//true，是不是构造的? 也可以理解为：后面的构造器的原型是否在前面对象的原型链上。 12345678910function grand() &#123;&#125;Person.prototype = new grand();function Person() &#123;&#125;var person = new Person();console.log(person instanceof grand);//true 在这里介绍一下快捷键的使用： 1234567撤销 ctrl+z反撤销 ctrl+y选中：Shift + 左右 ctrl + dTab == ctrl + [Shift+Tab == ctrl + ] 选中一行：Shift+ctrl + 左右 区分数组和对象1、instanceof 操作符 12345[] instanceof Object //truevar obj = &#123;&#125;;obj instanceof Object//true[] instanceof Array //trueobj instanceof Array//false 2、利用constructor属性 1234var arr = [];var obj = &#123;&#125;;arr.constructor --&gt;Arrayobj.constructor --&gt;Object 3、toString方法 12345Object.prototype.toStringArray.prototype.toStringNumber.prototype.toStringBoolean.prototype.toStringString.prototype.toString 123456Array.prototype.toString = function () &#123; return &quot;moreluckily&quot;;&#125;var arr = [1,2,3,4];document.write(arr);//moreluckilyconsole.log(arr);//[1,2,3,4] 为了方便各种类型进行打印，系统在每个原型链上面都重写了toString方法。因为对象，数组都不能直接使用document.write()进行打印，系统会内部进行调用该变量的toString方法。但是我们需要跳过数组自身的toString方法，去使用Object上面的toString。这时候，就要使用call来改变指向。 12345var obj = &#123; &#125;;var arr = [ ];var toStr = Object.prototype.toString;console.log(toStr.call(obj));//[Object Object]console.log(toStr.call(arr));//[Object Array] 封装成方法： 12345678910function isArrayOrObject(target) &#123; var toStr = Object.prototype.toString, arrStr = &apos;[Object Array]&apos;; if(toStr.call(target) === arrStr) &#123; return &apos;this is Array&apos;; &#125;else&#123; return &apos;this is Object&apos;; &#125;&#125; 那能不能写一个函数将所有的类型的数据都判断出来呢？所有的原始值和引用值。 12345number string boolean undefined null //原始值------typeof() ---object function //null注意//typeof(null) -- &gt; object//if(null == null)&#123;return null&#125;object array function Number() Boolean() String() //引用值 封装成方法： 1234567891011121314151617181920function type(target) &#123; var typeStr = typeof(target), toStr = Object.prototype.toString, objStr = &#123; &quot;[object Object]&quot; : &quot;object - object&quot;, &quot;[object Array]&quot; : &quot;array - object&quot;, &quot;[object Number]&quot; : &quot;number - object&quot;, &quot;[object Boolean]&quot; : &quot;boolean - object&quot;, &quot;[object String]&quot; : &quot;string - object&quot; &#125; if(target === null) &#123; return null; &#125;else if(typeStr === &quot;function&quot;) &#123; return &quot;function&quot;; &#125; if(typeStr !== &quot;object&quot;)&#123; return typeStr; &#125;else&#123; return objStr[toStr.call(target)] &#125; 4、Array.isArray( )方法 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false 比较推荐使用前面讲的第三种方法。 克隆在开始介绍克隆的代码和数组的相关知识点之前，我在前面先介绍一下arguments.callee方法和func.caller属性。 1、arguments.callee arguments是每个函数都具有的一个对象，实参列表。它有一个属性叫做callee，指向的是函数的本身。 当我们在一些匿名函数或者立即执行函数里面进行递归调用函数本身的时候，由于这个函数没有名字，我们不能用函数名的方式调用，就可以用arguments.callee来调用。 一般当我们需要通过计算来进行初始化的时候，我们写一个立即执行函数，当这个立即执行函数还需要递归调用自身的时候，我们就是用arguments.callee方法。 12345678var num = (function (n) &#123; if(n == 1)&#123; return 1; &#125; return n * arguments.callee(n-1);&#125;(5))console.log(num); //120//小数点后能计算到15位,再多就不好使了 2、func.caller 1234567function demo() &#123; text();&#125;function text() &#123; console.log(text.caller);&#125;demo(); //demo() &#123;&#125; func.caller：这是函数本身自带的一个属性，可以指出当前函数里运行环境的函数引用，即这个函数是在哪个函数体里面执行的。 会考它俩的区别。 克隆克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。 浅层克隆克隆大致就是我们的源对象里面有什么属性，目标文件就有什么属性，依照这个原理，我们可以写出下面的代码： 12345678var obj = &#123; name : &apos;abc&apos;, age : 123&#125;var obj1 = &#123;&#125;for(var prop in obj)&#123; obj1[prop] = obj[prop];&#125; 将其封装成一个方法： 12345678910var obj = &#123; name : &apos;abc&apos;, age : 123&#125;var obj1 = &#123;&#125;function extend(origin, targrt) &#123; for(var prop in origin)&#123; target[prop] = origin[prop]; &#125;&#125; 浅层的拷贝，对引用值不好使，即当我们有一个属性是引用值（数组或者对象）的时候，按照我们这种克隆方式，只是把这个引用值的指向赋给了新的目标对象，也就是说，我们一旦改变了源对象或者目标对象的引用值属性，另一个也会跟着改变，这一点就是浅层克隆的缺点。 深层克隆为了解决浅层克隆的引用值的问题，我们又需要一种深层克隆。 其实深层克隆的原理也很简单，我们只要不克隆引用值的引用，而是把引用值也当做一个源对象，把里面的值一个一个的克隆进目标对象里面，不就解决了他们二者相同指向的问题了吗。 12345678910111213141516171819function deepClone(origin, target) &#123; //传不传target都行 var target = target || &#123;&#125;, arrStr = &quot;Array - Object&quot;; for(var prop in origin) &#123; if(origin.hasOwnProperty(prop)) &#123; //判断是不是对象 if(typeof(origin[prop] === &quot;object&quot;)) &#123; if(type(target[prop]) == arrStr)&#123; target[prop] = []; &#125;else&#123; target[prop] = &#123;&#125;; &#125; deepClone(origin[prop], target[prop]); &#125;else&#123; target[prop] = origin[prop]; &#125; &#125; &#125; return target;&#125; 这里我们运用了递归调用的方法，当我们检测到源对象里面的这个属性值是引用类型的，那么就在目标对象里面也创建一个引用类型的属性，如果原来是数组就创建数组，是对象就创建对象，然后分别将源对象里面的这个引用值和目标对象里面的引用值分别当做新的源对象和目标对象进行克隆，这样就是克隆的里面每一个值了，而不是把整个引用都克隆过去。 这个时候目标对象和源对象的引用值之间就没有了关系，自己都是独立值，可以进行修改了。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的数组的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js中的this","slug":"js中的this","date":"2018-09-25T15:31:59.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/09/25/js中的this/","link":"","permalink":"http://moreluckily.com/2018/09/25/js中的this/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中this的相关知识。 命名空间由于我们的一个项目是很多人开发的，每个人都有一套自己的变量，为了防止人和人之间变量的互相干扰，我们经常把自己的变量都放到相对应的模块里面，模块和模块之间是没有关系的，这样就算变量名相同也不会互相干扰。我们经常用对象来实现这种模块的作用。 12345678910111213141516171819202122var org = &#123; department1: &#123; a : &#123; &#125;, b : &#123; &#125; &#125;, department2: &#123; wang : &#123; name : &quot;abc&quot;, sge : 123 &#125;, fa : &#123; &#125; &#125;&#125;var wang = org.department2.wang;wang.name;wang.age; 以上的方法是旧方法来解决的，现在多数使用闭包来进行解决，每个变量都在自己的域中，别人访问不了。 123456789101112var add = (function () &#123; var count1 = 0; var count1 = 0; function myAdd(num1, num2)&#123; count1 = num1; count2 = num2; console.log(count1 + count2); &#125; return function (num1, num2) &#123; myAdd(num1, num2) &#125;;&#125;()) 这种解决方式，也是类似于利用私有化变量来解决命名冲突，只有在与自己产生闭包的变量才能访问到。不污染全局变量。 链式调用有时候，我们需要像jQuery那样调用完一个方法之后连续的调用下一个方法，这时候，我们需要使用this了。 123456789101112131415var deng = &#123; smoke : function () &#123; console.log(&quot;smoke, cool!!!&quot;); return this; &#125;, firehair : function () &#123; console.log(&quot;fire&quot;); return this; &#125;, drink : function () &#123; console.log(&quot;drink&quot;); return this; &#125;&#125;//deng.drink().smoke(); 这样写我们就可以实现链式调用了，因为当函数一调用执行完就会返回自己，如果没有返回this，那么以上代码就会报错。 this指向1、函数预编译过程 this —&gt; window 12345678910111213function text () &#123; console.log(this);&#125;text();//AO = &#123;arguments : [], this : window&#125;//this -- &gt;windowfunction text () &#123; function demo() &#123; console.log(this); &#125; demo();&#125;text(); 1234567function Person() &#123; console.log(this);&#125;//AO -- &#123;// this : Object.create(Person.prototype);//就是 window// &#125;new Person(); 2、局作用域里面 this–&gt;window 123GO = &#123; this --&gt; wondow&#125; 3、call和apply，改变this指向，指向的是括号里面所传的对象； 4、obj.func()； // func() 里面的this指向的是obj，意思就是，谁调用的方法就是指向谁。 12345678var obj = &#123; age : 123; smoke : function () &#123; console.log(this); &#125;&#125;obj.smoke();this --&gt; obj&#123;&#125; 接下来举一些例子来巩固一下吧。 12345678910var obj = &#123; age : 123, smoke : function () &#123; console.log(this); &#125;&#125;var smoke1 = obj.smoke;smoke1();指向 --&gt; window没调用，就是window 再来一个例子吧。 123456789101112131415161718192021222324252627var name = &quot;222&quot;;var a = &#123; name : &quot;111&quot;, say : function () &#123; console.log(this.name); &#125;&#125;var fun = a.say;fun(); //222a.say();//111var b = &#123; name : &quot;333&quot;, say : function (fun) &#123; fun(); &#125; &#125;b.say(a.say);//222//(a.say) , a.say的函数体//首先b.say(), this --&gt; b（b这个函数体） //如果打印this.name的话就是333//fun --&gt; say : function () &#123;// console.log(this.name);// &#125;// fun();//指向的就是window的，就是222b.say = a.say;//将b.say换成了a.sayb.say();//333 再来一个题目吧。 12345678910111213var name = &apos;window&apos;; //一般都是用&apos;&apos;,php不认识 &quot;&quot;var obj = &#123; name : &apos;obj&apos;, child : &#123; name : &apos;child&apos;, getName : function () &#123; return this.name; &#125; &#125;&#125;console.log(obj.child.getName());//childvar getName = obj.child.getName;console.log(getName());//window 上面的题目比较简单，来一个比较难的题目吧。 12345678910function fun(n, o) &#123; console.log(o); return &#123; fun : function(m) &#123; return fun(m, n); &#125; &#125;&#125;var x = fun(0);x.fun(1); 来分析一下： 12345678910111213x = &#123; fun : function (m) &#123; return fun(m, n); &#125;&#125;x.fun(1);//x = &#123; fun : function (m) &#123; return fun(1, 0); //上哪里找fun?上第一行找 //打印:undefined , 0 &#125; &#125; 1234567891011121314var y = fun(0).fun(1).fun(2);//fun(0) --&gt; &#123; fun : function (m) &#123; return fun(m, 0); &#125;&#125;//1.undefined//2.0//3.1fun(1) --&gt; &#123; fun : function (1) &#123; return fun(1, 0); &#125;&#125; 12345var z = fun(0).fun(1);//undefined//0z.fun(2);//1z.fun(3);//1 属性的表示方法我们经常使用这样的方法来表示属性的引用：obj.prop，其实在系统的内部obj.prop (系统内部会转变)--&gt; obj[&#39;prop&#39;] 有些时候使用第一种表示方法是不好使的，举个例子： 12345678910function getProp(prop) &#123; var obj = &#123; age : 123, sex : &quot;male&quot;, height : 175 &#125; // console.log(obj.prop); 不行 console.log(obj[prop])//这样才行&#125;getProp(&apos;age&apos;); 当我们要通过变量传参的形式来调用属性的时候，第一种方式会报错，第二种方法才能正常使用。 123456789function getProp(num) &#123; var obj = &#123; friend1 : &apos;a&apos;, friend2 : &apos;b&apos; &#125; console.log(obj[&apos;friend&apos; + num]);&#125;getProp(1);//agetProp(1);//b 通过中括号的形式调用属性，还能进行属性的拼接。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的克隆相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的继承","slug":"js的继承","date":"2018-09-25T12:48:16.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/25/js的继承/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的继承/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中继承的相关知识。 继承发展史首先复习一下call 1234567var obj = &#123;&#125;;function text(name, age) &#123; this.name = name; this.age = age;&#125;text.call(obj, &quot;abc&quot;, 123);//obj里有name和age 继承发展史:第一阶段：传统形式，其实就是原型链继承，它会过多的继承了没用的属性。 12345678910Grand.prototype.lastName = &quot;abc&quot;;function Grand() &#123;&#125;var grand = new Grand();Foo.prototype = grand;function Foo() &#123;&#125;var foo = new Foo();son.prototype = son;function son() &#123;&#125;var son1 = new son(); //过多的继承了没用的属性 第二阶段：借用构造函数。 12345678910function Factory(name, age) &#123; this.name = name; this.age = age;&#125;function Person(name, age) &#123; //var this = Object.create(Person.prototype); Factory.call(this, name, age); //return this;&#125;var person = new Person(&quot;age&quot;,123) 这种方式就是利用了call和apply可以改变this指向的特点，通过构造函数来间接的构造子对象。 但是这种方式有两个缺点： 1.严格来说，这种方式不属于继承，也访问不了原型的原型。 2.每次构造一个对象都要走两个构造函数，效率很低。 第三阶段：共享原型。 1234567891011121314Person.prototype.lastName = &quot;wang&quot;;function Person(name) &#123; this.name = name;&#125;var person = new Person(&quot;abc&quot;);PersonAnother.prototype = Person.prototype；PersonAnother.prototype.age = 11;function PersonAnother() &#123;&#125;var personAnother = new PersonAnother();personAnother.lastName=&quot;wang&quot;;var operson = new Person(&quot;abc&quot;);//当我们给personAnother的原型上添加属性的时候，发现operson的原型也会发生同样的变化，这就是我们不想要的，于是就产生了第四种方式了 第四阶段：圣杯模式。 为了解决第三种方法产生的bug，我们需要添加一个中间层，产生一个过渡。 123456789Person.prototype.lastName = &quot;wang&quot;;function Person() &#123; &#125;F.prototype = Person.prototypefunction F() &#123;&#125;var f = new F();PersonAnother.prototype = f;PersonAnother.prototype.age = 123;function PersonAnother() &#123; &#125;new PersonAnother(); 第三种情况出现的bug，是因为PersonAnother和Person原型指向是同一个房间，所以当房间的内容改变的时候他们就会同时发生改变，这时候我们加上一个中间层，F函数，里面就是让它的原型指向Person的原型，然后，PersonAnother的原型继承自F函数的原型，就相当于也继承了Person的原型，而且实现了PersonAnother改变的时候，Person的原型不发生改变。 但是，这还是有一点不足，我们知道constructor属性指向的是构造这个对象的函数，但是这时候PersonAnother的constructor指向的是Person，因为F函数里面没有constructor属性，于是便会随着原型链网上找，于是就找到了Person里面，这时候我们需要手动地给PersonAnother添加一个constructor属性。 还有就是，在正常开发中，我们需要一个叫超类（Uber）的东西，同时我们为了保存一下它的父类，也用一个uber来记录一下父类。于是，圣杯模式的最终形式就是这样的： 12345678910function inherit(Origin, Target) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; // 超类uber Target.prototype.uber = Origin.prototype;&#125;PersonAnother.__proto__ : Person&#123;uber:Object, sge: 123&#125;PersonAnother.__proto__.uber : Object&#123;lastName: &quot;wang&quot;&#125; 不过，这种写法虽然成功了，但是还是有一点点小瑕疵，这里面的F函数只是起到一个搭桥的功能，并没有什么实质性的作用，那么我们能不能舍弃掉这个东西呢？ 真的舍弃掉是不可能的，但是我们可以通过一定的方法来规避这个函数，让他不出现在我们的继承函数中。 圣杯模式高级写法我们利用雅虎的YUI3库进行一个高级的圣杯模式写法，利用的是闭包的私有化变量。 123456789var inherit = (function () &#123; var F = function () &#123;&#125;; return function(Origin, Targe) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype; &#125;&#125;()) 这样通过立即执行函数和闭包，我们既可以使用F函数，又可以不让它出现在我们的真正的继承函数中（即返回的那个函数）。 当然我们也可以通过一张图来概括圣杯模式。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的this相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的原型","slug":"js的原型","date":"2018-09-25T06:02:56.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/25/js的原型/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的原型/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中原型的相关知识。 原型**先说一下原型的定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象，也可以对它进行增删改查，举2个例子： 12345678910Person.prototype.name = &quot;wang&quot;;Person.prototype.age = 20;Person.Prototype.sex = &quot;male&quot;;function Person() &#123; &#125;var person1 = new Person();var person2 = new Person();person1.name //&quot;wang&quot;person2.age // 20person1.sex //maleperson1 //Person --&gt; __proto__:Object (原型) 虽然person1表面上什么都没有，但是因为它是由Person构造出来的，所以他继承了Person的原型，所以就有其他的看不见的属性想name，age，sex。但是我们要注意的是，person1上面的属性是只读的，不能修改它原型上的属性，也不能够删除。例如： 1234person1.name = &quot;moreluckily&quot;;person1.name // &quot;wang&quot;delete person1.name;person1.name //&quot;wang&quot; 对于数组，我们是可以利用数组自身的一些方法进行修改，例如： 12345Person.prototype.card = [100,100,100];function Person() &#123; &#125;var person1 = new Person();person1.card.push(100);console.log(person1.card);//[100,100,100,100] 提取共有属性利用原型特点和概念，可以提取共有属性。举个例子： 1234567function Car(color)&#123; this.height = 1400; this.width =1900; this.color = color;&#125;var car1 = new Car(&quot;green&quot;);var car2 = new Car(&quot;red&quot;); 这个例子可以看到，car1和car2只是color不一样，但是，height和width都是重复执行的，换句话说就是耦合的，这时候我们就需要对其进行解耦，这时候，原型就派上用场了。 1234567Car.prototype.height = 1400;Car.prototype.width = 1900;function Car(color)&#123; this.color = color;&#125;var car1 = new Car(&quot;green&quot;);var car2 = new Car(&quot;red&quot;); 因为原型也是一个对象，所以我们更简便的去写： 1234Car.prototype = &#123; height = 1400, width = 1900&#125;//更简便了 但是没有，constructor 构造器这个属性，不提倡使用自己写的。总结一下就是，原型就是一个对象，每一个函数有一个原型，而且每一个函数都只有一个原型。 原型链简介构造函数创建对象的时候，里面有一个__proto__ //由于在文本中不能输入__proto__,所以以后就用proto代替它的属性，它指向的是该函数的原型，当访问变量的时候，如果自身没有该属性，它就会寻找proto上面指向的该函数的原型上去寻找，如果这个原型上面也没有，会继续沿着原型上面的proto属性继续寻找，这条链式结构，就称之为原型链，每条原型链的终点就是Object()。如果，在原型链终点上面也没有找到查询的变量就会报undefined。 constructor 构造器构造函数创建对象的时候，会有一个constructor属性，指向的是构造出该对象的函数。 当我们自定义的方法设定原型的时候，constructor属性是没有的。这就是与原生原型的区别，这时候我们还需要手动添加constructor属性，这样就完美了。接着上面的例子： 1234567891011没有设定constructor属性的时候：car1.constructor // function Object() &#123;[native code]&#125;//设定了constructor属性的时候：constructor 就是指向CarCar.prototype = &#123;height : 1400,width : 4950,constructor : Car&#125;function (color) &#123;this.color = color;&#125; 原型链*对象如何查看原型：前面我们提到了构造函数可以通过.prototype的方法来查看构造函数的原型，那么我们怎么查看对象的原型呢？ 我们前面提到过用构造函数构造对象的时候，会隐式创建一个this对象，这个this对象里面有一个默认的属性叫做proto属性，这个属性的值就是指向的这个对象的原型。 1234var this = &#123; // xxx __proto__ : Person.prototype; &#125; 原型链：有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。举个例子：1234567891011121314151617181920212223GrandFather.prototype.lastName = &apos;DDD&apos;;function GrandFather() &#123; //this = &#123;__proto__: GrandFather.prototype&#125; &#125;var grand = new GrandFather();Father.prototype = grand;function Father () &#123; //this = &#123;__proto__: Father.prototype&#125; this.forture = &#123; house : 2, money : 99999 &#125;&#125;var father = new Father();Son.prototype = father;function Son () &#123; //this = &#123;__proto__: Son.prototype&#125; this.name = &quot;fff&quot;; this.age = 10;&#125;var son = new Son();var oSon = son;console.log(oSon.lastName); //D Father创造出来的每一个对象都继承自grand这个对象，Son的每一个对象都继承自father这个由Father创造出来的对象，这样son就可以继承上面Foo和Gra的所有属性。 当我们查找oSon上的属性的时候，如果son自身有属性，那么就打印出来，如果没有，就向上查找原型father，如果father上面还有这个属性，那么继续向上查找grand，如果有就输出，如果没有就返回undefined。 那我们可以画一个图来进行更好的去理解它： Object.create()创建对象的第四种方法，使用Object.create()方法。 这样可以得到一个没有原型的对象。 Object.create(prototype) 这种方法创建对象，传进去的必须是原型，然后不能是原始值，否则会报错。 特殊情况，如果填null，是不会报错，但是里面的东西就没有原形了，其他增删改查都是正常进行。 123var obj = &#123;&#125;;document.write(obj);document.write(obj.toString());//其实是调用这个 如果没有原型，有一些问题就会出现。例如，当我们使用document.write的时候，对象是不能直接打印出来的，只能隐式地调用toString方法，然后再进行操作，如果没有原型，那么就没有toString方法，那么使用document.write的时候就会报错。 另外，只有使用Object.create的时候才能把null传进去，其他情况手动的将prototype设定为null都是不好使的。 1var obj = Object.create(null);//没原型 面试题：所有对象的终端指向object.prototype是错误的，绝大多数才是对的，因为null没有原型。 this的一些问题前面我们知道函数内部的this默认的指向是全局对象window，那么我们有什么办法可以改变this的指向吗？ 我们就可以用call/apply来改变this指向。 call/apply 作用：改变this指向。 区别：后面传的参数形式不同。 我们现在写一个函数： 123456function Person() &#123; this.name = &quot;abc&quot;; this.age = 123;&#125;Person();//window//window.name = &apos;abc&apos;; 这个时候this指向window，name属性自然也就是window上面的全局属性。 用call/apply来改变this的指向： 12345678function Person(name, age) &#123; this.name = &quot;abc&quot;; this.age = 123;&#125;var obj = &#123;&#125;;Person.call(obj, &quot;bcd&quot;, 18);//Person.call(obj,参数1，参数2)Person.apply(obj, [&quot;bcd&quot;, 18]);//Person.apply(obj,[参数一，参数二])//obj : &#123;name: &quot;bcd&quot;, age: 123&#125; 我们可以看到，当使用了call方法之后，Person函数内部的this就指向了我们传递的这个对象。现在这个函数就可以为obj来赋属性值了。 apply和call基本没有区别，唯一的区别是call后面的参数是一个一个传的，而apply后面的参数是放进一个数组里面然后传进去的。 在实际开发中，更多的是使用apply，因为我们可以利用arguments来进行不定参操作。 123456789function Person(name, age) &#123; this.name = &quot;abc&quot;; this.age = 123;&#125;var obj = &#123;&#125;;function text() &#123; Person.apply(obj, arguments)//apply用的比较多 &#125;text(&quot;abc&quot;, 123); 另外再多人开发中，当我们需要使用之前已经写好的一个十分复杂的代码块的时候，复制代码十分麻烦，因为通常变量都是涉及到上下文中的各个变量。我们不需要重新写一遍，直接使用apply，将this指向改变就可以了。就是利用其他的方法来构建自己的方法，最后进行个性化的定制即可。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中继承的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的对象","slug":"js的对象","date":"2018-09-25T05:29:35.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/25/js的对象/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的对象/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中对象的相关知识。 复习一下首先来复习一下前几节课的内容，概念啥的就不多说什么了，来做几道题吧。 12(window.foo || (window.foo = &quot;bar&quot;));//先执行后面的，||直接返回document.write(window.foo); //bar 12345678var foo = &#123;n : 1&#125;;var bar = foo; //是foo的地址foo.x = foo = &#123;n : 2&#125;; //从右向左解析//相当于 bar.x = foo = &#123;n : 2&#125;,和foo没关系//视觉效果，要忽略视觉效果console.log(foo.x); //undefinedbar.x = foo = &#123;n : 2&#125;;console.log(bar.x); //&#123;n : 2&#125; 对象（object）对象（onject）是一个引用值，它可以有方法，属性，属性和方法之间要用逗号隔开，不能用分号隔开，否则会报错。举个例子： 1234567891011121314151617181920var mrWang = &#123; firstName : &quot;moreluckily&quot;, lastName : &quot;wang&quot;, age : 20, sex : &quot;male&quot;, sister : &#123; name : &quot;moreluck&quot;, age : 25 &#125;, brother : &#123; name : &quot;morelucky&quot;, age : 22 &#125;, study : function () &#123; console.log(&quot;I am studying, cool!&quot;); &#125;, sing : function () &#123; console.log(&quot;I am singing, good!&quot;); &#125;&#125; 对象的属性的增、删、改、查1234mrWang.borther2 = &quot;moreluclier&quot;;//增delete mrWang.borther2;//删除,只能删除对象的属性mrWang.age = 21; //改console.log(mrWang.age = 21);//查 对象的创建方法对象字面量格式1var obj = &#123;&#125; //PlainObject 对象字面量/对象直接量 构造函数创建对象12var obj = new Object ();obj.name = &quot;moreluckily&quot;; 这种方法太麻烦了，属性要一个个的加进去，能写字面量，就不写这种方法。 自定义构造函数**自定义构造函数，使用大驼峰的写法，即：1function TheFirstName() &#123;&#125; 自定义的构造函数方法可以自己定义方法，用于批量生产对象。举个例子：1234567891011function Car() &#123; this.name = &quot;Maserati&quot; this.height = 1400; this.width = 2000; this.run = function () &#123; this.health --; &#125;&#125;var car = new Car(); var car1 = new Car();//不同的对象car.color = red;//car的属性改变了，car1的属性不能改变 上面的例子写的有些麻烦，我们可以对其进行一些优化，用传参数的方式来直接写。 123456789101112function Car(color) &#123; this.name = &quot;Maserati&quot; this.height = 1400; this.width = 2000; this.health = 100; this.run = function () &#123; this.health --; &#125; this.color = color;&#125;var car = new Car(&quot;red&quot;); var car1 = new Car(&quot;green&quot;);//个性化 构造函数的内部原理1.在函数体最前面隐式的加上this = {};2.执行 this.xxx = xxx;3.隐式的返回this 123456789101112131415function Person(name, age, sex) &#123; //var this = &#123;&#125;; //AO = &#123; // this : &#123; // this.name = name; // this.age = age; // this.sex = sex; // &#125; &#125; this.name = name; this.age = age; this.sex = sex; //return this;&#125;var person = new Person(&quot;moreluckily&quot;, 123, &quot;male&quot;) 在函数person函数定义的时候，首先，会隐式地在执行上下文中添加一个空对象名为this，然后，执行每句语句，相当于往this里面添加对象的属性和方法。最后，所有语句读执行完毕的时候，隐式地把this对象返回出去。 如果构造函数没有使用new来进行引用的时候，那么，this就是指向的window，例如:1var person1 = Person();//直接这样写 那么，这里的name指向的就是window，所有的带this的属性指向的都是window。当我们查询person.name的时候返回的是undefined，其他的属性的都是undefined。可以看出，没有利用new来进行引用的构造函数，那么里面的this指向的就是window。window.name等属性是undefined。 自己写一个和构造函数一样的函数封装我们已经知道了构造函数的相关原理，我们就可以利用它的原理自己来写一个和构造函数一样的函数封装。 123456789function Peason(name, age, sex) &#123; var that = &#123;&#125;; this.name = name; this.age = sge; this.sex = sex; return that; &#125; var person = new Person(&quot;moreluckily&quot;, 123, &quot;male&quot;)//通过new,return之后的东西一定是一个对象 首先我们手动的创建一个空对象命名为that，然后给that对象定义方法和属性，最后显式地return that对象，但是这个人工的构造函数，效率等各方面都没有原生的好。大家还是不要用自己写的构造函数。 在这里还要注意的一点， return 12; return “2”; return true; return { }，我们可以发现，前三个都是原来由构造函数生产出来的对象，但是对于第四个，就变成一个空对象了，意思就是，如果我们return的如果是原始值，那么对结构没影响，但是如果返回的是一个引用值，那么结果就是return出来的那个引用值。 闭包的作用：私有化变量在之前说闭包的时候，没有讲到构造函数，其实闭包还有一个作用，就是私有化变量。来看一下代码： 1234567891011121314151617181920212223function Deng() &#123; var prepareWife = &quot;moreluck&quot; var obj = &#123; name : &quot;moreluckily&quot;, age : 20, sex : &quot;male&quot;, wife : &quot;morelucky&quot;, divorce : function () &#123; delete this.wife; &#125;, getMarried : function () &#123; this.wife = prepareWife; &#125;, changePrepare : function (someone) &#123; prepareWife = someone; &#125;, sayMyWife : function () &#123; return this.wife; &#125; &#125; return obj;&#125;var deng = Deng(); 我们对其进行操作： 1234567deng.sayMyWife() //&quot;morelucky&quot;deng.divouce() //undefined (没有返回值）deng.sayWife() //已经删除,undefineddeng.changePrepare(&apos;xiaoxiaozhang&apos;) //undefined (函数没有返回值）deng.getMarried() //undefineddeng.sayMyWife() //&quot;xiaoxiaozhang&quot;deng.prepareWife //undefined 我们手动地查询prepareWife的时候，发现是undefined，因为这个是函数里面的变量，不在全局作用域里，所以我们访问不了，但是，一系列的操作都是围绕prepareWife来进行的，它们都可以正常访问这个变量，所以，像这种只能通过与这个变量产生闭包的方法，属性，才能给对那个变量进行访问，所以，我们就称之为，私有化变量，我们可以通过定制接口等各种方法，来对变量的安全程度进行设置。 包装类*首先我们要清楚知道的一点是：原始值是没有属性和方法的。 前面讲过原始值有：Number,String,Boolean,undefined,null。 引用值有：array, object, function。 那么你硬要给原始值加上属性和方法，那么系统就会把它转化为原始值对应的对象的形式，称之为包装，那么该原始值的对象形式称之为包装类。 我们可以通过new来将原始值变成其对象形式。 123Number --&gt; new Number() --&gt;数字的对象形式String --&gt; new String() --&gt;字符串的对象形式Boolean --&gt; new Boolean() --&gt;布尔的对象形式 那当我们把一个原始值添加属性的时候，会发生什么事情呢？ JS引擎会隐式地将原始值转化为对应的对象类型，然后，进行delete操作，意思就是，当我们给一个原始值添加属性的时候，引擎将会马上删除该原始值的对象形式。举个例子： 12345var num = 123;//new Number(num).abc = &quot;a&quot;; --&gt;deletenum.abc = &quot;a&quot;;//新的 new Number(num).abcconsole.log(num.abc);//undefined 我们知道引用值数组有一个属性length，它可以查看数组的长度，那么字符串也是有长度的，但是它不能像数组那样使用length对字符串进行截断处理，就是因为当对string进行设置length之后，之后会把马上销毁掉不进行任何地保留或者处理。也就是字符串的对象形式。 12345var str = &quot;abcd&quot;;//new String(str).length = 2; --&gt;deletestr.length = 2;// //新的 new String(str).lengthconsole.log(str.length);//4 123var arr = [1,2,3,4];arr.length = 2;console.log(arr); //[1,2] 包装类的一些例子*我们来看一下和包装类相关的一些例子： 12345678910111213//题目1：//运行text()和new text()的结果分别是什么？var a = 5;function text() &#123; a = 0; alert(a);//会产生一个：var this = &#123;&#125; alert(this.a); var a; alert(a);&#125;text();// 0 5 0new text();// 0 undefined 0 像第一个text( );，this.a就是window.a，也就是说第二个出来的是5。其他的两个0是AO里的，在这里就不多说了。 像第二个new text( );，在内部会产生一个var this = {},其内部没有东西，所以没有任何东西，出现的就是undefined。 再来一个例子： 1234567var str = &quot;abc&quot;;str += 1;var text = typeof(str);if(text.length == 6)&#123; text.sign = &quot;typeof返回的可能是string&quot;;&#125;document.write(text.sign);//undefined 这题的陷阱很深，最后大家可能都认为能够打印出来”typeof的返回结果可能是String”，但是，大家可能忘了，包装类，当定义完之后，就会被马上销毁，所以最后打印结果是undefined。 再举一个例子： 12345678910111213141516function Person(name, age, sex) &#123; var a = 0; this.name = name; this.age = age; this.sex = sex; function sss() &#123; a ++; document.write(a); &#125; this.say = sss; //上面的函数体&#125;var oPerson = new Person();oPerson.say();//1oPerson.say();//2var oPerson1 = new Person();oPerson1.say();//1 这就是闭包的作用：私有化变量。 再看一下接下里的这个题目： 1234567var foo = &#123;n : 1&#125;;var bar = foo;foo.x = foo = &#123;n : 2&#125;;console.log(foo.x);//undefinedbar.x = foo = &#123;n : 2&#125;;console.log(bar.x);// &#123;n : 2&#125;console.log(bar);//&#123;n : 1,x:&#123;n : 2&#125;&#125; 上次被这个问题困扰了很久，现在是不是明白了。 还有一点要情调的是： undefined == null //true //true 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中原型的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的闭包","slug":"js的闭包","date":"2018-09-24T17:00:46.000Z","updated":"2018-10-23T02:43:15.630Z","comments":true,"path":"2018/09/25/js的闭包/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的闭包/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中闭包的相关知识。 闭包初探先来举个例子吧，让我们看看什么是闭包。 1234567891011121314function a()&#123; //AO = &#123; aaa:12 , b : function ()&#123;&#125;&#125; function b()&#123; //AO = &#123; bbb: 234&#125; var bbb = 234; console.log(aaa);//12 &#125; var aaa = 12; return b; &#125; a(); var glob = 100; var demo = a(); demo(); 函数里面还套了另一个函数，看起来特别难的样子。让我们先来分析一下。当b执行完之后，就相当于a也执行完了，这样a都会把自己的执行上下文销毁，但是这时候，因为return b，把b保存给了外部的变量demo，这时候当demo执行的时候，可以正常打印出12，具体原因就是，虽然a把自己的执行期上下文删掉，但是这时候b仍然保存有a的劳动成果，当它返回给外部变量的时候，就相当于外部变量也有这个执行期上下文，所以就能够访问到aaa了。这就是我们经常听说的内存泄漏，就是因为原有的作用域链不释放所导致的。具体来看下图。 当a执行完成之后，a scope chain [0] 中的指向将会被删除，但是因为b的指向仍然存在，所以仍能访问到所需要的变量。 举个例子吧。12345678910function a() &#123; var aaa = 123; function b() &#123; console.log(++aaa); &#125; return b;&#125;var demo = a();demo(); //124demo(); //125 当a函数定义的时候，产生一个执行上下文，里面有一个aaa，和一个函数b，当b定义的时候，已经含有a的劳动成果，意思就是它已经有a的执行上下文，并且在b执行的时候，产生它自己的执行上下文，最后当a函数执行完之后，把函数b返回到了全局作用域，虽然a执行完，并且销毁了它自己的执行上下文，但是因为其内部b函数的存在，仍然有a的全部执行上下文，所以，仍然可以通过demo来访问function a( ) { }里面的aaa变量。 闭包的作用实现公有变量实现公有变量的最经典的例子就是实现函数累加器的功能。举个例子： 1234567891011121314function add() &#123; var num = 0; function demo() &#123; num++; console.log(num); &#125; return demo;&#125;var add1 = add();add1();//1add1();//2add1();//3add1();//4add1();//5 我们可以利用闭包产生一个公有变量，对于上述例子，公有变量就是num。add函数，把demo函数返回到了外部，demo函数，仍然有add函数的执行上下文，所有每次执行test的时候，就相当于执行demo函数，并且每次访问的num都是同一个num变量，这样，我们就称num就是公有变量，通过这样的操作方式，就可以利用闭包产生一个累加器了。 做缓存机构首先来看一下下面的代码，我们来分析一下这段代码。 1234567891011121314151617function text() &#123; var num = 0; function a() &#123; console.log(++num); &#125; function b() &#123; console.log(--num); &#125; return [a,b];&#125;var arr = text();arr[0]();//1arr[1]();//0arr[0]();//1arr[0]();//2arr[0]();//3arr[1]();//2 这段代码把a函数和b函数都返回到了外部，这样a函数和b函数都与num产生了一个闭包，并且a和b执行的都是同一个变量，当a改变num的时候，b的num也会发生改变，同理，b操作了num，a的num也会发生改变，因为它们指向的num是同一个num，这样，就相当于一个缓存，每次都是操作之前操作过的同一个变量。 闭包还有一个作用就是可以实现封装，属性私有化。但我们还没有讲到对象，所以先放一下，之后再将这个功能。 立即执行函数立即执行函数的定义：此类函数没有声明，在一次执行过后即释放。适合做初始化工作。 首先来看一下它的写法和功能： 12345(function () &#123; &#125;)() // 写法(function () &#123; //在这里直接执行//执行完就被销毁了 &#125;)() 当然了，立即执行函数也可以传参数，例如： 1234var ret = (function (a,b)&#123; console.log(a + b); return [a,b]; &#125;(a,b)&#125; 立即执行函数的一些基本知识首先我们需要知道它一些基本知识：1、只有表达式才能被执行，2、表达式被执行了就会被销毁，3、函数声明不能被执行 12function test() &#123; &#125; // 函数声明，不是表达式var test = function () &#123;&#125; // 函数表达式 但我们可以利用一些简单的方法将函数声明转化为表达式 1+function test()&#123; &#125; //+号运算符，可以将函数声明转会表达式，这样就可以执行了。那-号也就肯定可以咯。 1! function test() &#123;&#125; //可以在函数声明前加一个!号，也是可以将声明转化为表达式。 1(function () &#123; &#125;) //()也能 但我们写立即执行函数的时候，需要遵循W3C标准，它规定的正确的写法就是下面这样的： 123(function () &#123;console.log(&apos;b&apos;);&#125;()) 举一个比较特殊的例子： 123function test(a,b)&#123; console.log(a,b);&#125;(1, 2); 这种写法是不会报错的，因为它传了参数，这样系统将会解析为这样的：123456function test()&#123; console.log(a,b); &#125; (1,2) 这样，系统认为它们是相互独立的两个部分，不会报错，这时JS引擎的容错机制。 1var text = (1,2); // text=2 是不是很神奇，和C，C++什么的区别的比较大啊。 利用立即执行函数解决闭包的问题我们首先来看一个经典的闭包产生的问题： 12345678910111213function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i ++)&#123; arr[i] = function () &#123; document.write(i + &quot;, &quot;); &#125; &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt; 10; j++)&#123; demo[j]();&#125;//打印10,10,10,10,10... ,10个10 这段代码最后打印出的是10个10，我们的目的是要让它打印出0到9，显然跟我们的目标有差距。为什么呢？ 首先解析一下为什么10个10，首先我们需要知道，function打印出的i并不是马上变限的，意思是，function要等到执行的时候才会去寻找i的值，这时候i的值已经是10了，因为i必须要等于10的时候才会停止循环。 其实循环可以这样理解： 1function () &#123; console.log(i),function () &#123; console.log(i),function () &#123; console.log(i),function () &#123; console.log(i),... 当数组执行完循环之后，i才是真正的打印结果，这时候，i就是10； 另外，打出10个10，就是我们的每一个i，用的都是同一个执行上下文的i，这时候我们需要利用立即执行函数来解决这个问题。 12345678910111213141516function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i ++)&#123; (function (k) &#123; //特别重要 // 相当于i=k=0.... arr[k] = function () &#123; console.log(k); &#125; &#125;(i)) //实参 &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt; 10; j++)&#123; demo[j]();&#125;//0~9 利用立即执行函数，每次访问的i都是不一样的值，这样就可以打印出0-9了。 再来看一个例子： 123456789101112131415161718192021222324a = 100;function demo(e) &#123; function e() &#123;&#125; arguments[0] = 2; document.write(e); //2 if(a)&#123; //if里不能有函数，有的话不报错，但不会在预编译的时候提出来 var b = 123;//if里有声明，预编译使可以提到前面 function c()&#123; //每个人都能做出来 &#125; &#125; var c; a = 10; var a; document.write(b); //undefined f = 123; //暗示全局变量。 //在GO上加f:123 document.write(c); //undefined document.write(a); //10&#125;var a;demo(1);document.write(a);//100document.write(f);//123 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中对象的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的预编译","slug":"js的预编译","date":"2018-09-24T16:30:32.000Z","updated":"2018-10-23T02:43:15.630Z","comments":true,"path":"2018/09/25/js的预编译/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的预编译/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中函数预编译的相关知识。 js运行三部曲首先一个JS程序能运行起来，需要经历三个步骤：第一步，语法分析，先通篇看一遍，看有没有低级语法错误，例如：有没有中文符号，多加了括号什么的。第二步，预编译。第三步，开始执行。 暗示全局变量imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。举一些例子：12a = 1;//a为暗示全局变量var a = b = 1;//b为暗示全局变量 任何地方的变量如果没有声明就赋值，就是全局变量。注意是！！任意的地方，这意味着如果在函数内部没用声明变量，就直接赋值，这个变量在全局都是被访问到。更进一步的意思就是，无论这个变量是否在局部作用域，它都能在全局作用域中被访问到。 在第二行代码中，由于赋值的过程是自右向左进行的，b其实是没有声明的，只有a是声明了的。 一切声明的全局变量，全是window的属性。例如:12a = 3;//window.a=3var a = b = 3;//window.a=3,window.b=3 预编译**预编译四部曲在预编译的时候，会发生下面的四步，我们把这个过程称为预编译四部曲。 1234567第一步：产生执行上下文的对象（activition object）简称AO ，它存在于系统内部。第二步：找形参和变量声明，直接提到函数顶部，将变量和形参名作为AO属性名，并赋值undefined。第三步：将形参和实参相统一。第四步：在函数体里面找函数声明，值赋予函数体。 这个其实是在函数内部发生的，那不是函数内部呢？那就是会创建GO，GO相对AO来说就比较简单了，没有形参。 12345第一步：产生执行上下文的对象简称GO ，它存在于系统内部。第二步：找变量声明，直接提到函数顶部，将变量名作为GO属性名，并赋值undefined。第三步：在非函数体里面找函数声明，值赋予函数体。 其实在GO上的属性就是window上的属性12window = GO = &#123;a: &#125;//a = window.a 还需要注意的一点常识就是，if语句里面不能有function。 举一些例子首先讲一个上节课的一个小例子： 12345var foo = 100 + &apos;200&apos;; //100200var foo = &apos;200&apos; + 100; //200100var foo = &apos;20&apos; * 10; //200var foo = &apos;20&apos; / 10; //2var foo = &apos;21&apos; % 10; //1 接下来就是重点了，我将会讲一些经典的预编译的例子。大家一起加油哦！ 12345678910111213function fn(a) &#123; console.log(a); //function a() &#123;&#125; var a = 123; console.log(a); //123 function a() &#123;&#125; console.log(a); //123 console.log(b); //undefined var b = function () &#123;&#125; console.log(b); //function () &#123;&#125; console.log(d); //function d() &#123;&#125; function d () &#123;&#125;&#125;fn(1); 下面我们来一起分析一下，这是一个函数，会产生AO。会发生预编译四部曲，我们接下来一起分析一下吧。 1234567891、创建AO对象2、找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined3、将实参值和形参统一4、在函数体里面找函数声明，值赋予函数体AO = &#123; a : undefined, --&gt; 1, --&gt;function a() &#123;&#125;, b : undefined, d : function d() &#123;&#125;&#125; 预编译结束，接着一步一步的进行里面的语句，于是就得到了上面程序的结果。 看到这里，可能大家有点懵，没关系，我们继续来讲下一个例子。 123456789101112131415161718function text(a,b) &#123; console.log(a); //1 console.log(c); //undefined c = 0; console.log(c); //0 var c; console.log(c); //0 a = 3; console.log(a); //3 console.log(b); //function b() &#123;&#125; b = 2; console.log(b); //2 function b() &#123;&#125; console.log(d); //function d() &#123;&#125; function d() &#123;&#125; console.log(b); //2&#125;text(1); 这是一个函数，会产生AO。会发生预编译四部曲，我们接下来一起分析一下吧。123456789101、创建AO对象2、找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined3、将实参值和形参统一4、在函数体里面找函数声明，值赋予函数体AO = &#123; a : undefined, --&gt; 1, b : undefined, --&gt; funtion b() &#123;&#125;, c : undefined, d : function d() &#123;&#125;&#125; 是不是明白了许多，接下来我要加入GO了，将GO和AO一起进行分析。请看下面的例子： 12345678var a = 100;function text () &#123; //AO = &#123;&#125; console.log(a); //100,AO里面没有的话会向上找GO里面的a。 a = 200; console.log(a); //把GO里的100改成了200，200&#125;text();console.log(a); //200，GO里的100已经改成了200 可能看的有点懵，我再来举一个相似的例子： 1234567891011121314a = 100;//GO = &#123;100&#125;function text() &#123; //AO = &#123;a : function a() &#123;&#125;&#125; console.log(a); //function a()&#123;&#125; a = 200; //AO = &#123;a : 200&#125;,但没有将GO中的a进行更改 function a()&#123;&#125; console.log(a); //200 var a; console.log(a); //200&#125;text();var a;console.log(a); //100 是不是觉得特别有意思呢？哈哈哈。 为了让大家理解的更深，我多举几个例子吧。 123456789101112131415function b() &#123; console.log(c); //undefined c = 0; //暗示全局变量，会在GO中产生 console.log(c); //0 console.log(a); //undefined a = 123; console.log(a);//123 var a = 324; console.log(a); //324&#125;b();var c;console.log(c);//0//解析：GO = &#123;c : undefined&#125;AO = &#123;a : undefined&#125; 是不是已经比较熟练的掌握了预编译。再来一个例子吧。 123456789101112text();var a;a = 324;function text() &#123; console.log(b);//undefined if(a) &#123; var b = 234; &#125; console.log(b);//undefined&#125;//预编译不看能不能执行，有声明就直接扯出来，在if里面的b就直接给提前了。//并将b赋值为undefined 但是在预编译的时候，也需要return,举个例子： 12345678function a() &#123; //AO = &#123;foo : function foo()&#123;&#125;&#125; return foo;//function foo()&#123;&#125;，直接就返回了 foo = 10; function foo() &#123;&#125; var foo =11;&#125;console.log(a()); 这就是预编译的整个过程。 作用域精讲首先，函数上面有一些东西是不提供操作的，其中有一个就是：scope属性，它存储的就是函数的真实的作用域，是函数执行期上下文的集合。 运行期上下文:当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。 作用域链：就是scope中所存储的执行期上下文的集合，这个集合成链式连接。就是作用域链。来个例子讲解一下： 1234567891011function a() &#123; function b() &#123; var b = 234; &#125; var a = 123; b();&#125;var glob = 100;a();//a定义：a.[ [ scope ] ] --&gt; scope chain ---&gt; 0:GO（全局作用域链）;如图一//a执行：a.[ [ scope ] ] --&gt; scope chain ---&gt; 0:aAO; 1：GO；如图二 图一：图二： 可以看到，当a定义的时候，已经拥有了GO，查找元素的时候，就是在scope里找，如果在自己的作用链就在自己的AO中索取，如果不存在，就从顶往下寻找。 当函数执行完之后，会销毁a中产生的执行期上下文，回归到a定义的时候。这也可以跟我们之前所说的，只能里面访问外面的，不能外面访问里面的一样，具体到理论上，就是外面的作用链，没有局部的作用域链，所以不能找到所需要的变量。 同样，我们在分析一下b，当b定义的时候，已经又有了a的劳动成果，就是a的作用域。如图三。 然后当b执行的时候，又产生了自己的作用域链。如图四。 图三：图四： 最后强调一下，当b执行完之后，意味着a也执行完了，意味着a和b的执行期上下文都被销毁，直接就恢复到a被定义的时候，只有全局的GO。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中闭包的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js函数相关","slug":"js函数相关","date":"2018-09-24T16:01:35.000Z","updated":"2018-10-23T02:43:15.599Z","comments":true,"path":"2018/09/25/js函数相关/","link":"","permalink":"http://moreluckily.com/2018/09/25/js函数相关/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中函数的相关知识。 函数先说一下为什么我们需要函数，请看下面这个例子： 123456789101112131415if(1 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(2 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(3 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125; 我们可以看到，打印出a 、b、c的语句重复了很多次，在编程里面称为耦合（重复），但是这是与编程原则所相违背的，编程要讲究高内聚，弱耦合，我们需要将它们都整合到一起，这时候就出现了函数了。 我们可以定义一个函数，当符合条件的时候就让这个函数执行，我们可以优化代码：1234567891011121314function test()&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(1 &gt; 0) &#123; test(); &#125;if(2 &gt; 0)&#123; test();&#125;if(3 &gt; 0)&#123; test();&#125; 这样，我们就是耦合程度大大降低了，这也是使用函数的一个重要目的。称之为：解耦合，把功能抽象出来，进行逻辑的处理之后，通过编写函数，达到把耦合程度降到最低。 函数的定义方式函数有最基本几个要素： 声明关键词：function， 函数名称， 参数（可选）。 函数的命名方式，是有规范的，如果多个单词进行拼接的时候，我们需要使用小驼峰式命名，即第一个单词小写，之后的每个单词首字母大写。例如: function theFirstName( ) { } 说完函数的命名方式之后，我们需要知道怎样对函数进行定义。 有两种方式： 1、函数声明方式，例如 ：function theFirstName(){} 2、函数表达式方式，例如 ：123var test = function demo() &#123; code &#125; , 函数表达式var test = function () &#123; code &#125; , 匿名函数表达式 (重点) 当我们在控制台调试的时候，我们可以发现第一种方法，利用test ，可以寻找到该函数，但是利用函数的名字demo，却会报错。第二种方法直接利用test就可以寻找到该函数，这表明了，函数表达式的demo这个名字，其实填写和不填写是一样的，因为在JavaScript内部，会将函数表达式最后都转化为 匿名函数表达式，所以我们统一采用匿名函数表达式，并称之为：函数表达式。 函数的参数12function test（a, b）&#123; code &#125;test(1,2); test后面跟着的一个括号就是用来填函数的参数的，这里写上一个a和b，就相当于在函数内部隐式的定义了两个变量a和b，参数不代表实际的值，相当于占位而已，必须是当你传入实际的值的时候，才会有特定的意义。所以我们称之为形式参数，简称形参，然后我们都通过传入1,2，这样就相当于给a赋值1，给b赋值2，这两个实际的值就称之为实际参数，简称实参。 JavaScript的参数机制很强大，它不限制位数，不限制类型。形参和实参都是天生的不定参，两者的长度没有规定相等，你可以形参定义100个，但是实参只传10个，或者形参定义两个，实参传200个都是没有问题的。这里又引出了一个概念：参数列表。 实参列表：arguments[1,2] ,实参列表就是用来存放实际参数的，就是我们传进去的参数，对于test来说，arguments有两位分别是1,2.第二个就是arguments是一个类数组，它有长度，无论形参怎么样，实参都会存储arguments中。 形参列表：test[a,b],实参列表，就是函数名字的类数组，里面存放的就是形参，对于test，里面就是a和b。 要注意的是，形参列表和实参列表之间有个映射关系，这个映射关系必须是两者长度一样的时候才会存在，当这个映射关系存在的时候，如果形参列表发生改变，那么实参列表也会跟着改变。例如： 1234567function func(a,b)&#123; a = 2; b = 3; console.log(argements[0]); //2 console.log(argements[1]); //3&#125;func(1,2); 可以看出，func传进的参数个数跟形参的个数长度是一样的，所以当a，b改变的时候，形参会发生改变。 12345function sum(a,b)&#123;b=2;console.log(arguments[1]);//undefined&#125;sum(1); 但是要注意的是，映射规则必须是要一一对应的时候才会有“你变我就变”，没有一一对应例如，形参个数不等于实参个数，都是没有映射规则的。 12345678function sum()&#123;var result = 0;for(var i = 0; i&lt;arguments.length;i++)&#123;result += arguments[i];&#125;console.log(result);//1+2+3+4+5+6=21&#125;sum(1,2,3,4,5,6); returnreturn是用来确定函数的返回值的，例如：12345function demo2 () &#123; return 222; &#125;var func = demo();console.log(func) //222 第二个作用就是，终止函数，即，当引擎解析到return语句的时候，那么该函数会马上停止执行，并返回出return后面的语句。 作用域作用域是一个很重要的概念，每一个函数代码块都是一个作用域，这里有一个全局作用域和局部作用域的概念。 全局作用域：除了function内部的都是全局作用域，所有在这个作用域声明的变量都是全局变量。 局部作用域：函数可以生成局部作用域，在函数内部声明的变量称之为局部变量。 全局作用域不能访问到局部作用域里面的变量，局部作用域里可以访问到全局作用域的变量。如果利用房子比作作用域的话，一个大房子就相当于一个全局作用域，每个大房子里面的小房子就相当于局部作用域，小房子可以随时开门去到大房子去寻找自身需要的东西，但是大房子没有小房子的钥匙，只能在自身的空间寻找自身需要的东西。这就是全局作用域和局部作用域的概念。 简单来说就是，外面的不能访问到里面的东西，里面的东西可以访问到外面的东西。来看一下这个例子。 123456789var a = 1;function test()&#123; a = 2; console.log(a) //2&#125;function test2()&#123; a = 3; console.log(a) //3&#125; 函数会产生作用域，而作用域产生的效果：里面的可以访问外面的,外面的不能访问到里面的，并列的不可以互相访问。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的预编译 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js类型转换","slug":"js类型转换","date":"2018-09-24T15:29:42.000Z","updated":"2018-10-23T02:43:15.630Z","comments":true,"path":"2018/09/24/js类型转换/","link":"","permalink":"http://moreluckily.com/2018/09/24/js类型转换/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript的类型转换的知识。 初识引用值首先先简单的介绍2种引用值，数组和对象。首先来说一下数组（array）吧，举个例子：1234var arr = [1,undefined,null,true,345]；document.write(arr[0]);//1arr[0] = 2;document.write(arr[0]);//2 能读能写，数组的长度可以用arr.length来表示。接下来说一下对象（object），属性有属性名和属性值组成，举个例子：1234567891011var mrDeng = &#123; name:&quot;XXX&quot;, age:33, lastName:&quot;xxx&quot;, wife : &#123; name:&quot;xxx&quot; &#125;, height:172, health:100&#125;document.write(mrDeng.name);//xxx 这两个今天就先讲到这里吧，后面还会比较详细的讲到。 编程形式的区别编程语言按照形式上分，有两类，第一种称之为面向过程，第二种称为面向对象。面向过程编程：主要是按照步奏来来进行编程，考虑是怎么做。典型例子为C语言。面向对象编程：包含面向过程编程，但是它主要考虑是处理方法，利用什么资源进行编程，更加的结构化。js即面向过程又面向对象。 typeof 运算符在我们处理数据的时候，经常需要关注数据的类型，这时候可以使用typeof运算符。 typeof（）运算符可以区分出数据的类型，他返回六种值，分别是object，number，string，undefined，boolean，function。返回的是形式都是字符串形式。它还有一个特点就是，当一个变量未经声明就使用时会报错的，但是利用typeof判断一个未经声明的变量，会返回undefined，但是不报错。了解了typeof之后，我们就可以正式介绍类型转换了。 举一些例子来看一下吧。12345var a = 123;typeof（a）;//出现numbervar a = NaNtypeof（a）;//出现number 这就很奇怪了，下面就一起来学习类型转换吧。 显式类型转换Number（）这个方法可以将传进去的参数转化为数字类型的数据，如果传进去的不能被转化为数字，就会返回NAN。 有个注意的地方就是，false,null，’’(空串)，会转化成0，undefined，NAN，都会转化为NaN。 举一些例子吧， 12345Number(&apos;asdfa&apos;) // NaNNumber(&apos;12333&apos;) // 12333Number(null) // 0Number(undefined) // NaNNumber(NaN) //0 parseInt()这个方法会将字符串转化为数字类型，并进行数字截断处理，当传入的是数字和字符串，它会把数字单独截取。第二个用法，就是它可以进行十进制数向其他进制数进行转化。举一些例子吧。123456var num = parseInt（xxx）;&quot;123&quot; //123undefined //NaN NaN //NaNvar num=parseInt(&quot;12a3&quot;);//12var num=parseInt(&quot;6&quot;,2)//将6转化为2进制, 110 parseFloat（）toFix（）parseFloat（）这个方法也是将参数转化为数字类型，但是它不可以进行进制的转换。var num=parseFloat(&quot;10.123&quot;) //10.123 toFix（）可以设定保留多少为有效数字.var a = 199.223; a.toFixed(2); //199.23 string()string():这个方法就是将传进的参数转化为字符串类型的数据。这个没什么好说的。 Boolean()boolean():这个方法就是将传进的参数转化为true，或者是false，只有那6个值为false。undefined,null,NaN,””,false,0。 toString()这个方法很重要，首先它可以将调用它的变量转化字符串，第二个就是它可以将调用它的变量转化为十进制。另外可以利用它来判断object和array。这个之后可以跟大家在介绍，今天就不展开了。 12var str = 123;var num = str.toString(2);//string类型,将10进制转化为2进制。 1234将2进制转化为8进制：var num=parseInt(&quot;1000&quot;,2);document.write(num.toString(8));先转化成2进制，再转化为8进制。 隐式类型转化isNaN（）NaN是一个很特殊的东西，它“六亲不认”，它任何东西都不等于，包括它自己。12NaN == NaN //falseNaN === NaN //false isNaN（）就是用来判断NaN的。它可以将传入的参数判断是否为NaN。 12isNaN(NaN) //trueisNaN(0) //false 其他的隐式类型转化一元正负运算符:12var a = &quot;1234&quot;;var b = a + 1; // 12341 当使用+ 号进行字符串和数字类型进行操作的时候，+号两边，会有一个隐式类型转换，就是将数字调用string，然后进行拼接。 还有就是++运算符，例如：123var a = &quot;123&quot;;//Number(a) ++document.write(a++ + &quot;:&quot; + typeof(a));//123:Number 会先把a转化为数字类型,在进行其他的计算。 “- * / %” 转化成number,&amp;&amp; || !转化成布尔值。&gt; &lt; &lt;= &gt;=在一侧是数字时转化成number。 1234underfined == 0 //falsenull == 0 //falsenull == underfined //true(特殊规定)``` var a = “10” &gt; “9”;document.write(a);//输出false(字符串会比较ASCII码)12还有：===绝对等于和 !==绝对不等于不会发生类型转换，只有2侧一致才返回true。 var a = 0 == “”; //truevar a = 0 === “”; //false12 var a=(“11”*3 + “2”)/2 //166, 33+”2” 等于”332”`好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的函数 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的运算符及语句","slug":"js的运算符及语句","date":"2018-09-23T16:12:47.000Z","updated":"2018-10-23T02:43:15.615Z","comments":true,"path":"2018/09/24/js的运算符及语句/","link":"","permalink":"http://moreluckily.com/2018/09/24/js的运算符及语句/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript的运算符和JavaScript的一些基本语句。 JS的运算符运算符首先运算符分为：算数运算符，比较运算符以及逻辑运算符。 “+和-”运算符“+”和“-”运算符其实是一样的规则的，在这里我只介绍“+”运算符，他和”-“运算符是一样的，就不花大量的时间去介绍了。 在这里比较重要的两点：数学运算、字符串链接，而且任何数据类型加字符串都等于字符串。 下面举一些例子来说明这些问题： 12var a = &apos;a&apos; + 1 + 1 ; //得到: a = &apos;a11&apos;var a = 1 + 1 + &apos;a&apos; + 1;//得到: a = &apos;2a1&apos; 这里就需要注意运算时的优先级了。优先级”=“最弱，”()”优先级较高。而且运算时是从左向右运算的，和生活中的数学计算还是有一定的差别的。这里需要注意一下。 再来看一下这些例子： 12345var a = 1;var b = a++; //2var c = ++a; //3console.log(a++);//3console.log(++a);//5 由以上的例子我们可以知道，a++和++a是有区别的，a++是先进行该语句，再进行a+1，++a是先进行a+1，再进行该语句。 “/和%”运算符“/”就是数学中的除法，这个没什么特别的作用，“%”是取余的意思。举个例子吧。 12var a = 10 / 3;//3.3333333333333335var b = 10 % 3;//1 通过这个例子我们也能知道数字在浏览器中只能取小数点后的17位，而且第17位是不准确的。 在来看下面的例子： 12345678var a = 1.0000000000000001;var b = 1.0000000000000001;//小数点后16位var c = a + b;var d = 1.000000000000001;var e = 1.000000000000001;//小数点后15位var f = d + e;console.log(c);//2console.log(f);//2.000000000000002 从这里我们可以知道，浏览器只能计算小数点后15位的数据。 比较运算符比较运算符有“&gt;”，”&lt;”，”==”，“&gt;=”，“&lt;=”，”!=”等等，两个值的比较结果为boolean值，即只有true和false这两种结果，而且需要注意的是：比较运算符如果存在跟算术运算符一起出现的时候，先计算算术运算符部分，即算数运算符的优先级是要高于比较运算符的。 OK，接下来就举一些例子来对其进行说明： 12var a = 1 + 2 &gt; 2 + 2;//falsevar a = 3 &gt; 2 &gt; 1;//false 第一个，首先进行加减运算，即两边得到：3&gt;4，答案肯定是false。第二个，首先进行3&gt;2，答案是true，这里会发生一个隐式类型转换，即会将true转换为1，1&gt;1，答案当然是false。 逻辑运算符*首先要说的就是运算时，会发生隐式类型转换，有6个值会转换为false，其他的都是true。这个是必须要记住的。 underfined NAN null 0 “”（空串） false。这6个值会转换成false,然后再去进行计算。 &amp;&amp; 运算符这是我们常说的与运算符。先不说它的特点。那接下来举一些例子吧：1234var a = 1 &amp;&amp; 2;//2var a = 0 &amp;&amp; 2;//0var a = 3 &amp;&amp; 2 &amp;&amp; 1;//1var a = 1 + 2 &amp;&amp; 2 + 3;//5 &amp;&amp;运算符就是当前面的出现false时，就不看后面的结果，直接将0返回。当前面不为0时，就将后面的值返回，当也要注意的是：加减的优先级任然是高于逻辑运算符的。比较常见的应用就是短路语句了，举个例子：12var data;data &amp;&amp; fn(data);//data有数据才执行后面的函数 | | 运算符或运算符，||当前面为true,就返回前面的东西，||当前面为false,再看后面的东西。举一些例子来看一下：12var a = 1 || 2;//1var a = 0 || NaN || undefined;//undefined ! 运算符非运算符，就是取反的意思。这个没什么介绍的。 JS语句if( )语句如果if( )语句里面的判断是正确的话，那么就会走接下来的代码块，否则就跳过if语句。例如：123if(a)&#123; console.log(a); &#125; if( ) else 语句看例子： 1234567if(a)&#123;console.log(a)&#125;else&#123;var a = 5 ;console.log(a);&#125; 如果，a不为0就会打印出a，否则就进行else里的语句。 else if( )语句看例子:123456if(date is monday）&#123;console.log(&apos;monday&apos;)&#125;else if(date is tuesday)&#123;console.log(tuesday)&#125;else&#123;&#125; for循环语句这个是最常见的语句之一，看例子：123for(var i = 0; i &lt;= 10; i++;)&#123;console.log(i + &apos;,&apos;);&#125; //0,1,2....10 这个也比较好理解，我就不多说了。 while 循环语句这个语句跟for循环是差不多的，但是我们有时候可以利用它来进行递归，这样效率更高（少些几行而已）while（）括号里面直接填写的是判断条件，代码块写的就是执行语句。但是我们要注意，如果填入的是一个一直成立的表达式，那么它就可能会一直死循环下去。never-ending loop 无限死循环。 switch 语句这个语句相信大家都很熟悉吧，我先来举个例子：1234567891011var date = window.prompt(&apos;input&apos;);switch(date)&#123; case &quot;monday&quot;： doucment.write(&apos;working&apos;); case &quot;tuesday&quot;: document.write(&apos;working&apos;); case &quot;wendesday&apos;: document.write(&apos;working&apos;); case &quot;sunday&quot;: document.write(&apos;resting&apos;); &#125; 当输入monday，会出现working，working，working，resting。就需要优化：123456789101112var date = window.prompt(&apos;input&apos;);switch(date)&#123; case &quot;monday&quot; : case &quot;tuesday&quot; : case &quot;wendesday&quot; : document.write(&apos;working&apos;); break; case &quot;sunday&quot; : document.write(&apos;resting&apos;); break; defalut :document.write(&apos;nice!&apos;)//其他的情况；&#125; break停止的是里面的一个循环。外面的循环正常进行。（停止循环就用break），continue结束本次循环，继续进行下一次循环。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的类型转换，谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"javaScript的历史","slug":"javaScript的历史","date":"2018-09-22T17:02:44.000Z","updated":"2018-10-23T02:43:15.584Z","comments":true,"path":"2018/09/23/javaScript的历史/","link":"","permalink":"http://moreluckily.com/2018/09/23/javaScript的历史/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。 前面的html和css忘了一些不要紧，我们需要好好学习javaScript，因为前端工程师也可以叫做JS工程师，也就是说JS是前端最重要的，大家一起加油吧！ JS的发展史首先我要说一下javaScript的简称是js，而且js和java没有任何的关系，它俩是两个东西。现在介绍一下js的发展史吧！1994年4月，马克.安德森和Silicon Graphics（简称为SGI，中译为“视算科技”或“硅图”）公司的创始人吉姆·克拉克（Jim Clark）在美国加州设立了“Mosaic Communication Corporation”。Mosaic公司成立后，由于伊利诺伊大学拥有Mosaic的商标权，且伊利诺伊大学已将技术转让给Spy Glass公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为Netscape Navigator，公司名字于1994年11月改名为“Netscape Communication Corporation”，此后沿用至今，中译为“网景”。微软的Internet Explorer及Mozilla Firefox等，其早期版本皆以Mosaic为基础而开发。微软随后买下Spy Glass公司的技术开发出Internet Explorer浏览器，而Mozilla Firefox则是网景通讯家开放源代码后所衍生出的版本。 JavaScript作为Netscape Navigator浏览器的一部分首次出现在1996年。它最初的设计目标是改善网页的用户体验。初期JavaScript被命名为，LiveScript，后因和Sun公司合作，因市场宣传需要改名JavaScript。后来Sun公司被Oracle收购，JavaScript版权归Oracle所有。 浏览器组成浏览器分为shell部分和内核部分。内核部分又有渲染引擎（语法规则和渲染），和Js引擎以及其他模块。最出名的就是谷歌公司chrome的js引擎，就是著名的v8引擎。它的特点就是可以直接把js编译为机器码，所以这速度是最快的，后来许多浏览器也有了自己的js引擎。 js引擎的发展： 2001年发布ie6，首次实现对js引擎的优化。2008年Google发布最新浏览器Chrome，它是采用优化后的javascript引擎，引擎代号V8，因能把js代码直接转化为机械码来执行，进而以速度快而闻名。后Firefox也推出了具备强大功能的js引擎Firefox3.5 TraceMonkey（对频繁执行的代码做了路径优化）Firefox4.0 JeagerMonkey 同步和异步同步就是，同一时间只能干一件事情。异步就是，同一时间可以干多件事情。 单线程，同一时间，只能干一件事情。 多线程，同一时间，能干多个事情。 js的特点解释型语言计算机语言可以分为两种，第一种称为编译性语言，第二种称为解释性语言。 编译性语言：通篇翻译完，再执行一遍，然后生成一个编译文件，执行的是编译文件，优点是：比较快，缺点：跨平台差。典型的例子：C，C++等 解释型语言：翻译一行，执行一行，缺点就是：速度慢，优点是：可以跨平台。典型代表：PHP，Python，js。 注意比较常见的一种语言：Java，它属于两者之间，既不是编译型语言，也不是解释型语言。通过javac弄成.class文件，有兴趣的可以去百度一下。 js就是单线程的，同一时间只能干一件事。但我们可以让它看起来像多线程一样。举个例子，就像我们吃饭一样，吃一口饭，再吃一口菜，吃完之后，我们将这段时间快进快进，现在看碗里的饭和盘里的菜。我们可以看见饭和菜是同时慢慢减少的。这就是js的执行队列。 ECMA标注 — 为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格JavaScript兼容于ECMA标准，因此也称为ECMAScript。 开始学习JSJS分为三大部分，ECMAScript ， DOM，BOM。前两个最重要，ECMAScript是基础，DOM可以操作html和CSS。而BOM可以操作浏览器，那这样的话就权限太大了，在开发中是不允许。 JS的引入JS的引入方式和CSS类似，首先介绍第一种方式，就是页面级js，在head或者body中加入：&lt;script&gt;js的内容&lt;/sxript&gt;第二种方式就是外部js形式，一般在head标签里加：&lt;script src=&quot;lesson1.js&quot;&gt;&lt;/script&gt;为符合web的开发标准：结构html、样式css、行为js相分离，通常采用外部引入。 有一点需要注意的就是：JS文件加载的时候，它会把所有内容都阻塞了，所有东西都不能够进行操作，必须要等到JS加载完才能进行操作。所以我们最后一般将script标签放在body标签的底部。避免js文件阻塞html和CSS的运行。 js的基本语法JS中的变量（variable）一个变量，肯定首先需要对这个变量进行声明。var a;然后对变量进行赋值：123var a;a = 1;var a = 1; 前两句的效果和第三句的效果是一模一样的。当声明多个变量时，可以这样来写：12345var a,a,b,c,d;var a,//一般都这样来写 b, c, d; 变量的命名规则1、变量名必须以英文字母、_、$ 开头 2、变量名可以包括英文字母、_、$、数字 3、不可以用系统的关键字、保留字作为变量名 那js中有哪些关键字和保留字呢？看下面这张图： 这些我们并不需要去背。 js的基本语法数据类型数据的类型分为两大类，原始值和引用值。 原始值（栈数据） Number，数字类型。例如：1,2,3… String，字符串类型。例如：”123”,’123’。要用单引号或双引号包裹起来 Boolean，布尔类型，只有:true,false。 Undefined，未定义，只有一个，它自己本身undefined Null，空，也只有一个，null 引用值（堆数据）前期先介绍三类： Array，数组。例如：[1,2,3] Object，对象。例如：{name : “wang”,age : 20 } Function，函数，例如：function () {} 栈数据和对数据的区别栈（stack）数据，类似一个框，只有一个口。先进后出。first in last out。堆（heap）数据，指向的是堆的地址。 那我们来分析一下下面代码的情况： 12var a = 1;a = 2; 首先，js向系统索取了一个地址，假设为1000，来放a这个变量，然后赋值为1。然后当我们修改这个变量的时候，原来的1000地址的名字将不再为a，但是它的数据仍然存在。这个时候系统将另外取一个地址，假设为1001，这个地址将会命名为a，并且，值为2。它并不是真正意义上的删除，而是将原来的地址名字删掉，并重新赋值一个新地址而已。 js语法句的基本规则1、语句后面要用分号结束“；” 2、js语法错误会引发后续代码终止，但不会影响其它js代码块 3、书写格式要规范，“= + / -”两边都应该有空格 好了，今天的这篇blog就到这里结束了，谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"制作百度主页","slug":"制作百度主页","date":"2018-09-22T16:01:06.000Z","updated":"2018-10-23T02:43:15.630Z","comments":true,"path":"2018/09/23/制作百度主页/","link":"","permalink":"http://moreluckily.com/2018/09/23/制作百度主页/","excerpt":"","text":"新的blog，新的开始。今天我将带着大家一起制作百度主页。 百度主页的制作首先是html的框架：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;div class=&quot;navSection&quot;&gt; &lt;ul&gt; &lt;li class=&quot;more&quot;&gt; &lt;a href=&quot;#&quot;&gt;更多产品&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;light&quot;&gt; &lt;a href=&quot;#&quot;&gt;设置&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;light&quot;&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;视屏&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;地图&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;hao123&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;糯米&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;searchSection&quot;&gt; &lt;div class=&quot;logoSection&quot;&gt; &lt;img src=&quot;./src/img/bd.png&quot; alt=&quot;baidu&quot;&gt; &lt;/div&gt; &lt;div class=&quot;keywordSection&quot;&gt; &lt;form action=&quot;/&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;inputSection&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottonSection&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;infoSection&quot;&gt; &lt;div class=&quot;codeSection&quot;&gt; &lt;img src=&quot;./src/img/code.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;手机百度&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;messageSection&quot;&gt; &lt;p class=&quot;topP&quot;&gt; &lt;a href=&quot;#&quot;&gt;把百度设为主页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;关于百度&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;About Baidu&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百度推广&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;bottomP&quot;&gt; &lt;a href=&quot;#&quot;&gt; ©2017 Baidu 使用百度前必读 意见反馈 京ICP证030173号 &lt;/a&gt; &lt;span class=&quot;icon1&quot;&gt;&lt;/span&gt; &lt;a href=&quot;#&quot;&gt; 京公网安备11000002000001号 &lt;/a&gt; &lt;span class=&quot;icon2&quot;&gt;&lt;/span&gt; 然后就是css的内容来修饰这个框架了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151*&#123; margin: 0px; padding: 0px; list-style: none; font-family: arial;&#125;/* 导航区域css */ .navSection&#123; height: 60px;&#125;.navSection ul::after&#123; content: &quot;&quot;; display: block; clear: both;&#125;.navSection ul li&#123; height: 60px; line-height: 60px; float: right; margin-right: 15px;&#125;.navSection ul li a&#123; color: #333; font-size: 13px; font-weight: bold; /* text-decoration:none; */&#125;.navSection ul .light a&#123; font-weight: normal;&#125;.navSection ul .more &#123; margin-right: 30px;&#125;.navSection ul .more a&#123; color: #fff; background-color: #38f; padding: 6px 4px; text-decoration: none; font-weight: normal;&#125;/* 搜索区域css */.searchSection&#123; margin-top: 40px; text-align: center;&#125;.searchSection .logoSection &#123; /* text-align: center; */ margin-bottom: 20px;&#125;.searchSection .logoSection img&#123; width: 270px; height: 129px;&#125;.searchSection form div&#123; display: inline-block;&#125;.searchSection form .inputSection&#123; vertical-align: top; position: relative;&#125;.searchSection form .inputSection input&#123; width: 539px; height: 34px; padding-left: 15px;&#125;.searchSection form .inputSection span&#123; position: absolute; right: 10px; top: 50%; width: 18px; height: 16px; margin-top: -8px; background-image: url(../img/camera.png); background-position: 0px 0px; cursor: pointer;&#125;.searchSection form .inputSection span:hover &#123; background-position: 0px -20px;&#125;.searchSection form .bottonSection&#123; margin-left: -5px;&#125;.searchSection form .bottonSection input&#123; width: 100px; height: 38px; background-color: #3385ff; border: none; color: #fff; font-size: 15px;&#125;/* 信息展示区 */.infoSection &#123; text-align: center; margin-top: 270px;&#125;.infoSection .codeSection span &#123; display: block; font-size: 12px; font-weight: bold; color: #666;&#125;.infoSection .codeSection &#123; margin-bottom: 30px;&#125;.infoSection .messageSection p a&#123; color: #999; margin-right: 20px;&#125;.infoSection .messageSection .topP &#123; margin-bottom: 10px;&#125;.infoSection .messageSection .bottomP span &#123; display: inline-block; width: 14px; height: 17px; margin-left: -20px; margin-right: 20px; background-image: url(&apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/global/img/icons_5859e57.png&apos;);&#125;.infoSection .messageSection .bottomP .icon1 &#123; background-position: -600px -96px;&#125;.infoSection .messageSection .bottomP .icon2 &#123; background-position: -623px -96px;&#125; 这样一个百度主页就完成了，我们来看一下效果吧！ 看到这个效果，是不是特别开心和自豪呢？ 好了，今天到这就把前端的html和css告一段落，下篇blog将继续和大家一起学习javaScript，大家和我一起加油吧。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css -html","slug":"css-html","permalink":"http://moreluckily.com/tags/css-html/"}]},{"title":"css学习5","slug":"css学习5","date":"2018-09-22T14:07:33.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/22/css学习5/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习5/","excerpt":"","text":"从小到大我们都在听着别人的声音给自己的人生划格子，左边的这条线是要学业有成，右边的这条线是一定要有一个安稳的好工作，上面的这条线是三十岁之前要结婚，下面的这条线就是你结了婚一定得生个孩子，好像只有在这个格子里面才是安全的，才被别人认为是幸福的。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 溢出打点溢出打点是什么？ 一上来我们肯定会有这样的问题。其实在百度的网页中，这是特别常见的。我们先来看一下： 在文字的结尾处，我们发现内容并没有显示的特别完整，文字的最后是以“…”的形式结束的，这个效果是怎么实现的呢？ 首先是单行打点的情况：在标签中，当文字快溢出容器的时候，它们是会自动换行的。但是一旦换行，我们就不会有那种打点的效果了。这时候，有一个属性： white-space:nowrap; 它会使文字失去换行的本领。 这时候，文字就不会自动换行了，但是又要怎样才能让它出现“…”的形式呢？这时候又有一个属性： txet-overflow:ellipsis; 这就是文字溢出之后是ellipsis（省略），也就得到了文字溢出打点的效果。 最后当然也需要将溢出的文字隐藏起来，这就实现了文字溢出打点的效果了。 这三个东西配合，也就是三件套配合，会得到溢出打点的效果。举个例子来看一下吧。 1234567891011&lt;div&gt;有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。&lt;/div&gt;div&#123; width:200px; height:60px; border:1px solid black; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; &#125; 它的效果特别明显了，如下图所示： 可以看到，文字省略的部分已经用了“…”来代替了。 这个是单行打点，如果是多行文字打点呢？鉴于兼容性，多行文字我们一般不做打点处理，一般做多行文字截断处理。 而且在百度中常见的多行文字打点是什么情况呢？我们检查一下里面的情况，我们可以发现如下情况： 通过该图片我们可以发现，直接用的就是“…”的形式，即没有用技术的手段是实现索航文字打点技术。 背景图片当引用一张图片的时候，这些图片就是当做背景图片来进行设定的。 首先我们来了解一下背景图片的几个属性 1234567background-image:url(adress);//图片地址background-repeat:no-repeat;//图片不重复,不允许平铺background-repeat:repeat-x;//图片向x轴平铺background-repeat:repeat-y;//图片向y轴平铺background-size:100px 100px;//图片大小background-position:50% 50%;//图片位置,放在正中间 background-position:center center;//图片位置,放在正中间 先说一下 background-repeat，如我们不设定这个属性，当引入一张图片的时候，如果图片大小不等于容器大小的话，它们会自动重复，直到铺满容器。 第二再说一下background-position,这里的50%直接就是居中到容器中心，不需要在调整margin。还可以设定left center表示左边居中，当然还有bottom值来进行设定，可以灵活运用进行图片的定位。当background-size设定为100%的时候，就是直接铺满整个容器。 background引入图片的时候，存在网络不好，这时候就只加载html，不加载css和javaScript，图片显示不出来的时候，我们需要想利用img标签那样给它添加文字，怎样做呢？这里有2中方法去实现。 1、第一种方法，先让文字溢出，然后强制不换行 1234567891011121314&lt;a href=&quot;#&quot;&gt;淘宝&lt;/a&gt;a&#123;display:block;text-decoration:none;width:142px;height:58px;border:1px solid balck;background-image:url(address); background-repeat:no-repeat;background-size:100% 100%; text-indent:150px;//缩进大于容器宽度 让文字出去 white-space:nowrap;//不换行overflow:hidden;&#125; 2、这个是重点，比较常用。利用padding来显示背景图。当css加载不出来的时候，显示文字。 12345678910111213&lt;a href=&quot;#&quot;&gt;淘宝&lt;/a&gt;a&#123;display:block;text-decoration:none;width:142px;height:0px;border:1px solid balck;background-image:url(address);back-repeat:no-repeat;background-size:100% 100%; overflow:hidden;//文字溢出隐藏padding-top:100px;//利用padding来放背景图。&#125; 比较常用的实战方法 inline-block元素或者block元素可以嵌套任何元素 行级元素可以嵌套行级元素 p标签里不能放块级元素 a标签里不能放a标签 父子关系别写太多，4层5层就行了，写多了就浪费效率 float浮动模型实战上一篇blog由于篇幅的影响，今天再来对其进行实战。来实现显示淘宝的标价和多少人付款。 123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;span class=&quot;price&quot;&gt;$1000&lt;/span&gt; &lt;span class=&quot;offer&quot;&gt;20人付款&lt;/span&gt;&lt;/div&gt; *&#123; margin:0; padding:0; font-family: arial;&#125;div&#123; width: 200px; border:1px solid black; *zoom:1;&#125;div::after&#123; content: &quot;&quot;; display:block; clear:both;&#125;.price&#123; float:left; color:#f40; font-weight: bold;&#125;.offer&#123; float:right; font-size: 12px; color:#999; margin-top: 2px;//可以调节&#125; 实现的效果图如下图所示： 通过这个例子，你是不是对其理解的更加深刻呢？是不是觉得WEB前端特别有意思。 好了，今天到这就把前端的基础和css讲完了，下篇blog将带着大家把百度的主页做出来，当然我们也可以做淘宝的静态主页了。淘宝的静态主页就不在blog中放出来了，大家可以加我微信一起交流，谢谢大家！","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习4","slug":"css学习4","date":"2018-09-22T13:01:39.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/22/css学习4/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习4/","excerpt":"","text":"这个世界那么大、那么精彩，你什么都还没有看到过的时候就甘心的呆在一个格子里面，循规蹈矩安分守己地生活，这样的生活没有任何的风险，也不会被别人嘲笑，但是我总觉得一个没有把百酒都尝遍的人他是不大懂得清水之味的。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 两栏布局*这是一个经常考的一个问题，两栏布局问题也是一个特别重要的问题之一，它的题目是右侧固定，左侧自适应。也就是无论浏览怎么拉伸和收缩，右侧的一部分内容不会发生变化，而左侧的那部分内容进行自适应。123456789101112131415161718192021222324&lt;div class=&quot;left&quot;&gt;举个例子举个例子举 个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例子举个 例子举个例子举个例子&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;//写这么多字，让我们看起来更加的直观。*&#123; margin:0; padding:0;&#125;.left&#123; margin-right: 100px; (重点) height: 100px; background-color: green;&#125;.right&#123; position: absolute; top:0; right:0; width: 100px; height: 100px; background-color: red; opacity: 0.5;&#125; 会得到如下图所示的图形，由此我们知道，改变浏览器的宽度，不会使右侧的更改了透明度的红色正方形方块发生变化。 三栏布局*这是一个经常考的一个问题，三栏布局问题也是一个特别重要的问题之一，它的题目是右侧和左侧固定，中间部分自适应。也就是无论浏览怎么拉伸和收缩，右侧和左侧的一部分内容不会发生变化，而中间的那部分内容进行自适应。 123456789101112131415161718192021222324252627282930313233&lt;div class=&quot;middle&quot;&gt;举个例子举个例子举 个例子举个例子举个例子举个例子举个例子 举个例子举个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例子举个例子 举个例子&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;*&#123; margin:0; padding:0;&#125;.left,.right,.middle&#123; height: 100px;&#125;.left,.right&#123; position: absolute; width:100px; opacity: 0.5;&#125;.left&#123; top:0; left:0; background-color: red;&#125;.right&#123; top:0; right: 0; background-color: green;&#125;.middle&#123; margin:0 100px; background-color: blue;&#125; 会得到如下图所示的图形，由此我们知道，改变浏览器的宽度，中间自适应，两边的东西大小不会发生改变。 float浮动模型**float属性是一个古老的属性。它是用的最频繁的布局属性，以前它是专门为了实现文字环绕效果而设置的。就是用来为报纸设计的一个功能属性。但是对于响应式布局来说，float不具容错性比较差，容易出现比较严重的布局问题，而且他还可能带来一些其它问题，例如父元素塌陷，以及其它兼容性的问题。 文字环绕图片1234567891011&lt;img src=&quot;C:/Users/Administrator/Desktop/hg.jpg&quot; alt=&quot;这是胡歌&quot; class=&quot;left&quot;&gt;很多胡歌加油*&#123; margin: 0; padding: 0;&#125;.left&#123; width: 100px; float: left; margin-right: 1px; margin-bottom: 1px;&#125; 我们可以看到下图所示的样子：就像报纸一样，是不是特别有意思呢？哈哈哈。 float模型的特点float模型的feature（特点）：产生浮动流，只有块级元素（block）看不见浮动元素，所以块级元素会占据浮动元素原来的位置。文本（文字），文本类元素（inline,inline-block）,并且触发了bfc的元素都能看到浮动元素，并且会排列到浮动元素的后面。 clear加伪元素clear是用来对抗float的。而且只有块级元素才能用clear。通常，我们会使用到伪元素来进行clear。 伪元素又是什么呢？ 看下这个例子：123456789101112131415161718&lt;span&gt;加油&lt;/span&gt;*&#123; margin: 0; padding: 0;&#125;span&#123; background-color: red;&#125;span::before&#123; content: &quot;lucky&quot;; display: inline-block; width:60px; height: 20px; background-color: green;&#125;span::after&#123; content: &quot;Fighting&quot;; background-color:orange; 会得到如下的图形: 伪元素：（天生就存在），可以当元素使用，但是inline元素要改成display:inline-block。每个标签都有2个伪元素。 浮动的解决办法只有块级元素才可以清除浮动，这里有个标准。3+1标准：123456father&#123;*zoom：1；&#125;father::after&#123;//注意这里写的是两个冒号，主要的是跟伪类进行区分content:&quot;&quot;; //注意的是，即使content没有内容，也需要写display:block;clear:both;&#125; 实例讲解float浮动模型**这个例子就是淘宝的导航栏：我们使用float浮动模型来对它的一部分导航栏进行制作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;淘抢购&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;电器城&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;司法拍卖&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;*&#123; margin: 0; padding: 0; text-decoration: none; color: #424242; font-family: arial;&#125;.nav&#123; //3+1清除浮动 list-style: none; *zoom: 1;&#125;.nav::after&#123; content: &quot;&quot;; display: inline-block; clear:both;&#125;.nav .nav-item&#123; float: left; margin: 0 8px; height: 25px; line-height: 25px; font-weight: bold;&#125;.nav .nav-item a&#123; height: 25px; padding: 0 5px; display: block;&#125;.nav .nav-item a:hover&#123; border-radius: 15px; background-color: #f40; color:#fff;&#125; 得到的效果图就是如下图所示： 可以看到这个导航栏使用浮动模型来写的，基本和淘宝的导航栏是一样的。是不是特别有意思。鼠标放在哪个导航栏上，导航栏就会变色，你们可以去淘宝上看是不是这样的，哈哈。 这一篇blog就先讲到这里，下篇blog会更有意思。谢谢大家。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习3","slug":"css学习3","date":"2018-09-22T12:21:19.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/22/css学习3/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习3/","excerpt":"","text":"你要相信，命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，这个故事关于独立，关于梦想，关于勇气，关于坚韧，它不是一个水到渠成的童话，没有一点点人间疾苦。这个故事是有志者，事竟成，破釜沉舟，百二秦关终属楚，这个故事是，苦心人，天不负，卧薪尝胆，三千越甲可吞吴。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 层模型*说起层模型这个名字，可能大家会想到我的上篇blog中的盒模型，但不是一个东西哈，它俩的区别还是挺大的。首先来介绍一下position这个属性，它有几个常见的值，常见的有三个值，static，absolute，relative。position：absolute；这个属性它的feature(特点）是：脱离原来位置进行定位，相对于最近的有定位的父级（bfc）进行定位，如果没有，那么相对于文档（document）（浏览器边框）进行定位。position：relative；保留原来位置，进行层定位。相对于自己（出生）原来的位置进行定位。我下面介绍一个例子去帮助大家去理解层模型。 1234567891011121314151617181920212223242526&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;*&#123; margin: 0; padding: 0;&#125;.demo&#123; position: absolute; width: 100px; height: 100px; background-color: red; opacity: 0.5;//透明度，更好观察 left: 100px; top: 100px; z-index: 5;//层的设定，大于下面的就行&#125;.demo2&#123; position: absolute; width: 150px; height: 150px; background-color: green; top: 10px; left: 10px; z-index: 1;&#125; 得到的结果如下图所示： 可以看见红的在上面，当设置的z-index比下面的小时，则green在上面。 接下来在介绍一下position：relative；它在进行定位的时候，元素首先会出现在自己的位置上，然后再根据left，top的值，以自己原来的位置进行定位。 最后提一下position：fixed，相对于可是窗口进行定位，典型的例子就是网页中的小广告，窗口无论怎样往下走，他都是固定的位置不动，在两边的固定位置不变。但IE6中没有fixed（注意）。 居中布局*12345678910111213141516&lt;div&gt;&lt;/div&gt;*&#123; margin: 0; padding: 0;&#125;div&#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 50%; top: 50%; margin-top: -50px; margin-left: -50px;&#125; 它的效果图不就不在这里给出了，因为图可能会比较大，我把现象和大家说一下吧，就是会有一个长宽都为100px的正方形红色的方块在整个浏览器的正中间居中了。 简单的居中五环*了解了居中的情况，我们就能写一个简单的居中的五环了，是不是很有趣呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div class=&quot;plat&quot;&gt; &lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle5&quot;&gt;&lt;/div&gt;&lt;/div&gt;*&#123; padding:0; margin:0;&#125;.plat&#123; position: absolute; left: 50%; top: 50%; margin-top: -95px; margin-left: -190px;&#125;.circle1,.circle2,.circle3,.circle4,.circle5&#123; position: absolute; width: 100px; height: 100px; border-width:10px; border-style: solid; border-radius: 50%;&#125;.circle1&#123; left: 0px; top: 0px; border-color: red;&#125;.circle2&#123; left: 130px; top: 0px; border-color: green;&#125;.circle3&#123; left: 260px; top: 0px; border-color: yellow;&#125;.circle4&#123; left: 65px; top: 70px; border-color: blue;&#125;.circle5&#123; left: 195px; top: 70px; border-color: orange;&#125; 会出现如下图所示的一个简单的五环，这个颜色是我随便取得，并不是真正的五环的颜色。 这一篇blog就先讲到这里，下篇blog特别重要。谢谢大家。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习2","slug":"css学习2","date":"2018-09-21T07:02:33.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/21/css学习2/","link":"","permalink":"http://moreluckily.com/2018/09/21/css学习2/","excerpt":"","text":"年龄越大，越学会了顺其自然，以前总认为坚持会让人更强大，但是长大后才发现，让我们强大的是放下。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 css渲染机制section div ui li a em { }。计算机找这些标签的时候是从右向左找的，一步一步的过滤。这样找的时间最短，速度最快。这个就是css渲染机制，在上一篇blog中提到过这一点。 css属性*接下来说一下常见的css属性： 1、background-color：设定背景颜色 2、color：设定字体颜色 3、font-size：设定字体大小，默认字体大小为16px，这里设定的是字体的高，如果设定字体宽就会显得参差不齐。 4、font-weight：设定字体粗细，常用值为bold（加粗），normal（正常），lighter（细），一般只有bold和normal好使，这取决于浏览器的字体包是否有我们需要的字体。还可以通过integer这个属性来设置，100|200..|900 改变粗细，具体的写法是：font-weight:100,200…strong天生有这个属性。 5、font-style：italic，改变字体为斜体。em标签是天生就有这个属性。 6、font-family：字体，通用字体就是font-family: Arial。 这个字体是最好看的，最美观的。 颜色的三种表示方法1、直接形式英文的green，blue，yellow，red等，表示的是比较含糊的值。 2、颜色代码十六进制表示：光源三原色rgb，两位两位的十六进制数，0-ff，颜色饱和程度，0表示没有颜色混合； rgb 对应都是两位重复，则可以简写。 它的写法是：例如：#ffff00，可以简写为#ff0；#f0f0f0，就不能进行简写了。最常见的就是淘宝红#f40了。3、颜色函数rgb代表顺序Red(红色)、Green(绿色)和Blue(蓝色)。它的写法就是：rgb(255，255，255) 白色rgb(255，0， 0)代表红色rgb(0，255， 0)代表绿色rgb(0， 0，255)代表蓝色 css盒模型*首先来了解一下css盒模型的一些概念。 1、content：内容区，大小为width乘height。就是我们以前经常写的东西。2、padding：内边距，用来进行分隔边框和content，可以理解为缓冲位置。分上下左右四部分，设定的时候我们可以这样来写：123456padding:30px;//(表示上下左右全部为30px)padding:30px 20px 10px 20px;//(顺序为:上右下左，顺时针,进行设定内边距）padding:50px 20px 30px;//(顺序为:上 左右 下）padding:50px 30px;//(顺序为:上下 左右） 当然也可以通过padding-left，right，top，bottom分别来进行设置。 3、border：边框12345border-width:10px 20px 30px 40px;border-style:solid;border-color:balck;//边框的颜色border:1px solid black;//产生边框的形象，1px边框的粗细border-top-width:10px;//左边框的长度 style表示的是边框的样式为实线，color表示颜色为黑色，边框粗细为上右下左10px，20px，30px，40px像素，border设定粗细的时候顺序问题跟padding是一样的。上面是几种不同的设置方法，但最后都能得到我们想要的结果。 4、margin：外边距，设定盒子与盒子之间的距离。可以单独设置。但是margin不属于有色区域，计算盒子模型的大小的时候，不需要考虑其大小。5、盒模型图通过上面的介绍，其实我们得到一张盒模型的图：这个图就能特别清晰明了的知道了整个盒模型的基本情况。 6、远视图效果通过这些知识，我们就能写一个比较小的好玩的东西了，下面我就做了一个远视图效果的东西。123456789101112131415161718192021222324252627282930&lt;div class=&quot;wrapper1&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.box&#123; width: 20px; height: 20px; background-color: red;&#125;.content&#123; width: 20px; height: 20px; background-color: blue; padding: 20px;&#125;.wrapper&#123; width: 60px; height: 60px; background-color:red; padding: 20px;&#125;.wrapper1&#123; width: 100px; height: 100px; background-color:blue; padding: 20px;&#125; 得到的效果是如下图所示：当然还可以继续多加几层，是不是特别好玩呢？ margin塌陷问题先来看一下什么是margin塌陷：1234567891011121314&lt;div class=&apos;father&apos;&gt; &lt;div class=&apos;son&apos;&gt;&lt;/div&gt;&lt;/div&gt;.father&#123; width:200px; height:200px; background-color:red; &#125;.son&#123; margin-top:50px; width:100px; height:100px; background-color:green; &#125; 我们可以看到的现象是如下图所示： 子元素加上绿色，父元素为红色，理论上我们给子元素设置margin-top，绿色顶部应该跟黄色会产生一段距离，但是现在的问题就是，子元素带动父元素一起移动了50px，这就是margin塌陷问题。那怎么解决这个问题呢？就是让子元素离父元素的顶部50px，但父元素不移动。 margin塌陷解决1、第一种方法就是父级元素的顶部没了，塌陷了，那我给他加一个顶。border-top:10px solid black;这样虽然结决了这块的问题，但是在开发整个页面的时候是不行的，这个方法特别不靠谱，不能用这个方法。那就引出了下面的第二个方法了。 2、触发bfc机制，什么是bfc呢？bfc的全称是bfc-block format content。每一个盒模型都会有它们默认的一套渲染机制，就是我们平常用的都属于它们的默认渲染机制，在这套机制里面，会存在margin塌陷的问题，这时候，我们需要利用另一套渲染机制来进行渲染，这就叫做利用触发bfc了。那怎样触发bfc呢？ 在这里先只介绍三种方法： overflow:hidden; //溢出隐藏position：absolute;float浮动 当我们在父级father触发bfc即可得到我们想要的情况，操作方法如下。12345.father&#123; width:200px; height:200px; background-color:red; overflow:hidden; &#125; 操作完成之后，我们在重新进入以下页面，尽可以看见正常位置了，也就是我们想要得到的东西。 margin合并问题margin合并讨论的就不是父子结构了，而是兄弟结构。一个设定了margin-bottom,另外一个设定了margin-top，这两个取的是更大的一个，它们并不会产生更大的间距。这时候我们需要在其中一个兄弟元素中套上一个父级标签，对父级标签触发bfc即可解决这个问题。但是通常我们不会通过这种方法解决margin合并的问题，因为这样会带来其他的反效果。我们通常就直接取其中的最大值来用就行了。 好了，这篇blog到这里就结束了，希望大家喜欢。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习1","slug":"css学习1","date":"2018-09-21T03:58:39.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/21/css学习1/","link":"","permalink":"http://moreluckily.com/2018/09/21/css学习1/","excerpt":"","text":"我根本不知道我将来想要过什么样的生活，我根本不知道我将来想过什么样的生活，去哪个城市，做什么工作，我只是知道自己不想要什么，我不想要那种循规蹈矩、安安分分的平平淡淡的日子，不想要一个一眼就可以看到死的生活。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 浏览器的一些必备知识浏览器是由2大部分组成的，shell外核部分和内核部分。外核相对比较好做，但内核才是一个浏览器的核心。目前来说世界上主流浏览器有:1、微软 IE浏览器，它的内核是：trident。2、谷歌 Chrome，它的内核是：blink/webkit。3、苹果 Safari，它的内核是：webkit。4、火狐 Firefox，它的内核是：gecko。5、欧朋 Opera，它的内核是：presto 。它的兼容性特别好，这个浏览器可以在Windows、Mac和Linux三个操作系统平台上运行。在这里补充一点：以前谷歌和苹果一起开发的内核webkit，后来谷歌单独开发了一个内核blink，所以chorme内核写了两个，但现在基本都说是blink内核。 在这里还是强调一下，html 负责框架，css 负责内容， javascript 负责行为css的引入方式css的全称是cascading style sheet，也就是层叠样式表，必须依赖于html来进行操作，用以负责网页的内容。 它在html中引入的方式有三种： 1、行间样式，在标签里直接进行设置。例如：&lt;div style=&#39;width:100px;height:100px;background:red;&#39;&gt;&lt;/div&gt;2、页面级css，直接在html文件中，添加一个style标签，在style标签中进行css的设置。例如：1234567&lt;style type=&quot;text/css&quot;&gt; &lt;div&gt; width:100px; height:100px; background:red; &lt;/div&gt;&lt;/style&gt; 3、外部引入的方式，利用link标签，进行引入。一般在head中放入。&lt;link rel=&#39;stylesheet&#39; href=&#39;相对地址或绝对地址&#39;&gt; css的加载机制当我们引入了css之后呢，要介绍一下，是怎样加载的css文件的，在这里我们就要理解一下异步和同步的概念了。 异步的，并行的；在计算机术语中，异步是并行的，多线程的；同步的，串行的；在计算机术语中，同步指的是串行的，单线程，一个时刻只能干一件事情。这块可能我说的有点问题，大家可以在网上进行相关资料查找。当浏览器加载html文件的时候，是加载一行执行一行，当读到link标签的时候，会另开一个线程加载css，即异步加载css，html继续加载，css也一起加载，成一种“你干你的，我干我的”情况，这就是css的异步加载机制，这个很重要。 css选择器***在引入了css之后，若想添加样式，css的选择器就登场了。什么是css选择器呢？就是通过选择器，来确定某个或某种元素，以供我们进行样式的设定。下面就给大家介绍一下具体有哪些选择器。 1、id选择器当在一个标签中添上一个id，就可以通过该id选择器，将html中的框架和css内容进行联系起来。例：123456&lt;div id=&quot;only&quot;&gt;&lt;/div&gt;//html中的框架#only&#123; width:100px; height:100px; background-color:red; &#125; //css中的内容 id选择器，使用“#”+id来选择出对应的框架，然后将这个框架中的内容用css来补充。id选择器是一对一的。 2、class选择器123456&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;.demo&#123; width:100px; height:100px; background-color:red; &#125; 和id类似，其主要的形式如上面的程序所示。class选择器是多对多的。 3、标签选择器123456&lt;div&gt;&lt;/div&gt;div&#123; width:100px; height:100px; background-color:red; &#125; 和上面的标签类似，我们能够特别简单的就能理解了。 4、通配符选择器123*&#123; background-color:red; &#125; 这里注意一下，通配符选择器是将全部的标签都进行选择，包括html，head，body等标签。这里是将整个页面都变成红色。 5、属性选择器1234567&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;[class]&#123; width:100px; height:100px; background-color:red; &#125; 这里就是有class的全被选择了,当然也可以将class=”demo”写全，那就只选择一个了。 css选择器优先级比较介绍了这么多的选择器，我们不禁要想，如果有两个或者多个的选择器都选择了同一个元素的时候，而且这些选择器中的内容都不一样，那这个元素应该设置成什么样的样式呢？应该听谁的呢？举几个例子：1234567891011&lt;div id=&apos;only&apos; class=&apos;demo&apos;&gt;d&lt;/div&gt; #only&#123; width:100px; height:100px; background-color:red; &#125; .demo&#123; width:100px; height:100px; background-color:green; &#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现红色。也就是说id选择器的优先级是高于class选择器的。 123456&lt;div id=&apos;only&apos; style=&apos;background-color:green;width:100px;height:100px;&apos;&gt;&lt;/div&gt;#only&#123; width:100px; height:100px; background-color:red;&#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现green。也就是说行间样式的优先级是高于id选择器的。 1234567891011&lt;div class=&apos;demo&apos;&gt;123&lt;/div&gt; [class]div &#123; width:100px; height:100px; background-color:green; &#125; .demo&#123; width:100px; height:100px; background-color:red; &#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现red，但当.demo和[class]互换一下位置，此时浏览器会出现green。也就是说class选择器的优先级是等于属性选择器的。 css选择器权重*在这里就引出了一个比较重要的知识了，css选择器的权重，可以将这些权重归纳为如下： ！important infinity行间样式 1,0,0,0id选择器 1,0,0class选择器&amp;属性选择器&amp;伪类选择器 1,0标签选择器&amp;伪元素选择器 1,通配符选择器 0 当然了，我们就可以得出结论，当多个选择器混合使用的时候，我们需要将选择器的权重相加，之后再看那个权重进行比较，谁高就听谁的。这里的1,0,0,0是256进制的，在部分IE浏览器中256个class选择器才会大于id选择器。这里稍微要注意一下。（并不是2进制或者10进制） 6、父子选择器1234567891011&lt;div&gt; &lt;em&gt; &lt;p class=&apos;demo&apos;&gt;12345&lt;/p&gt; &lt;/em&gt;&lt;/div&gt;div em p&#123;width:100px;height:100px; background-color:green;&#125; 在开发的时候需要写成这种多级关系，让结构等价清晰明了。 7、直接子元素选择器直接子元素选择器，真正的父子选择器。1234567891011&lt;div&gt; &lt;em&gt; &lt;p class=&apos;demo&apos;&gt;12345&lt;/p&gt; &lt;/em&gt;&lt;/div&gt;div &gt; em &gt; p&#123;width:100px;height:100px; background-color:green;&#125; 而且父子选择器和直接子元素选择器是可以混用的。但在这里如果有多个这种在一起的时候，比如：section div ui li a em { }。计算机找这些标签的时候是从右向左找的，一步一步的过滤。这样找的时间最短，速度最快。 8、并列选择器12345678&lt;div class=&apos;demo&apos;&gt;1&lt;/div&gt;&lt;p class=&apos;demo&apos;&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; // 此时若想单独让2变成红色，这时候就需要用到并列选择器p.demo&#123; width:100px; height:100px; background:red;&#125; 9、分组选择器1234567div,p,em&#123; width:100px; height:100px; background-color:green; &#125; 这样div、p、em标签里的东西就全部都变成绿色，宽高各100。 在这里这篇blog就先告一段落了，下一篇blog就开始讲继续为大家讲解css。谢谢大家！！！","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"html学习3","slug":"html学习3","date":"2018-09-20T16:16:31.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/21/html学习3/","link":"","permalink":"http://moreluckily.com/2018/09/21/html学习3/","excerpt":"","text":"新的一天，每天都要元气满满哦。今天我将继续带着大家一起继续学习htnl中特别重要的一些标签的知识。 ol和li标签ol和li标签通常是一起出现的，是有序列表的意思，ol的全称就是order list，这2个标签能进行排序，例如：12345&lt;ol&gt; &lt;li&gt;第一点&lt;/li&gt; &lt;li&gt;第二点&lt;/li&gt; &lt;li&gt;第三点&lt;/li&gt;&lt;/ol&gt; 就会出现1.第一点2.第二点3.第三点，默认是用数字进行排序，当然也可以不用数字进行排序，例如：12345&lt;ol type=&quot;a&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;1&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;i&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;a&quot; reversed=&quot;reversed&quot;&gt;&lt;ol type=&quot;a&quot; start=&quot;2&quot;&gt; 第一行的意思就是用a,b,c等进行排序，当超过26个字母之后，就开始使用aa,ab,ac等等进行排序，type里也可以用A来进行排序，和a排序类似；第二行的意思就是用1,2,3等进行排序；第三行的意思就是用罗马数字进行排序，当然也可以用大写的罗马数字进行排序；第四行的意思就是用a,b,c等进行排序，但后面又加了一个属性reversed，reversed的中文意思是翻转,颠倒的。也就是反过来倒着排序；第五行的意思就是用a,b,c等进行排序，但后面又加了一个属性start，也就是从第2个值也就是b来进行排序。但要提的一点就是type里只能填5个值，也就是a,A,1,i,I这五个值。中特别重要的一些标签的知识。 ul和li标签*ul和li标签也是在一起出现的，ul的全称就是unorder list，是有序列表的意思。这个其实是用比较多的，ol反而基本上不怎么用。它的使用场景：大功能块，下面有很多功能子项 ，它们样式都一样，典型的例子就是网页的导航栏。即打个比方就是：ul相当于柜子，li相当于抽屉。li的全称是list item，ul也可以加type值来进行设置样式，属性值有三个，disc（实心圆 默认），square（方块），circle（空心圆）。 img标签*img标签的标准写法：&lt;img src=&#39;图片地址&#39; alt=&#39;文字&#39; title=&#39;图片内容&#39;&gt;img标签是用来显示图片的功能，img的全称就是image，就是图片，影像的意思，也就是将图片引入网页中。它是一个单标签，也可以将其写成一对标签的形式，即：&lt;img&gt;&lt;/img&gt;img标签中的src属性是图片的地址，这里有三种地址方式可以选择： 1、网络地址：就是网上的图片，网上的url,就是带http什么什么的。 2、相对路径，如果如果网页程序文件和图片文件是在同一文件夹下，这时候就可以写相对地址，相对路径就是一个大的范围。 3、绝对路径，如果网页文件和图片文件不在同一文件夹下，就需要使用绝对地址，绝对路径是一个特别绝对的地方，需要将路径写的特别清晰，位置要特别的清楚不能出错。 第二个属性就是alt属性，这是一个工业级别的属性，当我们网络比较差的时候，或者图片地址出错的时候，就会在图片位置显示出alt属性中的文字。其实这是一种容错手段，一级容错，将错误降到最低。也就是当图片不能正常显示的时候，文字就会被显示出来，这样用户体验更加好，尽管看不到图，但是至少知道图的内容是什么。这个也叫图片占位符。第三个属性就是title属性，这也是一个工业级的属性，当鼠标移动到图片位置的时候，就会在鼠标点处显示出title里的值。这个也叫图片提示符。 注释*html中注释的快捷键是“Ctrl加？”，具体的形式如下所示：&lt;!-- 注释内容 --&gt;注释能够找错，可以一个模块一个模块的注释，然后找到错误出在了哪个模块，然后再在这个模块里去寻找出错的位置。 a标签**a标签的写法如下所示：&lt;a href=&quot;http://www.baidu.com&quot;&gt; www.baidu.com&lt;/a&gt;a标签就是超文本引用，它是由anchor得来的，这个单词的意思是抛锚，锚。a标签的功能是：1、网页链接功能，即在href里写上一个地址，我在上面写了一个百度的地址，当点击这个地址的时候，网页就会自动跳转到该地。2、锚点功能，同样的在href处写一个id，当点击a标签的时候，会自动调到带有id的标签处，典型的例子就是我们常常看到的“一键置顶”的功能。3、打电话功能和发邮件，Tel属性可以填入一个电话号码。我们常常在美团外卖，饿了么等app中看到，他们都有一个给商家致电的功能，就是用这个写的，当点击a标签的时候，就会自动给Tel中的电话号码致电。发邮件和他类似。4、协议限定符，在恶意网站中，我们常常点击了一个东西，于是网页就自动跳出很多弹窗，而且退出不了，必须把浏览器关了。可以利用a标签这样写，其实就是里面写了一个死循环。 table标签table标签可以实现嵌套，能实现表格的功能。具体的写法如下图所示：1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; tr就是表格的行，td就是表格的列，table标签在以前是用来布局的，以前布局都用它，但是现在不用了，只需知道为什么不用它进行布局就ok。我们正常的程序是下载一行执行一行，并不会阻塞下面的代码，但是table必须是等待它里面的内容全部下载完才会进行渲染。这样的体验效果是极差的，所以不用table来进行布局。 form标签*form标签，能实现通信功能，也就是当前端与后端进行数据交换的时候，就会使用from表单进行数据的传输。form标签的写法是：&lt;form method=&quot;get/post&quot; action=&quot;&quot;&gt; action=&quot;http://www...&quot;&lt;/form&gt;这里面的属性就是：1、method:get或者post，发送数据的方式。2、action:目标接收地址，就是数据发送的地方。发送的信息要有信息的名和信息的值。 input标签*input标签是单标签：写法如下所示：&lt;input type=&quot;text password radio/checkbox sumbit&quot; name=&quot;&quot; value=&quot;&quot; value=&#39;默认值&#39; checked=&#39;chechked&#39;&gt;第一个属性type，可以通过type属性的值来显示不同类型的input。1、text，文本框，输入用户名之类的。 2、password，密码框输入密码。 3、radio，checkbox，单选框，多选框。 4、submit，提交数据。 在第三条radio和checkbox，当type为radio的时候，input作为单选框，这时候需要利用name属性，所有选项的name属性必须都相等，表示他们属于同一单选框，这样才可以实现单选功能。当type属性为checkbox的时候，就是作为多选框，这时候，各选项的name属性不一样。 还有我们可以改善用户体验，举个例子，当使用input调查性别的时候，只有两个选项，男女，这时候，我们可以设置一个默认选项，假如默认是男性，我们可以在男性的input里添加一个属性：checked=”checked”，表示，男性为默认选项。这样就可以减少用户操作，提升用户体验。就是每一个选项不用我们都去点，而只需要进行对默认的选项进行肯定或者是否定，肯定就不需要用户去操作了，这样就让用户的体验改善了。 标签的分类**html标签可以分为三类，第一类称之为块级元素，第二类称之为行级元素，第三类就是行级块元素。 1、块级元素：占满整行，可以改变宽高。“display=block”， 可以通过CSS样式设置宽高。典型的标签： div p ul ol li address form h1 - h6等等2、行级元素：不占满整行， 元素所占空间完全由内容所控制。不可以通过CSS样式设置宽高。“dispaly=inline”， 典型的标签： span a em strong select br3、行级块元素 “display=inline-block”，这种标签是既不属于行级元素，也不属于块级元素。根据自身内容大小决定其所占据的空间，可以通过CSS样式设置宽高。典型的标签：img input。 在这里html就告一段落了，下一篇blog就开始讲css了。谢谢大家！！！","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"html学习2","slug":"html学习2","date":"2018-09-19T15:58:27.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/19/html学习2/","link":"","permalink":"http://moreluckily.com/2018/09/19/html学习2/","excerpt":"","text":"新的一天，每天都要元气满满哦。今天我将带着大家一起继续学习htnl标签的一些知识。 P标签p标签，也叫段落标签，它能使写在其里面的内容成段落展示。标准写法就是如下所示：&lt;p&gt;内容&lt;/p&gt;p标签的p就是paragraph的缩写，是html中比较常用的标签之一。 h1-h6标签h1-h6标签能呈现越来越小的趋势标题的功能，h1标签的字号最大，h6标签的字号最小，它们的特点就是就是独占一行，改变大小，加粗文字。它们的基本写法如下所示： 123&lt;h1&gt;1级标题&lt;/h1&gt;...&lt;h6&gt;6级标题&lt;/h6&gt; strong标签&lt;strong&gt;加粗文字&lt;/strong&gt;这个标签就是起到加粗的作用，但是在之前用的都是b标签，即：&lt;b&gt;加粗文字&lt;/b&gt;熟悉WORD软件的朋友可能对其不陌生，对的，可以在WORD中用来加粗文字，但现在strong标签更加语义化，让我们更能理解他的意义。 em标签&lt;em&gt;斜体&lt;/em&gt;这个标签就是起到使文字变成斜体的作用，在之前用的都是 i标签，即：&lt;i&gt;斜体&lt;/i&gt;和b标签一样，都是从WORD中引用过来的，但现在基本不会使用i标签了，基本都会使用em标签。 del标签&lt;del&gt;￥80元&lt;/del&gt;这个标签会在文字中间加一条横线，得到的效果图如下图所示：这个效果是不是在很多地方都见过呢？没错，在淘宝或者京东里见过许多次，但是根据开发根据开发标准，del标签是不能使用的，因为，这个可以利用css进行设置，因为直接对其样式进行了修改，而html主要负责的是页面的框架架，这个标签在使用的时候，那么css和html的功能有重合的部分，所以不能使用这个这个标签，也即是这个标签不重要，可以将其忽略。在这里也介绍几个不重要的标签，单标签br和hr。1&lt;br&gt;2&lt;hr&gt;3br标签是换行，hr标签是加一条横线的效果，都不经常使用。在这里还是强调一点，html只负责结构和框架，css才能负责样式，javascript负责行为。 特别重要的2个标签*&lt;div&gt;容器&lt;/div&gt;&lt;span&gt;容器&lt;/span&gt;这两个标签没有任何的作用，不像上面讲的那几个标签，可以出现一些效果，但是这两个标签最大的特点就是没有任何特点。举个例子，我们可以将其当做一个书桌中的一个抽屉，我们可以将这些抽屉进行交换，而里面的东西，随着这些抽屉一起移动。使这些功能更加结构化，结构合理，分布较好，可以当成容器来使用，而容器的作用就是结构化和集中化操作。 文字分隔符12345&lt;p&gt;aa&lt;/p&gt;&lt;p&gt;a a&lt;/p&gt;&lt;p&gt;a a&lt;/p&gt;&lt;p&gt;a&amp;nbsp;a&lt;/p&gt;&lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;a&lt;/p&gt; 在浏览器中，默认将空格当成一个文字分隔符，但是不管空多少，它都只认为是一个文字分隔符。我们来看看效果：当我们需要较多的空时，就需要文字分隔符来帮忙了。还有就是当我们需要在浏览器中显示&lt;div&gt;时，我们发现我们不能在浏览器中显示出来，因为它是关键字，这个时候就需要“&lt;”和“&gt;”上场了，在html中，&gt;&amp;lt;就表示“&lt;”，它就是less than的缩写，也就是小于号。而:&gt;&amp;gt;就代表“&gt;”，它就是great than的缩写，也就是大于号的意思。 好了，今天的这篇 blog就到这里结束了，谢谢大家的观看。*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上！","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"html学习1","slug":"html学习1","date":"2018-09-19T13:21:28.000Z","updated":"2018-10-23T02:43:15.568Z","comments":true,"path":"2018/09/19/html学习1/","link":"","permalink":"http://moreluckily.com/2018/09/19/html学习1/","excerpt":"","text":"html是什么html css javaScript 并称WEB前端的三剑客，那它们具体的作用是什么呢？用比较专业的词汇说就是html负责结构，css负责样式，javaScript（缩写为js，以后都用缩写来对其进行介绍）负责行为。进行开发首先需要下载编程工具，在这里我推荐使用Sublime2或者Sublime3 或者Visual Studio Code（简称VS Code），在这里博主使用的是VS Code。html是WEB前端的基础，也是最简单的，html的全称是htperText markup language!!!中文翻译就是超文本链接语言，它是由一对一对的标签组成的。例如：&lt;html&gt; &lt;/html&gt;html标签就是根标签它的框架就是：1234&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这里面的head标签是给浏览器看的，就是这里面的内容是对浏览器进行一些定义什么的，而body标签是给用户看的，即这里面写的一些东西就是整个页面的框架。那我们现在就开始写代码，在head标签写以下代码：&lt;title&gt;百度一下&lt;/title&gt;然后点击保存（Ctrl+S），接下来点击鼠标右键，再然后点击Open In Default Browser选项（或者直接使用快捷键A/t+B），就会在自己电脑上默认的浏览器中打开一个网页（在这里我推荐使用Google Chrome 浏览器），但在这时我们会发现出现乱码的现象。这是因为外国的浏览器不能识别中文，这时我们就需要在 head标签里加一个另一个标签了，就是设置浏览器属性，让浏览器能够识别中文，需要加的标签是meta标签，这是一个单标签。&lt;meta charset=&quot;UTF-8&quot;&gt;charset代表了一定的属性，里面可以写比较多的东西，例如：可以在里面加gb2312，它代表的是国家标准，但其只能识别简体字，不能识别繁体字；在其基础上就有了gbk，它既能识别简体字也能识别繁体字；在之后就有了unicode，一般将它称为万国码，但utf-8是它的升级版本，于是我们在这里就使用utf-8了。&lt;html lang=&quot;en&quot;&gt;也就是language=”english”的缩写，这句话的意思也就是告诉搜索引擎爬虫，我们的网站是关于什么内容的。当然这里的en可以用”zh”和“de”等代替，”zh”就是zhongwen的缩写，”de”就是德语的缩写，还要在head标签里写的内容就是：&lt;meta name=&quot;keywords&quot; content=&quot;关键字&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot;&gt;这些信息就是告诉搜索引擎爬虫我们写的浏览器是关于什么内容的，让搜索这些关键字的人能快速的找到我们浏览器并打开它。 我们可以直接在VS Code中输入html:5然后按下Tab键，就可以生成一些基本的信息内容了。就会出现以下的一些基本内容：1234567891011&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这些虽然可以直接生成，但我们需要知道他是怎么来的，不能不求甚解。 好了，今天的blog内容就是这些了，我明天就会向大家介绍html中常见的标签名称和作用。大家晚安，希望大家都不要活成自己讨厌的样子。good night,have a sweet dream.","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"WEB前端介绍","slug":"WEB前端介绍","date":"2018-09-19T12:51:01.000Z","updated":"2018-10-23T02:43:15.537Z","comments":true,"path":"2018/09/19/WEB前端介绍/","link":"","permalink":"http://moreluckily.com/2018/09/19/WEB前端介绍/","excerpt":"","text":"WEB前端介绍首先我们需要知道WEB前端技术能做什么？它能做的东西还是蛮多的，下面我就对其进行一些简单的介绍。 公司官网（在PC通过浏览器来访问公司网站） 移动端网页（在手机上来浏览公司信息、小游戏等） 移动端APP界面（例如：淘宝、去哪儿旅游、携程等） 微信小程序（微信推出的功能，随用随装，不占用手机空间）WEB前端需要掌握的一些技能，其核心要求掌握： 语言技术：JS基础和核心、HTML5、CSS3 框架技术：JQuery、ajax、Bootstrap、AngularJS, React, React Native, Cordova, Hadoop 通讯协议技术：HTTP协议、服务端开发技术, NodeJS 客户端技术：微信开发技术、JS、SDK开发、Web App开发技术下面的blog我将开始对其各个部分进行详细的介绍与教学，OK，这篇blog就先介绍到这里了。期待大家对我接下来blog的支持与喜爱，谢谢大家。","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"大学三年总结","slug":"大学三年总结","date":"2018-09-19T11:46:12.000Z","updated":"2018-10-23T02:43:15.646Z","comments":true,"path":"2018/09/19/大学三年总结/","link":"","permalink":"http://moreluckily.com/2018/09/19/大学三年总结/","excerpt":"","text":"三年的一些感受时光如白驹过隙，稍纵即逝，一晃大学三年就过去了。在这三年中，努力过，奋斗过，笑过，也哭过，成功过，失败过，喜悦过，悲伤过，徘徊过，疯狂过，失落过。在前几天，参加学校的保研面试，但是很难受的是，没有得到学校的保研名额。其中的情况有自己的一部分原因，也用一些学校老师的情况。在这里真的不想说什么了，同时自己确实是挺难过的，努力了三年，最后得到了这个结果无论是谁都会都会有一段低潮期，在失败之后呢？不禁要想自己的未来在哪里呢？找工作或者考研？我的学校并不是985也不是211学校，只是一个普通的一本院校。考上研究生之后呢？我一直在思考这个问题。毕竟大学的出身还是挺重要的，找工作是找本专业的工作还是跨专业找呢？前几天我跑了我们学校的宣讲会，我这个专业说白了就是自动化分出来的一个旁支，对口的工作特别少，要么就是工资太低了，而一些比较好进的国企工资也低，热门的国企又不好进，而且录取的时间特别晚，等它出结果黄花菜都凉了。同时我发现这些公司有一大半都是来自互联网公司，而像我这样的非计算机专业的学生想直接进入这些公司还是太难了。经过了几天的思考，我决定还是进入互联网公司，毕竟这些公司是不看你的出身的，只看你的想法和实力。回顾过去，自己仍然有不少缺点，如创新潜力还不够强，有时候不懂得坚持，但我会尽可能地在以后的学习和生活中着重提高这些方面的潜力，人的一生就是在不断地学习、实践中得到提高、完善的。 大四的计划时光已逝，良晨难在，获取超于失去，何乐而不为，憧憬，是因为新的梦想在开启斗士的豪情！保研失败并不是结束，只是为下一个阶段学习的开始打下基础。此刻，我将重新整装，确定新的目标，迎接下一个阶段的学习。未来之路就在眼前，遥远，需要不断求索。那么就让我们屏弃所有的恐惧，和我一齐上路，为我以后的学习和工作继续创造自己的辉煌。特别喜欢超级演说家刘媛媛的演讲，“人生那么短，我就选择做那种又盲目又热情的傻瓜。永远年轻；永远热泪盈眶；永远相信梦想；相信努力的意义；相信遗憾会比失败更可怕。因为不成功的人生，它只是不完美，但是它完整。”我觉得我应该振作起来，继续努力的开始去学习，去不断的让自己没有时间去思考为什么自己没有保上研，毕竟中国是个人情社会，别人可能没你优秀，但别人在选择老师的实验室选择的好呀。也确实自己还是挺倒霉的，参加的一些比较重要的比赛都没有取得好成绩。在这里还是特别感谢我宝哥，鼓励我激励我，上帝给你关了一道门，可能是想告诉你，孩子啊！我在为你留了一扇窗呢。接下来的日子里，我将会与WEB前端结缘，拿起曾经丢下的一项能在这个社会上立足的技能，为自己的未来再次奋斗杨帆起航。长风破浪会有时，直挂云帆济苍海 。自己肯定能在明年的春招中收获自己胜利的果实，到那时，必定春风得意马蹄疾，一日看尽长安花。","categories":[{"name":"总结","slug":"总结","permalink":"http://moreluckily.com/categories/总结/"}],"tags":[{"name":"-总结","slug":"总结","permalink":"http://moreluckily.com/tags/总结/"}]}]}