{"meta":{"title":"Mr.Wang's blog","subtitle":null,"description":null,"author":"moreluckily","url":"http://moreluckily.com"},"pages":[{"title":"关于博主","date":"2018-09-19T04:46:53.000Z","updated":"2018-09-19T12:52:38.695Z","comments":true,"path":"about/index.html","permalink":"http://moreluckily.com/about/index.html","excerpt":"","text":"关于博主我是Mr.Wang，来自于江西省，景德镇市，在哈尔滨理工大学测通学院测控技术与仪器专业就读大四，在2018年9月19号，正式开始更新自己的blog。言归正传，其实做这个blog的主要目的是，记录自己的生活，分享自己平时学习生活中遇到的问题及经验，同时也当做一种复习。希望以后可以跟大家一起学习交流，共同成长。这就是blog存在的原因，希望能记录、分享我在生活中遇到的难题和我认为比较精彩的内容。包括技术类问题以及为人处事，也希望能帮助一些人解决他们遇到的难题，同时提高自己的表达和总结能力。生活中总是有些东西从别人口中说出来，自己都会觉得很容易，也就那么点东西，没什么值得骄傲，但其实知道一些东西不容易，讲给别人并使其听懂更不容易。 喜欢的句子 Cease to struggle and you cease to live.生命不止，奋斗不息。 You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.你不能改变你的过去，但你可以让你的未来变得更美好。一旦时间浪费了，生命就浪费了。 The harder you work, the luckier you will.越努力越幸运 有志者事竟成，破釜沉舟，百二秦关终属楚；苦心人天不负，卧薪尝胆，三千越甲可吞吴。 超级演说家命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，这个故事关于独立，关于梦想，关于勇气，关于坚忍。 人生那么短，我就选择做那种又盲目又热情的傻瓜。永远年轻；永远热泪盈眶；永远相信梦想；相信努力的意义；相信遗憾会比失败更可怕。因为不成功的人生，它只是不完美，但是它完整。 联系博主 博客：www.moreluckily.com 微信号：Wang13677983456 QQ:1328440709"},{"title":"标签","date":"2018-09-19T04:41:56.000Z","updated":"2018-09-19T04:43:56.893Z","comments":true,"path":"tags/index.html","permalink":"http://moreluckily.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-19T04:44:42.000Z","updated":"2018-09-19T04:45:42.669Z","comments":true,"path":"categories/index.html","permalink":"http://moreluckily.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"js的脚本化CSS","slug":"js的脚本化CSS","date":"2018-09-28T08:46:45.000Z","updated":"2018-09-28T11:35:40.365Z","comments":true,"path":"2018/09/28/js的脚本化CSS/","link":"","permalink":"http://moreluckily.com/2018/09/28/js的脚本化CSS/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中脚本化CSS的相关知识。 读写css属性每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。 注意： 1.我们碰到float这样的关键字属性的时候，前面要加一个css前缀。 float—&gt;cssFloat 2.复合属性必须拆解 border: 1px solid red; 这种属性是不允许出现的，只能写border-width、border-color、border-style。 3.当css中的样式是用“-”连接起来的时候，我们要变成小驼峰式写法。 background-color —&gt; backgroundColor; 这个属性只能读写行间样式，我们写在css的样式是不能获取的，因此我们通过这个属性加样式的时候要注意权重值问题。 同时，我们在js中写样式只能往行间里写，永远也写不到css文件里面。 查询计算样式window上面有一个方法叫做getComputedStyle可以来获取元素的计算样式，也就是css样式。 1window.getComputedStyle(ele. null); 这里的样式是取优先级最高的，不只是行间样式，所有的只要是表现出来的样式都可以获取出来。 同时，返回的计算样式的值都是绝对值，没有相对单位。 我们写的background-color: red会返回rgb(255,0,0)，em单位或者百分比的单位都会化成具体的像素值返回。 这个方法有两个参数，第一个参数是我们要获取的元素。 第二个参数是一个字符串，代表我们是否要获取这个元素上面的某一个伪元素，如果不的话，就填写null，否则就填写要获取的这个元素的哪一个伪元素。例如：用来选取伪元素的样式，after和before， 12345678910111213div&#123; width:10em;&#125;div::after&#123; content:&quot;&quot;; width:10px; height:10px; background-color:green; display: inline-block;&#125;var div = document.getElementsByTagName(&apos;div&apos;)[0];window.getComputedStyle(div,&quot;after&quot;) //10px 但是很遗憾的是IE8以及以下的版本不兼容这个方法。 IE8有一个特殊的样式currentStyle。 dom.currentStyle也会返回一个样式表，和上面的基本一样，唯一的区别在于返回的计算样式的值不是经过转换的绝对值，而是我们写什么值就会返回什么值。 现在有了这些方法和属性，我们就可以封装一个兼容性的获取样式的函数了。 12345678function getStyle(obj, prop, fake) &#123; var fake = fake || null; if(obj.currentStyle) &#123; return obj.currentStyle[prop]; &#125;else &#123; return window.getComputedStyle(obj, fake)[prop]; &#125;&#125; 脚本化样式表在document上有一个属性叫做styleSheets，这个属性储存了一个html文档所有的css样式表的集合，我们可以来操作style标签，不过在实际中基本是用不到的，所以这里就不过多介绍了。 最后我们可以写一个让小方块运动的函数： 12345678910111213141516div#demo &#123; width: 100px; height: 100; position: absolute; left: 0; top: 0;&#125; var div = document.getElementById(‘demo’);var timer = window.setInterval(function () &#123; div.style.left = parseInt(getStyle(div, ‘left’)) + 1 + ‘px’; ifparseInt((getStyle(div, ‘left’)) &gt; 1000) &#123; clearInterval(timer); &#125;&#125;, 10); 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的事件的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的滚动条和元素尺寸","slug":"js的滚动条和元素尺寸","date":"2018-09-28T08:45:44.000Z","updated":"2018-09-28T11:23:27.931Z","comments":true,"path":"2018/09/28/js的滚动条和元素尺寸/","link":"","permalink":"http://moreluckily.com/2018/09/28/js的滚动条和元素尺寸/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中滚动条与元素尺寸的相关知识。 滚动条这里需要记住一个常识：所有的W3C标准，IE9以下的浏览器都时具有兼容性问题的。 window.pageXOffset/window.pageYOffset这个方法可以查看滚动条的横轴和纵轴的滚动距离，但是很遗憾的是IE8以及以下的版本不兼容。 因此针对于IE，我们就需要有第二套方法： 123document.body.scrollLeft/doucment.body.scrollTopdocument.documentElement.scrollLeft/document.documentElement.scrollTop 虽然IE可以使用这两个方法，但是这两个方法不仅仅是IE才可以使用。 这里要说明的是，这两种方法要一起使用，因为浏览器的兼容性问题，有的浏览器是document.body有值，有的是document.documentElement有值，但是所有的浏览器都只有一个有值，不会两个都有或者一个都没有，而且这里的没有值不代表是null，而是0，因此我们使用的时候一般都是两个一起使用。 针对兼容性的问题，我们现在就可以封装一个函数，求滚动条滚动距离的方法。 1234567891011121314function getScrollOffset()&#123; if(window.pageXOffset)&#123; return &#123; //w3c标准 x : window.pageXOffset, y : window.pageYOffset &#125; &#125;else&#123; return &#123; x : document.body.scrollLeft + document.documentElement.scrollLeft, Y : document.body.scrollTop + document.documentElement.scrollTop &#125; &#125;&#125;console.log(getScrollOffset())//打印当前的滚动条 查看视口的尺寸视口就是我们的可视区，因为我们改变浏览器的大小的时候会改变可视区的大小，那么我们如何来查看当前浏览器的可视区大小？ 这里我们依然有两套方法： 1window.innerHeight/window.innerWidth; 这个方法可以直接获取到当前可视区的宽高，但是依然很遗憾的是IE8以及以下的版本不兼容。 这个时候就需要第二套方法了： 在标准模式下， 1doucment.documentElement.clientWidth/document.documentElement.clientHeight 在任何浏览器都兼容。 在怪异模式（混杂模式）下， 1document.body.clientWidth/document.body.clientHeight 才能查看视口大小，而不能使用上面标准模式下的方法。 我们如何变成怪异模式呢？ 其实很简单，只需要把我们html代码的第一行的&lt;!DOCTYPE HTML&gt;去掉就可以变成怪异模式了，而加上这一行代码就可以变成标准模式。 如何判断怪异模式还是标准模式？ document上中有一个方法叫做compatMode，当浏览器处于怪异模式的时候会返回字符串“BackCompat”，在标准模式下可以返回“CSS1Compat”，通过这个方法我们就可以判断了。 知道了什么是标准模式和怪异模式以及如何判断的情况下，我们就可以封装一个兼容性的函数，返回浏览器的视口大小。 12345678910111213141516function geteViewpotOffset() &#123; if(window.innerWidth)&#123; return &#123; w : window.innerWidth, h : window.innerHeight &#125; &#125;else if(document.compatMode == &quot;BackCompat&quot;)&#123; return &#123; w : document.body.clientWidth, h : document.body.clientHeight &#125;else&#123; return &#123; w : document.documentElement.clientWidth, h : document.documentElement.clientHeight &#125;&#125; 需要写一个函数，来判断各种数据类型，包括包装类。123456789101112131415161718192021222324function type(target)&#123;var typeStr = typeof(target), toStr = Object.prototype.toString, objStr = &#123; &quot;[object Object]&quot; : &quot;object - Object&quot;, &quot;[object Array]&quot; : &quot;array - Object&quot;, &quot;[object Number]&quot; : &quot;number - Objcet&quot;, &quot;[object Boolean&quot; : &quot;boolean - Object&quot;, &quot;[object String]&quot; : &quot;string - Object&quot; &#125;if(target === null) &#123;//判断null直接 看是不是等于 null即可，利用call会报错 return null;&#125;else if(typeStr === &quot;function&quot;)&#123; return &quot;function&quot;;&#125;if(typeStr === &quot;function&quot;)&#123; return &quot;function&quot;;&#125;if(typeStr !== &quot; object&quot;)&#123; return typeStr;&#125;else &#123; return objStr[toStr.call(target)]; //判断最后的对象 对应的类型。&#125; 查看元素的几何尺寸domEle.getBoundingClientRect()在获取的dom元素上，有一个getBoundingClientRect方法，这个方法可以获取到元素的宽高和左上点的位置以及有下点的位置（width、height、top、left、right、bottom），注意这里的宽高是指除去了margin的盒子模型的宽高。 但是老版本的IE浏览器没有实现width和height，那么我们在老版本的IE计算宽高的时候就需要用bottom-top和right-left来计算宽高值了。 还有一点需要注意的是，这里的宽高也不是实时更新的，数据只是一个副本。 我们依然可以封装一个函数，可以返回元素的宽高。 1234567891011121314Element.getElementOffset() &#123; var objData = this.getBoundingClientRect(); if(objData.width) &#123; return &#123; w: objData.width, h: objData.height &#125; &#125;else &#123; return &#123; w: objData.right - objData.left, h: objData.bottom - objData.top &#125; &#125;&#125; 滚动条滚动让滚动条滚动的方法有三个：scroll、scrollTo、scrollBy。 这三个方法都有两个参数，分别是x值和y值。前两个方法的作用一模一样，都是让滚动条滚动到（x，y）的位置，但是最后一个scrollBy有一些区别，它是让滚动条相对于上一个位置滚动多少距离。 我们可以简单的用这个方法来实现一个自动阅读的功能： 123456789101112131415161718192021222324252627&lt;button style=&quot;width:50px;height:50px;border-radius:50%;box-shadow:1px 2px 3px #000;background:red;opacity:0.7;position:fixed;bottom:150px;right:50px;&quot;&gt;start&lt;/button&gt;&lt;button style=&quot;width:50px;height:50px;border-radius:50%;box-shadow:1px 2px 3px #000;background:yellow;opacity:0.7;position:fixed;bottom:50px;right:50px;&quot;&gt;stop&lt;/button&gt;&lt;button style=&quot;width:50px;height:50px;border-radius:50%;box-shadow:1px 2px 3px #000;background:orange;opacity:0.7;position:fixed;bottom:250px;right:50px;&quot;&gt;speed&lt;/button&gt; var start = document.getElementsByTagName(&apos;button&apos;)[0];var stop = document.getElementsByTagName(&apos;button&apos;)[1];var su = document.getElementsByTagName(&apos;button&apos;)[2];var speed = 1;var timer = 0;var key = true;start.onclick = function()&#123; if(key) &#123; timer = setInterval(function()&#123; window.scrollBy(0, speed); &#125;, 50); key = !key; &#125;&#125;stop.onclick = function () &#123; clearInterval(timer); key = true;&#125;su.onclick = function () &#123; if(speed &lt; 5) &#123; speed ++; &#125;&#125; 得到的效果图如下： 可以操控按钮去控制自动阅读，可以加速和停止等操作。 另一个查看元素尺寸的方法dom.offsetWidth/dom.offsetHeight虽然前面有一个ele.getBoundingClientRect()方法，但是由于这个方法名字是在太长了，因此用的并不是非常多，相比较而言，这两个dom元素的属性用的更多一些。 这里获取的宽高值和上面的一样，都是除去margin后的盒子模型的宽高。 查看元素的位置dom.offsetLeft/dom.offsetTop这两个值分别是元素距离左侧和上侧的距离，这里的值是相对于有定位的父级而言的，如果没有有定位的父级的话，才是相对于文档的坐标。 那么现在就来了一个问题：如何找到有定位的父级呢？ domEle上面还有一个属性是offsetParent，这个属性可以查看到元素的有定位的父级，如果没有的话就会返回body，而body的offsetParent则是null。 我们利用上面的信息，可以来封装一个函数，求元素的相对于文档的坐标。 1234567891011121314151617181920Element.prototype.getPosition = function ()&#123; if (!this.offsetParent)&#123; return &#123; “w”: this.offsetLeft, “h”: this.offsetTop &#125; &#125; var width = this.offsetLeft, height = this.offsetTop, ele = this.offsetParent; while (ele.offsetParent)&#123; width += this.offsetParent.offsetLeft; height += this.offsetParent.offsetTop; ele = ele.offsetParent; &#125; return &#123; “w”: width, “h”: height &#125;&#125; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的脚本化CSS相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的日期和定时器","slug":"js的日期和定时器","date":"2018-09-28T08:43:38.000Z","updated":"2018-09-28T08:49:12.001Z","comments":true,"path":"2018/09/28/js的日期和定时器/","link":"","permalink":"http://moreluckily.com/2018/09/28/js的日期和定时器/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中日期对象和定时器的相关知识。 封装一个函数insertAfter(),功能类似于insertBefore()上篇的blog说过了关于insertBefore(a,b)的方法，父级调用，在a之前插入b.那么对于这个insertAfter(a,b)方法也是类似的，也是有父级调用，在a后面插入b。了解了功能之后，我们就要开始实现了。由于手头上方法，也就那么一个 insertBefore()，利用它我们可以进行插入的操作。但是，在插入之前，我们需要找到插入节点的位置，那么我们怎样才能找到需要进行插入操作得节点呢？请看以下分析： 12345&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;a&gt;&lt;/a&gt;&lt;/div&gt; 如果我们需要在em标签后面插入节点，就相当于在a标签之前插入节点，他们两个是等价的，所以，我们就可以利用这个思维，先找到想插入的节点a的下一个兄弟节点b，然后对b节点调用insertBefore方法，在b之前插入目的节点，那么就相当于在a之后插入了一个目标节点了。 明白了这个问题之后，我们还需要判断他是否有兄弟节点，如果存在，就调用insertBefore，如果没有就进行appendChild即可。代码如下： 12345678Element.prototype.insertAfter = function (target,afterNode)&#123; var siblingNode = afterNode.nextElementSibling; if(siblingNode)&#123; this.insertBefore(target, siblingNode); &#125;else&#123; this.appendChild(target); &#125;&#125; 我们来实验一下，看一下这个封装的方法对不对。 12345678910var p = document.createElement(&apos;p&apos;);//创建一个p标签var div = document.getElementsByTagName(&apos;div&apos;)[0];var span = document.getElementsByTagName(&apos;span&apos;)[0];var em = document.getElementsByTagName(&apos;em&apos;)[0];var a = document.getElementsByTagName(&apos;a&apos;)[0];div.insertAfter(p, a);//p标签去a标签的后面console.log(div);//p标签去a的后面了div.insertAfter(p, span);console.log(div);//p标签去span的后面了 封装remove()函数，使得child.remove()可以销毁自身。在原型链上对其进行操作：1234Element.prototype.remove = function () &#123; var parent = this.parentNode; parent.removeChild(this);&#125; 这个问题的代码其实很简单，只要找到这个元素的父级，然后让父级删除掉这个元素就可以了。 将目标节点内部的节点顺序逆序。123&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt; --&gt; (逆转)&lt;div&gt;&lt;a&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; 对于这个题目，是利用我们插入的元素如果是本身就存在的，那么就会剪切到新的位置上这个特性来做的。 其实就是将倒数第二个标签，放在最后一个位置，然后倒数第三个标签其实还在倒数第三个标签的位置，然后将倒数第三个标签放在最后一个位置。依次类推： 12345678910111213Element.prototype.reverseElement = function()&#123; var len = this.childNodes.length, child, first = this.firstChild; for (var i = 0; i &lt; len - 1; i++)&#123; child = this.lastChild; this.insertBefore(child, first); &#125;&#125;var p = document.getElementsByTagName(&apos;p&apos;)[0];var div = document.getElementsByTagName(&apos;div&apos;)[0];var a = document.getElementsByTagName(&apos;a&apos;)[0];console.log(div.reverseElement());//就会逆序 静态类JavaScript慢慢发展向面向对象，朝向Java方向，原型，继承等都是面向对象的，慢慢就摒弃面向过程编程。当我们想使用某些方法的时候，通常可以使用new进行构造出来，或者直接使用 原型链上的方法，这种形式的就叫动态的方法。例如： 12345function Person()&#123; this.aaa = function() &#123; &#125;;&#125;var demo = new Person();demo.aaa();//调用方法 这种就叫做动态类。 后来有些方法不需要这么麻烦的方法，每次都去生成一个对象。有些很简单的就不需要这样操作。例如Math方法：Math.random,Math.sqrt。这样的方法其实是直接挂在一个对象上面可以直接调用。 12345Math = &#123; random: function() &#123; &#125;, sqrt: function() &#123; ], .........&#125;//可以直接调用 日期对象日期对象的各种方法和用法在w3c上有详细的介绍。 日期对象也是javascript的内置对象之一，我们可以直接使用。 123var data = new Data();Date();// &quot;Fri Sep 28 2018 11:23:56 GMT+0800 (中国标准时间)&quot; |Date()|返回当日的日期和时间。|//date.getDate()//28|getDate()|从 Date 对象返回一个月中的某一天 (1 ~ 31)。||getDay()|从 Date 对象返回一周中的某一天 (0 ~ 6)。||getMonth()|从 Date 对象返回月份 (0 ~ 11)。|//要自己加一|getFullYear()|从 Date 对象以四位数字返回年份。||getYear()|请使用 getFullYear() 方法代替。||getHours()|返回 Date 对象的小时 (0 ~ 23)。||getMinutes()|返回 Date 对象的分钟 (0 ~ 59)。||getSeconds()|返回 Date 对象的秒数 (0 ~ 59)。||getMilliseconds()|返回 Date 对象的毫秒(0 ~ 999)。||getTime()|返回距1970年1月1日凌晨的毫秒数| |getTime()|返回距1970年1月1日凌晨的毫秒数|纪元时间,计算机查现在到这个时候得时间,然后返回今天的时间.通常是两个getTime联合使用，求时间差。 123456var firstTime = new Date().getTime;for(i = 0; i &lt; 100000000; i++)&#123;&#125;var lastTime = new Date().getTime;console.log(lastTime - firstTime)//这个可以求出来程序的执行时间。 第二个作用就是作为时间戳：每一次发的请求都是不一样的，利用它可以做唯一表识。 Date.parse( ) : 注意它是用Date作为调用对象，参数是必须的，将参数转化为毫秒数。 |setDate()|设置 Date 对象中月的某一天 (1 ~ 31)。||setMonth()|设置 Date 对象中月份 (0 ~ 11)。||setFullYear()|设置 Date 对象中的年份（四位数字）。||setYear()|请使用 setFullYear() 方法代替。||setHours()|设置 Date 对象中的小时 (0 ~ 23)。||setMinutes()|设置 Date 对象中的分钟 (0 ~ 59)。||setSeconds()|设置 Date 对象中的秒钟 (0 ~ 59)。||setMilliseconds()|设置 Date 对象中的毫秒 (0 ~ 999)。||setTime()|以毫秒设置 Date 对象。| 123456789设置时间，在哪个时间干别的事var date = new Date();date.setSeconds(date.getSeconds() +20); //设定时间 setInterval(function () &#123; if(Math.abs(new Date().getTime() - date.getTime()) &lt; 500 )&#123; console.log(&apos;coming&apos;); &#125;&#125;, 500);//程序到了规定时间将会打印出coming。 Js定时器一个常识：浏览器会每隔16毫秒刷新页面一次 setInterval(); //定时clearInterval(); //清除定时 这些方法都是定义在window对象上面的，因此我们写window.setInterval和解setInterval的意思是一样的，前面的window可以省略掉。 setInterval这个定时器的功能是每过一段时间，就把我们想要执行的函数放到js的执行队列中等待执行。因为执行队列不一定是空的，需要等执行队列中的所有任务都执行完之后才会执行我们的函数，因此这个函数执行的时间也会有细微的差别。 这个方法的语法是： 1setInterval(function () &#123;&#125;, 1000); 第一个参数是我们要执行的函数，第二个参数是每过多长时间把函数放入执行队列。 这里要说明的是，第一个参数的那个函数，不能带有参数。其次，里面的this默认指向window，因为前面提到过，谁调用方法，方法里面的this就指向谁，setInterval其实前面省略了window，因此里面的this默认一定指向window，不论这个setInterval是否是一个对象的方法。 setInterval其实很消耗内存，这个定时器一旦执行，就不会终止，因此需要我们的内核一直监听这个函数。 这个时候我们就需要一个方法来清除定时器了：clearInterval。 定时器其实会返回一个标记，我们可以通过定时器的这个标记来清除掉相对应的定时器。 1234567var i = 0;var timer = setInterval(function () &#123; console.log(i++); if(i &gt; 10)&#123; clearInterval(timer);//清除定时器 &#125;&#125;, 1000); //在1000ms左右 这个函数的功能就是每1000ms打印一个数字i，当i大于10时，就会清除定时器，也就是打印出了0~10。 这里有一点需要特别强调：凡是写定时器，一定要清除定时器！ 还有一点需要注意的是，定时器是先等待再执行。 有时候我们只需要这个函数延迟一段时间执行，并不需要专门开启一个定时器，这个时候就需要用到setTimeout了。 setTimeout是延迟执行的意思，语法和用法和setInterval一样，只是这个方法只是把函数延迟一段时间之后执行一次而已。比较常见的就是看电影的试看功能。 同时它也有clearTimeout，当我们不想让这个函数执行了，提前把它clear掉就可以了。 其实setInterval和setTimeout的第一个参数不一定非要是一个函数，它也可以是一串字符型的js代码。 1setInterval(“console.log(1);”, 100); 这段代码同样可以执行，定时器每100ms给我们打印一个1。 通过这个特性，我们不一定要把函数写在定时器里面，大部分时间我们都是在外部把函数定义好了，然后直接把函数名传进去就可以了。 12function test () &#123;&#125;setInterval(test, 1000); 写一个计时器，到三分钟停止123456789101112131415161718192021222324252627&lt;style&gt; input&#123; border: 1px solid rgba(0,0,200,0.5); text-align: right; &#125;&lt;/style&gt;minute:&lt;input type=&quot;text&quot; value=&quot;0&quot;&gt; second:&lt;input type=&quot;text&quot; value=&quot;0&quot;&gt; var minuteNode = document.getElementsByTagName(&apos;input&apos;)[0];var secondNode = document.getElementsByTagName(&apos;input&apos;)[1];var minute = 0;var second = 0;var timer = 0;timer = setInterval(function() &#123; second ++; if(second == 60) &#123; minute += 1; second = 0; &#125; minuteNode.value = minute; secondNode.setAttribute(&apos;value&apos;,second); if(minute == 3)&#123; clearInterval(timer); &#125;&#125;, 10); 得到的结果如下图所示： 就是右边的没个10ms计一个数，当超过60个数时，左边的数加一，右边的数又从0开始计数，等左边的数为3使，停止计数。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的滚动条与元素尺寸相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的DOM操作续","slug":"js的DOM操作续","date":"2018-09-27T15:25:10.000Z","updated":"2018-09-27T16:36:36.720Z","comments":true,"path":"2018/09/27/js的DOM操作续/","link":"","permalink":"http://moreluckily.com/2018/09/27/js的DOM操作续/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中DOM基本操作续的相关知识。 DOM基本操作续createElement创建元素节点: 我们可以通过:1document.createElement(‘div’); 这个方法来创建一个元素，里面的参数填写我们要创建的标签名称，像div、p、span等等。 createTextNode创建文本节点: 我们可以通过:1document.createTextNode(‘abcd’) 方法来创建一个文本节点，里面的参数填写我们的文本内容。 createComment创建注释节点: 我们可以通过:1document.createComment(‘comment’); 方法来创建一个注释节点，参数写我们要写的注释内容。 createDocumentFragment这个方法可以创建一个文档碎片，有关提高性能的部分会用到这个方法。 插入操作appendChild(child);这个是父级调用的方法，它会将child元素插入到父级里面，而且是放到逻辑后面的位置上。 12div.appendChild(text);div.appendChild(comment); 这里如果是我们创建的元素，那么appendChild就是把新元素插入进去，但是如果是DOM里面已经存在的元素，那么appendChild就是把这个已经存在的元素给剪切掉，然后放到新的位置上。 insertBefore(a, b);这个依然是父节点调用的方法，它的意思是将a插入到b前面的位置上，其中b要求是这个父级的子节点。这个方法可以记作为 insert a before b; 12var span = document.createElement(‘span’);div.insertBefore(span, comment); 这样我们就把一个span元素插入到了刚才的注释文本前面。 删除操作removeChild这个方法依然是父级调用的，参数就是要删除的子节点，其实实际上是剪切，这个方法会把我们删除掉的元素给返回，我们可以用一个变量去保存这个被删除的元素。 1var div = document.body.remove(div); 这样我们的div变量就可以保存刚才被删除的div这个元素。 替换操作replaceChild(new, origin)这个方法同样是父级调用，用新的元素new来替换原来的origin元素，原来的被替换掉的元素可以被返回，我们可以像删除操作那样用一个变量来保存。 现在我们就可以通过以上这些方法来动态创建一棵DOM树了。 下面介绍一些Element节点的属性和方法： innerHTML这个属性可以用字面意思来理解，元素里面的HTML结构。 1div.innerHML = ‘&lt;div&gt;123&lt;/div&gt;’; 我们可以直接通过这个属性来改变元素内部的结构和内容，不过注意它会直接删除掉以前的所有结构，如果以前内容还有其他的节点的话，使用的时候就要小心了。 1234demo.innerHTML = &apos;&lt;p&gt;\\ &lt;span&gt;&lt;/span&gt;\\&lt;/p&gt;&apos;;//不能有空格，加\\ 拷贝的时候注意，不能有空格。 innerText/textContentinnerText老版本的火狐浏览器不兼容，textContent老版本的IE浏览器不兼容。 这个属性可以直接调出来元素内部的文本信息，若果这个元素还有很多的子元素的话，那么会把子元素里面的文本信息一起返回。 不过需要注意的是，如果我们要改写innerText或者textContent的话，它会像innerHTML一样，先把内部的所有html结构先删除掉，然后再写入text文本，因此里面有html结构的时候写入也要小心。 这里提一下，如果我们有很多字符串要添加到一个元素的内部的话，虽然用innerHTML或者innerText方法，但是却不是用innerHML += str的方法，因为+=操作符的效率极低，当字符串很多的时候会非常非常消耗性能。 遇到这种情况我们一般是用数组的join方法将字符串全部连接成一个字符串，然后一次性写入innerHTML。 ele.setAttribute();这个方法可以设置元素的属性（特性），比如class、id等一些行间属性。 1div.setAttribute(‘id’, ‘demo’); 这个操作就可以给div这个元素设置一个叫做demo的id。 ele.getAttribute();这个方法是获取元素的行间属性。同样这里需要提一下，每个元素自带的行间属性都有自己特殊的功能，而我们通过自己给他们设置的属性并没有任何功能，因此我们可以来赋予他们功能和用处。还有一点，我们在后面改变元素的样式的时候，通常不是直接修改他的css样式，而是事先写好它应该变成的样式，然后装进一个class里面，我们直接修改他的类名而不是css样式。 12345&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;demo.setAttribute(&apos;sex&apos;, &apos;male&apos;);demo.setAttribute(&apos;clickTimes&apos;, &apos;10&apos;);console.log(demo.getAttribute(&apos;id&apos;));//democonsole.log(demo.getAttribute(&apos;clickTimes&apos;));//10 请编写一段JavaScript脚本生成下面这段DOM结构。要求：使用标准的DOM方法或属性。其实就是用DOM动态生成这样一个结构： 123&lt;div class=”example”&gt; &lt;p class=”slogan”&gt;HelloWorld&lt;/p&gt;&lt;/div&gt; 比较麻烦的写法就是： 12345678var div = document.createElement(‘div’),p = document.createElement(‘p’),text = document.create(‘HelloWorld’);div.setAttribute(‘class’, ‘example’);p.setAttribute(‘class’, ‘slogan’);p.appendChild(text);div.appendChild(p);document.body.append(div); 不过这里有点小提示，节点的className属性可以读写操作class。 因此这里我们为标签赋类名的值的时候可以不用setAttribute，可以直接用className。 12div.className = ‘example’;p.className = ‘slogan’; 不过，还有一个最取巧的办法，那就是直接用innerHTML。 1div.innerHTML = &lt;p class=“slogan”&gt;HelloWorld&lt;/p&gt; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的日期对象相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的DOM结构树","slug":"js的DOM结构树","date":"2018-09-27T15:24:27.000Z","updated":"2018-09-27T16:38:37.277Z","comments":true,"path":"2018/09/27/js的DOM结构树/","link":"","permalink":"http://moreluckily.com/2018/09/27/js的DOM结构树/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中DOM结构树的相关知识。 DOM结构树 这个图表中说明了每一个对象的父级。 123456//Document -&gt; 是一个构造函数 -&gt; 但是用户不能newdocument.__proto__ === HTMLDocument.prototype; //true//HTMLDocument.prototype -&gt; &#123;__proto__: Document.prototype&#125;//Document.prototype -&gt; &#123;__proto__: Node.prototype&#125;Node.__proto__.__proto__.__proto__ --&gt; object 浏览器除了可以处理html页面外，还可以处理xml和xhtml等页面。 我们发现HTMLDocument继承自HTMLDocument.prototype，我们在原型上定义一个属性来测试一下。 123HTMLDocument.prototype.abc = 123;document.abc; // 123document.getElementById(‘demo’).abc; // 报错 由此可见，HTMLDocument确实继承HTMLDocument对象的属性，但是相对的Element上面并没有这个方法。 这里的Node上面也还是有父级的，我们可以通过Node.prototype来查看，这里就不举例了。Node的原型链终端指向我们熟悉的Object。 Element：构造出html元素，包括各种head标签，body 元素等，它们的元素都继承自对应的父级的方法，意思是，HTMLheadelement的方法，只能允许HeadElement使用，其他元素节点不可以使用。 下面是一些DOM结构树的总结： DOM树总结*1、getElementById方法定义在Document.prototype上，意思就是document下的所有元素的都能使用，其他层级下就不行，例如Element节点上不能使用。 2、getElementByName方法定义在HTMLDocument.prototype上，非html中的document不能使用(xml document、Element); 3.getElementsByTagName方法定义在Document.prototype和Element.prototype上，也就是document和元素都可以用这个方法。 4.HTMLDocument.prototype上定义了一些常用的属性，body、head分别代指HTML文档中的bode,html标签。 12document.body //直接能用document.head // 直接能用 5.Document.prototype上定义了documentElement属性，指代文档的根元素，在html文档中，它总代指html元素。 1docuent.documentElement //特指html 6.getElementByClassName、querySelectorAll、querySelector在Document、Element类中均有定义。 DOM的基础练习代码前面介绍了DOM的一些基础的知识，整理一下有关其知识点的封装函数。 遍历元素节点树，要求不能用children属性123456789101112function retChildren(node)&#123; var child = node.childNodes; var len = child.length; var arr = []; for (var i = 0; i &lt; len; i++)&#123; if(child[i].nodeType === 1)&#123; arr.push(child[i]); &#125; &#125; return arr;&#125; 拿出一层树，循环遍历父节点，求子节点的的子节点，层层递归即可 封装函数，返回元素e的第n层祖先元素。123456789101112131415&lt;div&gt; &lt;strong&gt; &lt;em&gt; &lt;span&gt;123&lt;span&gt; &lt;/em&gt; &lt;/strong&gt;&lt;/div&gt;var span = document.getElementsByTagName(&apos;span&apos;)[0];function retParent(e, n)&#123; while(e || n)&#123; //如果n太大，e为null，为了兼容，先判断e是否存在。 e = e.parentElement;//寻找父节点,并赋值给自己，下一圈循环直接使用。 n --; &#125; return e;&#125; 封装成函数： 12345678910function retParent(e, n) &#123; var n = n || 0; // 进行简单的容错检测 if(n === 0) &#123; return e; &#125; for(var i = 0; e &amp;&amp; i &lt; n; i++) &#123; e = e.parentNode; &#125; return e;&#125; 封装函数，返回元素e的第n个兄弟元素节点，如果n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己123456789101112131415161718192021function retSibling(e,n)&#123;//兼容IE var nodeSibling = e; while (nodeSibling &amp;&amp; n)&#123;//利用循环控制圈数 if (n&gt;0) &#123; if(nodeSibling.nextElementSibling)&#123;// 如果不是ie浏览器 nodeSibling = nodeSibling.nextElementSibling; &#125;else&#123; // 如果是ie浏览器 for(nodeSibling = nodeSibling.nextElementSibling; nodeSibling &amp;&amp; nodeSibling.nodeType !== 1; nodeSibling = nodeSibling.nextElementSibling); &#125;//利用for循环执行流程解决，判断是否为Element节点，而且判断存在的时候才能赋值（因为存在null的情况） n --; &#125;else&#123; if (nodeSibling.previousElementSibling) &#123; nodeSibling = nodeSibling.previousElementSibling; &#125;else&#123; for(nodeSibling = nodeSibling.previousElementSibling; nodeSibling &amp;&amp; nodeSibling.nodeType !==1;nodeSibling = nodeSibling.previousElementSibling); &#125; n ++; &#125; &#125; return nodeSibling;&#125; 封装函数，实现children功能，在原型链上编程123456789101112131415Element.prototype.myChildren = function () &#123; var myChildNodes = this.childNodes, len = myChildNodes.length, arr = &#123; //高级写法 仿一个类数组 length : 0, splice : Array.prototype.splice, push : Array.prototype.push, &#125;; for(var i = 0; i &lt; len; i++)&#123; if(myChildNodes[i].nodeType == 1)&#123; arr.push(myChildNodes[i]); &#125; &#125; return arr;&#125; 判断元素节点，非元素节点扔掉。 自己封装hasChildren()方法，不可用children属性12345678910Element.prototype.myChildren = function () &#123; var myChildNodes = this.childNodes, len = myChildNodes.length; for(var i = 0; i &lt; len; i++)&#123; if(myChildNodes[i].nodeType == 1)&#123; return true; &#125; &#125; return false;&#125; 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中DOM基本操作续的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的DOM操作","slug":"js的DOM操作","date":"2018-09-27T15:24:10.000Z","updated":"2018-09-27T15:28:16.541Z","comments":true,"path":"2018/09/27/js的DOM操作/","link":"","permalink":"http://moreluckily.com/2018/09/27/js的DOM操作/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中DOM的相关知识。 DOM什么是DOM呢？ DOM的全称是Document Object Model 文档对象模型，DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。 DOM对象即为宿主对象，由浏览器厂商定义，用来操作html的css功能的一类对象和集合。不过浏览器厂商之间大部分都遵循w3c标准。 简单来说，DOM就是用来操作html和css的，它是一系列对象的集合。 为什么要用DOM？JS不能直接操作html，但是浏览器提供了一类对象，这些对象可以作为js操作html的桥梁，也就是说这类对象中有方法和属性，对方法和属性的调用与修改都会映射到html对应的标签中。 DOM操作：按照文档对象模型 （这些固定的方法和规则）操作标签，这里首先要说一下document这个老大哥，它是JS操作HTML标签的开始，无论你是要获取标签还是创建新标签都需要它。 DOM如何操作HTMLdocument代表整个文档，它也是一个dom元素，我们dom对html的操作，即使对html的增删改查。下面我就介绍一下dom都是如何增删改查html的。 那么我们如何查看元素节点？ 我们知道css中有id、class、标签等选择器，同样，我们的document对象上也定义了很多类似的方法来查看元素节点。 getElementById1234&lt;div id=&quot;only&quot;&gt;&lt;/div&gt;document.getElementById(&apos;id&apos;);//或者document.getElementById(&apos;only&apos;); 通过元素的id来选择出相对应的元素的，因为id是唯一标示，所以方法名中是Element。通过id选出来的对象只有一个对象。 值得注意的是，在ie8以下的浏览器中，不区分大小写，而且标签的name属性也可以被当做id被选择出来。 12&lt;div name=&quot;only&quot;&gt;&lt;/div&gt;document.getElementById(&apos;only&apos;); 这里同样能把这个div选择出来了。 getElementsByClassNamedocument.getElementsByClassName(&#39;class&#39;); 获取到的是一个类数组，因为很多元素都可以有一个类名。我们可以通过[ ]的方式来选择到具体的哪一个元素。 123&lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;&lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;var div = document.getElementsByClassName(&apos;demo&apos;)[0]; 这样我们就可以选择到第一个div了。 那如果碰到下面这种情况怎么办呢？ 123&lt;div class=&apos;demo&apos;&gt;&lt;/div&gt;&lt;div class=&apos;demo demo1&apos;&gt;&lt;/div&gt;&lt;div class=&apos;demo1&apos;&gt;&lt;/div&gt; 在这里，我们的getElementsByClassName其实后面可以填写多个类名。 1var div = document.getElementsByClassName(&apos;demo demo1&apos;)[0];//一定要选[ ] 这样，我们就可以选择出来第二个div了。 但是值得注意的是，ie8及以下的版本中没有这种方法。 getElementsByTagName1document.getElementsByTagName(&apos;div&apos;); 返回的是一个类数组。简单判断选择出来的是一个还是一组，可以看Element后面有没有s有就是一组，没有就是一个。当选出来是一组的话，想操作单个对象，就需要在后面加[ ]。 123456&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;var li = document.getElementsByTagName(&apos;li&apos;)[0]; //单独选出来第一个li元素。 getElementsByName1document.getElementsByName(); 只有部分标签的name可以生效，比如：表单、表单元素、img、iframe等。需要注意的是：div就是没有name属性的。 12&lt;input name=&apos;123&apos;&gt;document.getElementsByName(&apos;123&apos;)[0]; 同样是选择出来一组，不过这个方法不是很常用。有些情况要跟后端进行数据传输的时候就需要用到。 querySeletor()和querySelectorAll()12document.querySeletor();//选出一个document.querySelectorAll();//选出一组 我们知道选择元素最强的是css，而这两个里面写的参数就是我们css选择器的写法。 1234567&lt;div&gt; &lt;em class=&quot;abc&quot;&gt;&lt;/em&gt; &lt;span class=&apos;abc&apos;&gt; &lt;em class=&quot;abc&quot;&gt;123&lt;/em&gt; &lt;/span&gt;&lt;/div&gt;var emEle = document.querySelector(&quot;div .abc span em&quot;); 不过querySelector永远选择一组里面的第一个，所以返回的不是一个类数组而是一个具体的元素。 而我们如果要返回一个类数组的集合的话，那么就用第二个querySelectorAll()方法。 不过这两个方法的问题在于，他们返回的不像前面四个是一个实时改变的元素，而是一个副本。当我们用这两个方法选择出来元素之后，我们把本身那个元素修改一下，会发现我们选择出来的那个元素没有变化。 12345678&lt;div class=”content”&gt;111&lt;/div&gt;&lt;div class=”content”&gt;222&lt;/div&gt;&lt;div class=”content”&gt;333&lt;/div&gt;var div = document.querySelectorAll(‘.content’);var div1 = document.getElementsByClassName(‘content’)[0];console.log(div);div1.remove();console.log(div); 我们发现两次打印出来的都是[div.content, div.content, div.content]，也就是说我们实际删除的那个元素对用querySelector选择出来的那个副本没有影响。 不过，在ie7及以下的版本没有这两个方法。 1这里面我们我们最常用的是id和tag 节点节点类型我们页面里面的节点类型很多，比如元素节点、文本节点、注释节点、属性节点等等。 我们可以通过nodeType属性这个来查看这个节点的类型是什么。而nodeType返回的是一些数字，下面介绍几个基础的类型和数字的对应关系： 123456元素节点——1属性节点——2文本节点——3注释节点——8document——9DocumentFragment——11 节点的其他属性nodeName这个属性可以返回元素的标签名，以大写的形式表示，只读，不允许写入!!! 有几个特殊的节点返回的也不太一样： 123文本节点–&gt; #text注释节点–&gt; #commentdocument节点–&gt;#document nodeValueText节点或者Comment节点的文本内容，可以读写。能修改，能查询。 attributes把元素的行间属性都读取出来，放到一个对象里面返回，对象里面的每一个属性都是一个节点，这个节点就是我们前面提到的属性节点。 注意：对象里面的属性叫做property，而元素里面的属性叫attributes，实际应该叫特性。 1234&lt;div style=&quot;width: 100px; height: 100px;&quot; class=&quot;demo&quot; &gt;var div = document.getElementByTagName(&apos;div&apos;)[0];div.attributes // NamedNodeMap&#123; 0:style,1:class, length:2&#125;div.attbributes[0] //style = &quot;width:100px;height:100px;&quot; 节点还有一个方法： hasChildNodes( )可以检测是否有子节点。 遍历节点树parentNode 查找父节点123&lt;div&gt; &lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt; 这里strong的父节点就是p，p的父节点是div，div的父节点是body，body的父节点是html，html的父节点是document，document的父节点是null，在后面就没有了。 childNodes 子节点们childNodes 没有说明类型，那么就是说这个方法是把所有的子节点都返回。 123&lt;div&gt; &lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt; 我们div里面的childNodes其实有3个，第一个是前面的空格——文本节点，第二个是中间的p标签——元素节点，第三个是最后的空格——文本节点。 firstChild 第一个子节点lastChild 最后一个子节点nextSibling 下一个兄弟节点previousSibling 上一个兄弟节点以上这些方法的兼容性都很好，所有的浏览器都支持，但是下面这些就不行了。 基于元素节点树的遍历parentElement 返回当前元素的父元素节点，在这个方法上面，html上面的父元素节点就不是document而是null了。因为document自成一类，不是元素节点。 但是ie不兼容。 children所有子元素节点，这个方法所有的浏览器都兼容。 childElementCount1node.children.length === node.childElementCount 这个属性就是子元素节点的数量，不过更常用的是前面的那个。 nextElementSibling和previousElementSibling返回后一个/前一个兄弟元素节点（IE不兼容) firstElementChild和lastElementChild返回第一个/最后一个兄弟元素节点（IE不兼容) 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中DOM结构树的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的类数组","slug":"js的类数组","date":"2018-09-26T12:30:03.000Z","updated":"2018-09-26T14:48:38.771Z","comments":true,"path":"2018/09/26/js的类数组/","link":"","permalink":"http://moreluckily.com/2018/09/26/js的类数组/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中类数组的相关知识。 类数组类数组本质上是一个对象，只是它用对象来模拟出数组的效果，我们把这种对象叫做类数组。我们前面提到的arguments实参列表就是一个类数组。类数组不具备数组的一些方法。举个例子： 12345function test()&#123; arguments.push(1);&#125;test(1,2,3,4,5,6)//会报错 它的原型指向的是Object。而数组原型指向的是Array。它只是长的像数组。 123456789var obj = &#123; &quot;0&quot; : 0, &quot;1&quot; : 1, &quot;2&quot; : 2, &apos;length&apos; : 2, &apos;push&apos; : Array.prototype.push&#125;obj.push(5); //&#123;0: 0, 1: 1, 2: 5, length: 3, push: ƒ&#125;obj[0]//0 我们会发现它自动改变了length值，这就非常神奇了。其实类数组的关键就在这个length属性上，如果没有length属性，那么就是一个普通的对象，即使有push方法也不能使用。 现在我们来模拟一下数组的push方法是怎么实现的： 123Array.prototype.push = function (num ) &#123; this[this.length++]. = num;&#125; push方法就是在数组的最后添加一个值，也就是说length的位置加一个元素，然后把length加1，这样我们也就不难理解为什么有了length属性的对象可以调用数组的push方法了，因为它本身带有一个合法的length属性。 现在再来举个例子： 123456789var obj = &#123; &quot;1&quot; : 2, &quot;2&quot; : 3, &apos;length&apos; : 2, &apos;push&apos; : Array.prototype.push&#125;obj.push(&quot;a&quot;);obj.push(&quot;b&quot;);//&#123;1: 2, 2: &quot;a&quot;, 3: &quot;b&quot;, length: 4, push: ƒ&#125; 这里的length是2，所以一开始push(‘a’)的时候把obj[2]改成了a，因为本身没有2这个下标，然后length变成了3，push(‘b’)之后，obj里没有’3’，就在这里加’3’，然后obj[3]变成了‘b’，，然后把length变成4。 三目运算符形式：判断语句? 若为真，执行，并返回结果：若为假，执行，并返回结果三目运算符其实就是简化版的if(){…}else{}语句 1234567var target = true;if (target) &#123; console.log(&apos;a&apos;);&#125;else &#123; console.log(&apos;b&apos;);&#125;&apos;a&apos; 1target?(target正确就返回这个):（不正确就返回这个） 举个例子： 123var target = &apos;1&apos;;target === &apos;1&apos; ? console.log(&apos;a&apos;) : console.log(&apos;b&apos;);//a 来个比较难的题吧。 12345var text = typeof(typeof(undefined)) == &quot;undefined&quot; ? (NaN == NaN ? 0 : 1) : !!false; &quot;undefined&quot; 0 false &quot;string&quot; 1 false 0 text false try…catchtry {} catch (e) {} finally {}一般是用来检测可能出错的问题的。 我们把可能出错的代码块放入try里面，然后把如果出错会产生的反应代码放到catch里面，finally就是挡catch走完之后再走一下finally代码块，finally的用处不是很大。 catch的参数e一定要写上，系统会自动传进去错误信息，错误信息一共有以下6种： 1.EvalError eval()的使用与定义不一致 2.RangeError 数值越界 3.ReferenceError 非法或不能识别的引用数值 4.SyntaxError 发生语法解析错误 5.TypeError 操作数类型错误 6.URIError URI处理函数使用不当 其中3和4比较常见。 当try里面的代码出错了，try里面出错代码后面的代码就不会执行了，但是在try外面的代码还是正常执行的。 12345678910try&#123; console.log(&apos;a&apos;); console.log(&apos;b&apos;); console.log(c); console.log(&apos;d&apos;);&#125;catch(e) &#123; //e是error的缩写 console.log(e.name); //ReferenceError console.log(e.message); //c is not defined&#125; console.log(&apos;d&apos;); //abd ES5严格模式es5的严格模式是一种全新的es5规范，在这个模式下，有一些es3的不标准的规则就不能使用了。 我们只要在代码的第一行写上“use strict”;这一行字符串就可以进入严格模式了，不会对不兼容严格模式的浏览器产生影响。 严格模式主要有两种用法： 1.全局严格模式 2.局部严格模式 全局模式就是我们在整个js代码的第一行写上字符串，而局部模式就是在函数里面的第一行写上字符串。 这里不推荐使用全局严格模式。 严格模式有什么作用？ 1.当我们的代码进入严格模式之后，就不允许使用with函数，arguments.callee方法，func.caller属性。 2.变量赋值之前必须声明。(不能使用未声明的变量) 3.局部的this使用前必须被赋值，除了全局的this默认指向window，其他的默认都是undefiend。而且在非严格模式下，Person.call(null/undefined)之后，里面的this还是指向window，但是如果是严格模式的话，那么传递null，this就指向null，传递undefiend，this就指向undefiend。 4.拒绝重复属性和参数。不过有一些浏览器的属性名可以重复。 1234567891011function text() &#123; console.log(this);//window&#125;text();&quot;use strict&quot;;function text() &#123; console.log(this);//undefined&#125;text();//局部this必须被赋值,赋值什么就是什么 下面介绍一下with方法是什么。 with () {} 的作用是改变作用域链，它可以把括号里面的执行期上下文或者作用域放在自己的作用域链的最顶端。 123456789101112var obj = &#123; a : &quot;abc&quot;&#125;var a = &quot;global&quot;;function test()&#123; var a = &quot;test&quot;; with(obj)&#123; console.log(a);//abc 这个时候，with直接到了obj取a变量。 &#125;&#125;test();//改变作用域链。直接看到最顶端，提供一个执行上下文。很浪费效率，很浪费性能。 用with之后，我们把obj放在了自身上面，成为了最上面的作用域，这样我们打印a，就会优先调用obj里面的a属性，如果有就用，没有的话再向下找第二层test函数的作用域。 好了，今天的这篇blog就到这里结束了，ECMAScript部分就先到这里结束了，后面的主要内容是DOM，大家和我一起加油吧。下节课为大家讲解JS中的DOM相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js中的数组","slug":"js中的数组","date":"2018-09-26T12:29:37.000Z","updated":"2018-09-26T13:58:19.961Z","comments":true,"path":"2018/09/26/js中的数组/","link":"","permalink":"http://moreluckily.com/2018/09/26/js中的数组/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中数组的相关知识。 数组的创建数组的创建基本上只有两种： 1、数组字面量直接创建： 1var arr = [1,2,3]; 2、通过数组构造函数构造数组： 123var arr = new Array(1,2,3);//[1,2,3]var arr = new Array(20);//空数组都是，有20位,表示的是lengthvar arr = new Array(20.1);//会报错 要注意的是，如果我们在构造函数里面只写一个数字new Array(20);这个时候这个数字就不是第一个值是20的意思了，而是我们新创建的这个数组长度是20。 一般情况下都是使用第一种方法直接构建数组字面量。 数组的读写js的数组是弱数据类型的数组，不像其他语言那样严格。不可以溢出读： 12var arr = [1, 2];console.log(arr[3]); //undefined 但是数组是可以溢出写的： 12arr[4] = 4;console.log(arr);//1,2, , ,4 改变数组的方法改变原数组的方法主要有：reverse,sort,push,pop,shift,unshift,splice 1、push（） arr.push( );可以在数组的最后面直接添加数据，可以任意个数，任意类型。 12var arr = [];arr.push(1,2,3,[],&#123;&#125;) 知道了push，我们就可以写一个方法，和它的功能是一样的。 12345Array.prototype.push = function () &#123; for(var i = 0; i &lt; arguments.length; i++)&#123; this[this.length] = arguments[i];//加参数 &#125;&#125; 2、pop（） pop从数组后面剪切一位数据，同时返回这个被删除的数据，没有参数。只能一个一个剪切。 3、shift（） 和pop（）类似，在前面剪切数据，也只能一个一个的剪切。 4、unshift（） 和push（）类似，在前面加数据，也能传多个参数。 5、reverse（）将数组中的数据进行逆转，这个就不多说了。 6、splice（）* splice的英文意思是切片，剪切的意思。 123456789//splice(从第几位开始，剪切多少个长度,在切口处把该值添加进去)；var arr = [1,2,3];arr.splice(1, 1, 100, 200, 300);//[1,100,200,300,3]//剪切的也是一个数组//在1后面加一个0// var arr = [1,2,3];// arr.splice(1,0,0);arr = [1, 0, 2, 3]; 7、sort（）** 这个属性很重要，我们可以用它来进行排序。 1234567var arr = [1,2,4,5,0];arr.sort();//排序[0,1,2,4,5]，升序排列var arr = [1,12,3,4];arr.sort();//[1,12,3,4]//按ASCII码进行排序，不是大小排序 我们可以自定义排序，关注返回值，一旦返回值为负值，那么前面的参数代表的数据就在前面。一旦返回值为正值，那么前面的参数代表的数据就在后面。然后根据返回值，按照上述方法进行排序。 12345678910111213141516171819var arr = [1,12,2,3,4];//自己写一个规则，升序arr.sort(function (a,b) &#123; if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125;&#125;);//arr [1,2,3,4,12] 升序//自己写一个规则，降序 arr.sort(function (a,b)&#123; if(a &lt; b)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;);//arr [12,4,3,2,1]; 降序 这种比较的方式就是冒泡排序，将这些数随机的取2个数去对比(不是随机)，再进行排序,冒泡排序法（重点），冒泡排序法（重点)：我的理解是：先将第一个数和第二个数进行比较，取出较小值，然后将较小值放在第一个数，然后再和后面的比较，最小的放在第一位。然后将第二位的数和后面的每个数比较，取出较小值，一圈一圈的进行对比。…比完之后，就行了。 123456//简化的一种写法：var arr = [1,12,2,3,4];arr.sort(function (a,b) &#123; return a-b;//升序 return b-a;//将序&#125;); 给对象的某个属性进行排序，按ASCII码进行排序： 12345678910111213141516var arr = [ &#123;name:&apos;moreluckb&apos;,age:20&#125;, &#123;name:&apos;moreluckc&apos;,age:10&#125;, &#123;name:&apos;morelucka&apos;,age:30&#125;]//ASCII码进行排序，a&lt;b&lt;c&lt;d...arr.sort(function (a,b) &#123; if(a.name &gt; b.name)&#123; return 1; &#125;else&#123; return -1; &#125;&#125;);//升序排列// &#123;name:&apos;morelucka&apos;,age:30&#125;, &#123;name:&apos;moreluckb&apos;,age:20&#125;, &#123;name:&apos;moreluckc&apos;,age:10&#125; 将正序的数组进行随机打乱排序: 12345var arr = [1,2,3,4,5,6,7];arr.sort(function () &#123; return Math.random() - 0.5;&#125;); //Math.random();//返回随机数,(0,1)//每次比较都是不一样的，而且是乱的 不改变原数组1、concat（） 对两个数组进行连接。并且原数组是不会发生变化的。 1234//arr.concat(): 对两个数组进行连接。var arr = [1,2,3];var arr1 = [4,5,6];var arr2 = arr.concat(arr1); // [1,2,3,4,5,6] 当然我们如果要连接多个数组的话，那么concat里面的数组之间用逗号分隔即可。 12arr3 = [5, 5];arr = arr1.concat(arr2, arr3); 2、toString（） 将数组的每一位转化成字符串并返回。 12var arr = [&#123;&#125;,1,2,true];arr.toString(); // &quot;[object Object],1,2,true&quot; 3、slice（） 12345// arr.slice(第几位开始截，第几位结束)// arr.slice(第几位开始截到最后全部)，负数也可以，从后面开始到最后var arr = [1,2,3];var arr1 = arr.slice(0,1);//[1]var arr2 = arr.slice(1);//[2,3] 4、join（） 将数组按照传进去的符号进行连接，最后转化为字符串返回。默认是逗号连接。 12345//join将数组弄成字符串var arr = [&apos;more&apos;,&apos;&amp;&apos;,&apos;luck&apos;,&apos;&amp;&apos;,&apos;ily&apos;];console.log(arr.join(&quot;&quot;));//more&amp;luck&amp;ilyconsole.log(arr.join(&quot;,&quot;));//more,&amp;,luck,&amp;,ilyvar str = arr.join();//默认连接的是&quot;,&quot; 5、split（） 将字符串按照传进去的符号拆分为字符串形式数组。注意它是字符串的方法。但是它跟join操作是互逆的。 1234var str = &quot;the-first-name&quot;;console.log(str.split(&quot;-&quot;));//[&quot;the&quot;, &quot;first&quot;, &quot;name&quot;]console.log(str.split(&quot;&quot;));//[&quot;t&quot;, &quot;h&quot;, &quot;e&quot;, &quot;-&quot;, &quot;f&quot;, &quot;i&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;-&quot;, &quot;n&quot;, &quot;a&quot;, &quot;m&quot;, &quot;e&quot;]console.log(str.split(&quot;-f&quot;));//[&quot;the&quot;, &quot;irst-name&quot;]//以这个进行截 举个例子：12&apos;百度&apos;,&apos;alibaba&apos;,&apos;tencent&apos;,&apos;toutiao&apos;,&apos;wangyi&apos;把它们连接起来。 第一种方法： 12var str = &quot;&quot;;str += ...； 这种很耗性能，因为它属于栈操作。 第二种方法：12var arr = [&apos;百度&apos;,&apos;alibaba&apos;,&apos;tencent&apos;,&apos;toutiao&apos;,&apos;wangyi&apos;];arr.join(&apos;,&apos;); 堆内存散列操作，节省操作。栈内存，放进去容易，取出来容易，特别恶心。 数组去重问题这里有一个我们必须要掌握的方法：数组去重方法。 把数组中重复的元素去掉。 12345678910111213var arr = [1,1,1,1,2,3,3,2,3,2,undefined,undefined];Array.prototype.unique = function () &#123; var obj = &#123;&#125;, arr = [] for(var i = 0;i &lt; this.length; i++) &#123; if(!obj[this[i]]) &#123; obj[this[i]] = &apos;abc&apos;; arr.push(this[i]); &#125; &#125; return arr;&#125;console.log(arr.unique());//[1, 2, 3, undefined] 这里我们运用了一个简单的哈希结构。当我们数组中的这个数据出现过一次之后，我们就在obj中将这个元素的值的位置标记成’abc’，后面如果出现相同的属性值，因为这个位置已经是’abc’了，所以就不会添加到新数组里面，从而达到了去重的效果。 ES5的数组方法刚才的那些常用的数组方法都是ES3中定义的，ES5中出现了一些新的方法。 1、forEach（） 这个方法会改变原数组，它让数组中的元素从头到尾遍历一遍，每一个都调用一下我们在forEach里面传递的方法，中间不会停止。 12345var arr = [1, 2, 3, 4];arr.forEach(function () &#123; arr[i] += 1;&#125;)console.log(arr); // 2 3 4 5 2、map（） 这个方法和forEach很像，只不过forEach会改变原数组，而map不会改变原数组，而是返回一个新的数组，它也是让传递一个指定的方法，让数组中的每一个元素都调用一遍这个方法。不过记得map方法最后有返回值。 123456var arr = [1, 2, 3];var test = arr.map(function (x) &#123; return x * x;&#125;);console.log(test); // 1 4 9console.log(arr); // 1 2 3 3、filter（） 这个方法是过滤的作用，它同样不会改变原数组，而是返回一个原数组的子集。我们同样会传递一个方法，每一个元素都会调用一下这个方法，但是只有返回true的元素才会被添加到新数组里面，返回false的不会被添加到新数组里面。 12345var a = [1 ,2 , 3, 4, 5];var b = a.filter(function (x) &#123; return x &gt; 2&#125;);console.log(b); // 3 4 5 同时，filter( )会跳过稀疏数组里面缺少的元素，它的返回数组总是稠密的。 12345var arr = [1,,,,,,3,4];var b = arr.filter(function () &#123; return true;&#125;)console.log(arr); // 1 3 4 4、every（） 和 some（） 这两个方法是数组的逻辑判定，他们对数组应用指定的函数进行判定，返回true或者false。 every是如果每一个元素经过传递的方法的判定之后都返回true，那么最后才返回true。 some是只要有一个元素返回true，那么就返回true。 123var arr = [1 ,2 ,3];console.log(arr.some(function (x) &#123;return x&lt;3;&#125;)); trueconsole.log(arr.every(function (x) &#123;return x&lt;3;&#125;)); false 5、reduce（） 和 reduceRight（） reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，最后变成一个值，reduce是从左向右，reduceRight是从右向左。有两个参数，第一个是方法，第二个是可选参数，即我们最后的这个值的初始值。 当我们没有设置初始值的时候，用数组的第一个元素的值作为初始值。不过当数组为空的时候，不带初始值就会报错。 当我们的数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值的情况下，reduce只是简单地返回那个值，而不会调用函数。 123456var arr = [1, 2, 3];var sum = a.reduce(function (x, y) &#123; return x + y&#125;, 0);// 0 + 1 + 2 + 3 = 6;var temp = [1];var temoOut = a.reduce(function (x, y) &#123;return x x y&#125;); // 1 不会调用这个函数，因为数组只有一个值，除非我们设置一个初始值 前面说的isArray()方法来检测是否是数组，其实是ES5里面的。 最好的检验数组的方法是： Object.prototype.toString.call(arr) === ‘[object Array]’ 这是最可靠的检测是否是数组类型的方法。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的类数组的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"对象的枚举和克隆","slug":"对象的枚举和克隆","date":"2018-09-26T12:29:19.000Z","updated":"2018-09-26T12:31:46.177Z","comments":true,"path":"2018/09/26/对象的枚举和克隆/","link":"","permalink":"http://moreluckily.com/2018/09/26/对象的枚举和克隆/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中克隆的相关知识。 对象的枚举我们知道要枚举一个数组的所有元素，只要用一个for循环从头到尾遍历一遍就可以了。 但是对象并不能用for循环来遍历属性，所以这里我们就要使用for-in操作了。 123456789101112var obj = &#123; name : &quot;abc&quot;, age : 123, sex : &quot;male&quot;&#125;for(var prop in obj) &#123;var prop , prop in obj，也可以这样写 console.log(obj[prop]); // 每一次prop都代表obj中的一个属性名 //obj.prop不行 //obj.prop --&gt;（电脑转化）--&gt;obj[&quot;prop&quot;]&#125; 能把对象中的每一个属性都打印出来。var prop 相当于声明一个变量，in obj，每次循环都会从obj中拿出来一个属性名，obj[prop]就可以得到每一个属性值。注意不能写obj.prop这个形式，因为系统会将它变成obj[‘prop’]属性，所以每次都是undefined。 而且可以把var prop写在外面。 但直接这样写会有错误，看下面的例子： 12345678910Person.prototype.name = &apos;abc&apos;;function Person() &#123; this.age = 123; this.sex = &apos;male&apos;;&#125;var person = new Person();for(var prop in person) &#123; console.log(person[prop]);&#125;//会打印出&quot;abc..... 它会把自己原型链的属性也会打印出来，这有时候就不是我们需要的，我们只需要它自己的属性。 下面我们来介绍三种操作符： 1 、hasOwnProperty 这个操作符的作用是查看当前这个属性是不是对象自身的属性，在原型链上的属性则会被过滤掉。如果是自身的，就返回true，否则返回false。 1234567891011Person.prototype.name = &apos;abc&apos;;function Person() &#123; this.age = 123; this.sex = &apos;male&apos;;&#125;var person = new Person();for(var prop in person) &#123; if(person.hasOwnProperty(prop))&#123; console.log(person[prop]); &#125;&#125; 这样，我们的for-in循环就会只打印自身的属性而不会去打印原型上的属性。 2、in操作符 这个操作符的作用是查看一个属性是不是在这个对象或者它的原型里面。 1234567var obj = &#123; name : &quot;abc&quot;, age : 123&#125;console.log(&apos;name&apos; in obj); //trueconsole.log(&apos;age&apos; in obj); //trueconsole.log(&apos;sex&apos; in obj); //false 3、instanceof 操作符 这个操作符的作用是查看前面的对象是不是后面的构造函数构造出来的，和constructor挺像的。 123456function Person() &#123;&#125;var person = new Person();console.log(person instanceof Person);//true，是不是构造的? 也可以理解为：后面的构造器的原型是否在前面对象的原型链上。 12345678910function grand() &#123;&#125;Person.prototype = new grand();function Person() &#123;&#125;var person = new Person();console.log(person instanceof grand);//true 在这里介绍一下快捷键的使用： 1234567撤销 ctrl+z反撤销 ctrl+y选中：Shift + 左右 ctrl + dTab == ctrl + [Shift+Tab == ctrl + ] 选中一行：Shift+ctrl + 左右 区分数组和对象1、instanceof 操作符 12345[] instanceof Object //truevar obj = &#123;&#125;;obj instanceof Object//true[] instanceof Array //trueobj instanceof Array//false 2、利用constructor属性 1234var arr = [];var obj = &#123;&#125;;arr.constructor --&gt;Arrayobj.constructor --&gt;Object 3、toString方法 12345Object.prototype.toStringArray.prototype.toStringNumber.prototype.toStringBoolean.prototype.toStringString.prototype.toString 123456Array.prototype.toString = function () &#123; return &quot;moreluckily&quot;;&#125;var arr = [1,2,3,4];document.write(arr);//moreluckilyconsole.log(arr);//[1,2,3,4] 为了方便各种类型进行打印，系统在每个原型链上面都重写了toString方法。因为对象，数组都不能直接使用document.write()进行打印，系统会内部进行调用该变量的toString方法。但是我们需要跳过数组自身的toString方法，去使用Object上面的toString。这时候，就要使用call来改变指向。 12345var obj = &#123; &#125;;var arr = [ ];var toStr = Object.prototype.toString;console.log(toStr.call(obj));//[Object Object]console.log(toStr.call(arr));//[Object Array] 封装成方法： 12345678910function isArrayOrObject(target) &#123; var toStr = Object.prototype.toString, arrStr = &apos;[Object Array]&apos;; if(toStr.call(target) === arrStr) &#123; return &apos;this is Array&apos;; &#125;else&#123; return &apos;this is Object&apos;; &#125;&#125; 那能不能写一个函数将所有的类型的数据都判断出来呢？所有的原始值和引用值。 12345number string boolean undefined null //原始值------typeof() ---object function //null注意//typeof(null) -- &gt; object//if(null == null)&#123;return null&#125;object array function Number() Boolean() String() //引用值 封装成方法： 1234567891011121314151617181920function type(target) &#123; var typeStr = typeof(target), toStr = Object.prototype.toString, objStr = &#123; &quot;[object Object]&quot; : &quot;object - object&quot;, &quot;[object Array]&quot; : &quot;array - object&quot;, &quot;[object Number]&quot; : &quot;number - object&quot;, &quot;[object Boolean]&quot; : &quot;boolean - object&quot;, &quot;[object String]&quot; : &quot;string - object&quot; &#125; if(target === null) &#123; return null; &#125;else if(typeStr === &quot;function&quot;) &#123; return &quot;function&quot;; &#125; if(typeStr !== &quot;object&quot;)&#123; return typeStr; &#125;else&#123; return objStr[toStr.call(target)] &#125; 4、Array.isArray( )方法 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false 比较推荐使用前面讲的第三种方法。 克隆在开始介绍克隆的代码和数组的相关知识点之前，我在前面先介绍一下arguments.callee方法和func.caller属性。 1、arguments.callee arguments是每个函数都具有的一个对象，实参列表。它有一个属性叫做callee，指向的是函数的本身。 当我们在一些匿名函数或者立即执行函数里面进行递归调用函数本身的时候，由于这个函数没有名字，我们不能用函数名的方式调用，就可以用arguments.callee来调用。 一般当我们需要通过计算来进行初始化的时候，我们写一个立即执行函数，当这个立即执行函数还需要递归调用自身的时候，我们就是用arguments.callee方法。 12345678var num = (function (n) &#123; if(n == 1)&#123; return 1; &#125; return n * arguments.callee(n-1);&#125;(5))console.log(num); //120//小数点后能计算到15位,再多就不好使了 2、func.caller 1234567function demo() &#123; text();&#125;function text() &#123; console.log(text.caller);&#125;demo(); //demo() &#123;&#125; func.caller：这是函数本身自带的一个属性，可以指出当前函数里运行环境的函数引用，即这个函数是在哪个函数体里面执行的。 会考它俩的区别。 克隆克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。 浅层克隆克隆大致就是我们的源对象里面有什么属性，目标文件就有什么属性，依照这个原理，我们可以写出下面的代码： 12345678var obj = &#123; name : &apos;abc&apos;, age : 123&#125;var obj1 = &#123;&#125;for(var prop in obj)&#123; obj1[prop] = obj[prop];&#125; 将其封装成一个方法： 12345678910var obj = &#123; name : &apos;abc&apos;, age : 123&#125;var obj1 = &#123;&#125;function extend(origin, targrt) &#123; for(var prop in origin)&#123; target[prop] = origin[prop]; &#125;&#125; 浅层的拷贝，对引用值不好使，即当我们有一个属性是引用值（数组或者对象）的时候，按照我们这种克隆方式，只是把这个引用值的指向赋给了新的目标对象，也就是说，我们一旦改变了源对象或者目标对象的引用值属性，另一个也会跟着改变，这一点就是浅层克隆的缺点。 深层克隆为了解决浅层克隆的引用值的问题，我们又需要一种深层克隆。 其实深层克隆的原理也很简单，我们只要不克隆引用值的引用，而是把引用值也当做一个源对象，把里面的值一个一个的克隆进目标对象里面，不就解决了他们二者相同指向的问题了吗。 12345678910111213141516171819function deepClone(origin, target) &#123; //传不传target都行 var target = target || &#123;&#125;, arrStr = &quot;Array - Object&quot;; for(var prop in origin) &#123; if(origin.hasOwnProperty(prop)) &#123; //判断是不是对象 if(typeof(origin[prop] === &quot;object&quot;)) &#123; if(type(target[prop]) == arrStr)&#123; target[prop] = []; &#125;else&#123; target[prop] = &#123;&#125;; &#125; deepClone(origin[prop], target[prop]); &#125;else&#123; target[prop] = origin[prop]; &#125; &#125; &#125; return target;&#125; 这里我们运用了递归调用的方法，当我们检测到源对象里面的这个属性值是引用类型的，那么就在目标对象里面也创建一个引用类型的属性，如果原来是数组就创建数组，是对象就创建对象，然后分别将源对象里面的这个引用值和目标对象里面的引用值分别当做新的源对象和目标对象进行克隆，这样就是克隆的里面每一个值了，而不是把整个引用都克隆过去。 这个时候目标对象和源对象的引用值之间就没有了关系，自己都是独立值，可以进行修改了。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的数组的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js中的this","slug":"js中的this","date":"2018-09-25T15:31:59.000Z","updated":"2018-09-25T15:33:14.697Z","comments":true,"path":"2018/09/25/js中的this/","link":"","permalink":"http://moreluckily.com/2018/09/25/js中的this/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中this的相关知识。 命名空间由于我们的一个项目是很多人开发的，每个人都有一套自己的变量，为了防止人和人之间变量的互相干扰，我们经常把自己的变量都放到相对应的模块里面，模块和模块之间是没有关系的，这样就算变量名相同也不会互相干扰。我们经常用对象来实现这种模块的作用。 12345678910111213141516171819202122var org = &#123; department1: &#123; a : &#123; &#125;, b : &#123; &#125; &#125;, department2: &#123; wang : &#123; name : &quot;abc&quot;, sge : 123 &#125;, fa : &#123; &#125; &#125;&#125;var wang = org.department2.wang;wang.name;wang.age; 以上的方法是旧方法来解决的，现在多数使用闭包来进行解决，每个变量都在自己的域中，别人访问不了。 123456789101112var add = (function () &#123; var count1 = 0; var count1 = 0; function myAdd(num1, num2)&#123; count1 = num1; count2 = num2; console.log(count1 + count2); &#125; return function (num1, num2) &#123; myAdd(num1, num2) &#125;;&#125;()) 这种解决方式，也是类似于利用私有化变量来解决命名冲突，只有在与自己产生闭包的变量才能访问到。不污染全局变量。 链式调用有时候，我们需要像jQuery那样调用完一个方法之后连续的调用下一个方法，这时候，我们需要使用this了。 123456789101112131415var deng = &#123; smoke : function () &#123; console.log(&quot;smoke, cool!!!&quot;); return this; &#125;, firehair : function () &#123; console.log(&quot;fire&quot;); return this; &#125;, drink : function () &#123; console.log(&quot;drink&quot;); return this; &#125;&#125;//deng.drink().smoke(); 这样写我们就可以实现链式调用了，因为当函数一调用执行完就会返回自己，如果没有返回this，那么以上代码就会报错。 this指向1、函数预编译过程 this —&gt; window 12345678910111213function text () &#123; console.log(this);&#125;text();//AO = &#123;arguments : [], this : window&#125;//this -- &gt;windowfunction text () &#123; function demo() &#123; console.log(this); &#125; demo();&#125;text(); 1234567function Person() &#123; console.log(this);&#125;//AO -- &#123;// this : Object.create(Person.prototype);//就是 window// &#125;new Person(); 2、局作用域里面 this–&gt;window 123GO = &#123; this --&gt; wondow&#125; 3、call和apply，改变this指向，指向的是括号里面所传的对象； 4、obj.func()； // func() 里面的this指向的是obj，意思就是，谁调用的方法就是指向谁。 12345678var obj = &#123; age : 123; smoke : function () &#123; console.log(this); &#125;&#125;obj.smoke();this --&gt; obj&#123;&#125; 接下来举一些例子来巩固一下吧。 12345678910var obj = &#123; age : 123, smoke : function () &#123; console.log(this); &#125;&#125;var smoke1 = obj.smoke;smoke1();指向 --&gt; window没调用，就是window 再来一个例子吧。 123456789101112131415161718192021222324252627var name = &quot;222&quot;;var a = &#123; name : &quot;111&quot;, say : function () &#123; console.log(this.name); &#125;&#125;var fun = a.say;fun(); //222a.say();//111var b = &#123; name : &quot;333&quot;, say : function (fun) &#123; fun(); &#125; &#125;b.say(a.say);//222//(a.say) , a.say的函数体//首先b.say(), this --&gt; b（b这个函数体） //如果打印this.name的话就是333//fun --&gt; say : function () &#123;// console.log(this.name);// &#125;// fun();//指向的就是window的，就是222b.say = a.say;//将b.say换成了a.sayb.say();//333 再来一个题目吧。 12345678910111213var name = &apos;window&apos;; //一般都是用&apos;&apos;,php不认识 &quot;&quot;var obj = &#123; name : &apos;obj&apos;, child : &#123; name : &apos;child&apos;, getName : function () &#123; return this.name; &#125; &#125;&#125;console.log(obj.child.getName());//childvar getName = obj.child.getName;console.log(getName());//window 上面的题目比较简单，来一个比较难的题目吧。 12345678910function fun(n, o) &#123; console.log(o); return &#123; fun : function(m) &#123; return fun(m, n); &#125; &#125;&#125;var x = fun(0);x.fun(1); 来分析一下： 12345678910111213x = &#123; fun : function (m) &#123; return fun(m, n); &#125;&#125;x.fun(1);//x = &#123; fun : function (m) &#123; return fun(1, 0); //上哪里找fun?上第一行找 //打印:undefined , 0 &#125; &#125; 1234567891011121314var y = fun(0).fun(1).fun(2);//fun(0) --&gt; &#123; fun : function (m) &#123; return fun(m, 0); &#125;&#125;//1.undefined//2.0//3.1fun(1) --&gt; &#123; fun : function (1) &#123; return fun(1, 0); &#125;&#125; 12345var z = fun(0).fun(1);//undefined//0z.fun(2);//1z.fun(3);//1 属性的表示方法我们经常使用这样的方法来表示属性的引用：obj.prop，其实在系统的内部obj.prop (系统内部会转变)--&gt; obj[&#39;prop&#39;] 有些时候使用第一种表示方法是不好使的，举个例子： 12345678910function getProp(prop) &#123; var obj = &#123; age : 123, sex : &quot;male&quot;, height : 175 &#125; // console.log(obj.prop); 不行 console.log(obj[prop])//这样才行&#125;getProp(&apos;age&apos;); 当我们要通过变量传参的形式来调用属性的时候，第一种方式会报错，第二种方法才能正常使用。 123456789function getProp(num) &#123; var obj = &#123; friend1 : &apos;a&apos;, friend2 : &apos;b&apos; &#125; console.log(obj[&apos;friend&apos; + num]);&#125;getProp(1);//agetProp(1);//b 通过中括号的形式调用属性，还能进行属性的拼接。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的克隆相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的继承","slug":"js的继承","date":"2018-09-25T12:48:16.000Z","updated":"2018-09-25T15:33:17.002Z","comments":true,"path":"2018/09/25/js的继承/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的继承/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中继承的相关知识。 继承发展史首先复习一下call 1234567var obj = &#123;&#125;;function text(name, age) &#123; this.name = name; this.age = age;&#125;text.call(obj, &quot;abc&quot;, 123);//obj里有name和age 继承发展史:第一阶段：传统形式，其实就是原型链继承，它会过多的继承了没用的属性。 12345678910Grand.prototype.lastName = &quot;abc&quot;;function Grand() &#123;&#125;var grand = new Grand();Foo.prototype = grand;function Foo() &#123;&#125;var foo = new Foo();son.prototype = son;function son() &#123;&#125;var son1 = new son(); //过多的继承了没用的属性 第二阶段：借用构造函数。 12345678910function Factory(name, age) &#123; this.name = name; this.age = age;&#125;function Person(name, age) &#123; //var this = Object.create(Person.prototype); Factory.call(this, name, age); //return this;&#125;var person = new Person(&quot;age&quot;,123) 这种方式就是利用了call和apply可以改变this指向的特点，通过构造函数来间接的构造子对象。 但是这种方式有两个缺点： 1.严格来说，这种方式不属于继承，也访问不了原型的原型。 2.每次构造一个对象都要走两个构造函数，效率很低。 第三阶段：共享原型。 1234567891011121314Person.prototype.lastName = &quot;wang&quot;;function Person(name) &#123; this.name = name;&#125;var person = new Person(&quot;abc&quot;);PersonAnother.prototype = Person.prototype；PersonAnother.prototype.age = 11;function PersonAnother() &#123;&#125;var personAnother = new PersonAnother();personAnother.lastName=&quot;wang&quot;;var operson = new Person(&quot;abc&quot;);//当我们给personAnother的原型上添加属性的时候，发现operson的原型也会发生同样的变化，这就是我们不想要的，于是就产生了第四种方式了 第四阶段：圣杯模式。 为了解决第三种方法产生的bug，我们需要添加一个中间层，产生一个过渡。 123456789Person.prototype.lastName = &quot;wang&quot;;function Person() &#123; &#125;F.prototype = Person.prototypefunction F() &#123;&#125;var f = new F();PersonAnother.prototype = f;PersonAnother.prototype.age = 123;function PersonAnother() &#123; &#125;new PersonAnother(); 第三种情况出现的bug，是因为PersonAnother和Person原型指向是同一个房间，所以当房间的内容改变的时候他们就会同时发生改变，这时候我们加上一个中间层，F函数，里面就是让它的原型指向Person的原型，然后，PersonAnother的原型继承自F函数的原型，就相当于也继承了Person的原型，而且实现了PersonAnother改变的时候，Person的原型不发生改变。 但是，这还是有一点不足，我们知道constructor属性指向的是构造这个对象的函数，但是这时候PersonAnother的constructor指向的是Person，因为F函数里面没有constructor属性，于是便会随着原型链网上找，于是就找到了Person里面，这时候我们需要手动地给PersonAnother添加一个constructor属性。 还有就是，在正常开发中，我们需要一个叫超类（Uber）的东西，同时我们为了保存一下它的父类，也用一个uber来记录一下父类。于是，圣杯模式的最终形式就是这样的： 12345678910function inherit(Origin, Target) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; // 超类uber Target.prototype.uber = Origin.prototype;&#125;PersonAnother.__proto__ : Person&#123;uber:Object, sge: 123&#125;PersonAnother.__proto__.uber : Object&#123;lastName: &quot;wang&quot;&#125; 不过，这种写法虽然成功了，但是还是有一点点小瑕疵，这里面的F函数只是起到一个搭桥的功能，并没有什么实质性的作用，那么我们能不能舍弃掉这个东西呢？ 真的舍弃掉是不可能的，但是我们可以通过一定的方法来规避这个函数，让他不出现在我们的继承函数中。 圣杯模式高级写法我们利用雅虎的YUI3库进行一个高级的圣杯模式写法，利用的是闭包的私有化变量。 123456789var inherit = (function () &#123; var F = function () &#123;&#125;; return function(Origin, Targe) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype; &#125;&#125;()) 这样通过立即执行函数和闭包，我们既可以使用F函数，又可以不让它出现在我们的真正的继承函数中（即返回的那个函数）。 当然我们也可以通过一张图来概括圣杯模式。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的this相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的原型","slug":"js的原型","date":"2018-09-25T06:02:56.000Z","updated":"2018-09-25T12:58:50.363Z","comments":true,"path":"2018/09/25/js的原型/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的原型/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中原型的相关知识。 原型**先说一下原型的定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象，也可以对它进行增删改查，举2个例子： 12345678910Person.prototype.name = &quot;wang&quot;;Person.prototype.age = 20;Person.Prototype.sex = &quot;male&quot;;function Person() &#123; &#125;var person1 = new Person();var person2 = new Person();person1.name //&quot;wang&quot;person2.age // 20person1.sex //maleperson1 //Person --&gt; __proto__:Object (原型) 虽然person1表面上什么都没有，但是因为它是由Person构造出来的，所以他继承了Person的原型，所以就有其他的看不见的属性想name，age，sex。但是我们要注意的是，person1上面的属性是只读的，不能修改它原型上的属性，也不能够删除。例如： 1234person1.name = &quot;moreluckily&quot;;person1.name // &quot;wang&quot;delete person1.name;person1.name //&quot;wang&quot; 对于数组，我们是可以利用数组自身的一些方法进行修改，例如： 12345Person.prototype.card = [100,100,100];function Person() &#123; &#125;var person1 = new Person();person1.card.push(100);console.log(person1.card);//[100,100,100,100] 提取共有属性利用原型特点和概念，可以提取共有属性。举个例子： 1234567function Car(color)&#123; this.height = 1400; this.width =1900; this.color = color;&#125;var car1 = new Car(&quot;green&quot;);var car2 = new Car(&quot;red&quot;); 这个例子可以看到，car1和car2只是color不一样，但是，height和width都是重复执行的，换句话说就是耦合的，这时候我们就需要对其进行解耦，这时候，原型就派上用场了。 1234567Car.prototype.height = 1400;Car.prototype.width = 1900;function Car(color)&#123; this.color = color;&#125;var car1 = new Car(&quot;green&quot;);var car2 = new Car(&quot;red&quot;); 因为原型也是一个对象，所以我们更简便的去写： 1234Car.prototype = &#123; height = 1400, width = 1900&#125;//更简便了 但是没有，constructor 构造器这个属性，不提倡使用自己写的。总结一下就是，原型就是一个对象，每一个函数有一个原型，而且每一个函数都只有一个原型。 原型链简介构造函数创建对象的时候，里面有一个__proto__ //由于在文本中不能输入__proto__,所以以后就用proto代替它的属性，它指向的是该函数的原型，当访问变量的时候，如果自身没有该属性，它就会寻找proto上面指向的该函数的原型上去寻找，如果这个原型上面也没有，会继续沿着原型上面的proto属性继续寻找，这条链式结构，就称之为原型链，每条原型链的终点就是Object()。如果，在原型链终点上面也没有找到查询的变量就会报undefined。 constructor 构造器构造函数创建对象的时候，会有一个constructor属性，指向的是构造出该对象的函数。 当我们自定义的方法设定原型的时候，constructor属性是没有的。这就是与原生原型的区别，这时候我们还需要手动添加constructor属性，这样就完美了。接着上面的例子： 1234567891011没有设定constructor属性的时候：car1.constructor // function Object() &#123;[native code]&#125;//设定了constructor属性的时候：constructor 就是指向CarCar.prototype = &#123;height : 1400,width : 4950,constructor : Car&#125;function (color) &#123;this.color = color;&#125; 原型链*对象如何查看原型：前面我们提到了构造函数可以通过.prototype的方法来查看构造函数的原型，那么我们怎么查看对象的原型呢？ 我们前面提到过用构造函数构造对象的时候，会隐式创建一个this对象，这个this对象里面有一个默认的属性叫做proto属性，这个属性的值就是指向的这个对象的原型。 1234var this = &#123; // xxx __proto__ : Person.prototype; &#125; 原型链：有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。举个例子：1234567891011121314151617181920212223GrandFather.prototype.lastName = &apos;DDD&apos;;function GrandFather() &#123; //this = &#123;__proto__: GrandFather.prototype&#125; &#125;var grand = new GrandFather();Father.prototype = grand;function Father () &#123; //this = &#123;__proto__: Father.prototype&#125; this.forture = &#123; house : 2, money : 99999 &#125;&#125;var father = new Father();Son.prototype = father;function Son () &#123; //this = &#123;__proto__: Son.prototype&#125; this.name = &quot;fff&quot;; this.age = 10;&#125;var son = new Son();var oSon = son;console.log(oSon.lastName); //D Father创造出来的每一个对象都继承自grand这个对象，Son的每一个对象都继承自father这个由Father创造出来的对象，这样son就可以继承上面Foo和Gra的所有属性。 当我们查找oSon上的属性的时候，如果son自身有属性，那么就打印出来，如果没有，就向上查找原型father，如果father上面还有这个属性，那么继续向上查找grand，如果有就输出，如果没有就返回undefined。 那我们可以画一个图来进行更好的去理解它： Object.create()创建对象的第四种方法，使用Object.create()方法。 这样可以得到一个没有原型的对象。 Object.create(prototype) 这种方法创建对象，传进去的必须是原型，然后不能是原始值，否则会报错。 特殊情况，如果填null，是不会报错，但是里面的东西就没有原形了，其他增删改查都是正常进行。 123var obj = &#123;&#125;;document.write(obj);document.write(obj.toString());//其实是调用这个 如果没有原型，有一些问题就会出现。例如，当我们使用document.write的时候，对象是不能直接打印出来的，只能隐式地调用toString方法，然后再进行操作，如果没有原型，那么就没有toString方法，那么使用document.write的时候就会报错。 另外，只有使用Object.create的时候才能把null传进去，其他情况手动的将prototype设定为null都是不好使的。 1var obj = Object.create(null);//没原型 面试题：所有对象的终端指向object.prototype是错误的，绝大多数才是对的，因为null没有原型。 this的一些问题前面我们知道函数内部的this默认的指向是全局对象window，那么我们有什么办法可以改变this的指向吗？ 我们就可以用call/apply来改变this指向。 call/apply 作用：改变this指向。 区别：后面传的参数形式不同。 我们现在写一个函数： 123456function Person() &#123; this.name = &quot;abc&quot;; this.age = 123;&#125;Person();//window//window.name = &apos;abc&apos;; 这个时候this指向window，name属性自然也就是window上面的全局属性。 用call/apply来改变this的指向： 12345678function Person(name, age) &#123; this.name = &quot;abc&quot;; this.age = 123;&#125;var obj = &#123;&#125;;Person.call(obj, &quot;bcd&quot;, 18);//Person.call(obj,参数1，参数2)Person.apply(obj, [&quot;bcd&quot;, 18]);//Person.apply(obj,[参数一，参数二])//obj : &#123;name: &quot;bcd&quot;, age: 123&#125; 我们可以看到，当使用了call方法之后，Person函数内部的this就指向了我们传递的这个对象。现在这个函数就可以为obj来赋属性值了。 apply和call基本没有区别，唯一的区别是call后面的参数是一个一个传的，而apply后面的参数是放进一个数组里面然后传进去的。 在实际开发中，更多的是使用apply，因为我们可以利用arguments来进行不定参操作。 123456789function Person(name, age) &#123; this.name = &quot;abc&quot;; this.age = 123;&#125;var obj = &#123;&#125;;function text() &#123; Person.apply(obj, arguments)//apply用的比较多 &#125;text(&quot;abc&quot;, 123); 另外再多人开发中，当我们需要使用之前已经写好的一个十分复杂的代码块的时候，复制代码十分麻烦，因为通常变量都是涉及到上下文中的各个变量。我们不需要重新写一遍，直接使用apply，将this指向改变就可以了。就是利用其他的方法来构建自己的方法，最后进行个性化的定制即可。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中继承的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的对象","slug":"js的对象","date":"2018-09-25T05:29:35.000Z","updated":"2018-09-25T12:50:05.074Z","comments":true,"path":"2018/09/25/js的对象/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的对象/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中对象的相关知识。 复习一下首先来复习一下前几节课的内容，概念啥的就不多说什么了，来做几道题吧。 12(window.foo || (window.foo = &quot;bar&quot;));//先执行后面的，||直接返回document.write(window.foo); //bar 12345678var foo = &#123;n : 1&#125;;var bar = foo; //是foo的地址foo.x = foo = &#123;n : 2&#125;; //从右向左解析//相当于 bar.x = foo = &#123;n : 2&#125;,和foo没关系//视觉效果，要忽略视觉效果console.log(foo.x); //undefinedbar.x = foo = &#123;n : 2&#125;;console.log(bar.x); //&#123;n : 2&#125; 对象（object）对象（onject）是一个引用值，它可以有方法，属性，属性和方法之间要用逗号隔开，不能用分号隔开，否则会报错。举个例子： 1234567891011121314151617181920var mrWang = &#123; firstName : &quot;moreluckily&quot;, lastName : &quot;wang&quot;, age : 20, sex : &quot;male&quot;, sister : &#123; name : &quot;moreluck&quot;, age : 25 &#125;, brother : &#123; name : &quot;morelucky&quot;, age : 22 &#125;, study : function () &#123; console.log(&quot;I am studying, cool!&quot;); &#125;, sing : function () &#123; console.log(&quot;I am singing, good!&quot;); &#125;&#125; 对象的属性的增、删、改、查1234mrWang.borther2 = &quot;moreluclier&quot;;//增delete mrWang.borther2;//删除,只能删除对象的属性mrWang.age = 21; //改console.log(mrWang.age = 21);//查 对象的创建方法对象字面量格式1var obj = &#123;&#125; //PlainObject 对象字面量/对象直接量 构造函数创建对象12var obj = new Object ();obj.name = &quot;moreluckily&quot;; 这种方法太麻烦了，属性要一个个的加进去，能写字面量，就不写这种方法。 自定义构造函数**自定义构造函数，使用大驼峰的写法，即：1function TheFirstName() &#123;&#125; 自定义的构造函数方法可以自己定义方法，用于批量生产对象。举个例子：1234567891011function Car() &#123; this.name = &quot;Maserati&quot; this.height = 1400; this.width = 2000; this.run = function () &#123; this.health --; &#125;&#125;var car = new Car(); var car1 = new Car();//不同的对象car.color = red;//car的属性改变了，car1的属性不能改变 上面的例子写的有些麻烦，我们可以对其进行一些优化，用传参数的方式来直接写。 123456789101112function Car(color) &#123; this.name = &quot;Maserati&quot; this.height = 1400; this.width = 2000; this.health = 100; this.run = function () &#123; this.health --; &#125; this.color = color;&#125;var car = new Car(&quot;red&quot;); var car1 = new Car(&quot;green&quot;);//个性化 构造函数的内部原理1.在函数体最前面隐式的加上this = {};2.执行 this.xxx = xxx;3.隐式的返回this 123456789101112131415function Person(name, age, sex) &#123; //var this = &#123;&#125;; //AO = &#123; // this : &#123; // this.name = name; // this.age = age; // this.sex = sex; // &#125; &#125; this.name = name; this.age = age; this.sex = sex; //return this;&#125;var person = new Person(&quot;moreluckily&quot;, 123, &quot;male&quot;) 在函数person函数定义的时候，首先，会隐式地在执行上下文中添加一个空对象名为this，然后，执行每句语句，相当于往this里面添加对象的属性和方法。最后，所有语句读执行完毕的时候，隐式地把this对象返回出去。 如果构造函数没有使用new来进行引用的时候，那么，this就是指向的window，例如:1var person1 = Person();//直接这样写 那么，这里的name指向的就是window，所有的带this的属性指向的都是window。当我们查询person.name的时候返回的是undefined，其他的属性的都是undefined。可以看出，没有利用new来进行引用的构造函数，那么里面的this指向的就是window。window.name等属性是undefined。 自己写一个和构造函数一样的函数封装我们已经知道了构造函数的相关原理，我们就可以利用它的原理自己来写一个和构造函数一样的函数封装。 123456789function Peason(name, age, sex) &#123; var that = &#123;&#125;; this.name = name; this.age = sge; this.sex = sex; return that; &#125; var person = new Person(&quot;moreluckily&quot;, 123, &quot;male&quot;)//通过new,return之后的东西一定是一个对象 首先我们手动的创建一个空对象命名为that，然后给that对象定义方法和属性，最后显式地return that对象，但是这个人工的构造函数，效率等各方面都没有原生的好。大家还是不要用自己写的构造函数。 在这里还要注意的一点， return 12; return “2”; return true; return { }，我们可以发现，前三个都是原来由构造函数生产出来的对象，但是对于第四个，就变成一个空对象了，意思就是，如果我们return的如果是原始值，那么对结构没影响，但是如果返回的是一个引用值，那么结果就是return出来的那个引用值。 闭包的作用：私有化变量在之前说闭包的时候，没有讲到构造函数，其实闭包还有一个作用，就是私有化变量。来看一下代码： 1234567891011121314151617181920212223function Deng() &#123; var prepareWife = &quot;moreluck&quot; var obj = &#123; name : &quot;moreluckily&quot;, age : 20, sex : &quot;male&quot;, wife : &quot;morelucky&quot;, divorce : function () &#123; delete this.wife; &#125;, getMarried : function () &#123; this.wife = prepareWife; &#125;, changePrepare : function (someone) &#123; prepareWife = someone; &#125;, sayMyWife : function () &#123; return this.wife; &#125; &#125; return obj;&#125;var deng = Deng(); 我们对其进行操作： 1234567deng.sayMyWife() //&quot;morelucky&quot;deng.divouce() //undefined (没有返回值）deng.sayWife() //已经删除,undefineddeng.changePrepare(&apos;xiaoxiaozhang&apos;) //undefined (函数没有返回值）deng.getMarried() //undefineddeng.sayMyWife() //&quot;xiaoxiaozhang&quot;deng.prepareWife //undefined 我们手动地查询prepareWife的时候，发现是undefined，因为这个是函数里面的变量，不在全局作用域里，所以我们访问不了，但是，一系列的操作都是围绕prepareWife来进行的，它们都可以正常访问这个变量，所以，像这种只能通过与这个变量产生闭包的方法，属性，才能给对那个变量进行访问，所以，我们就称之为，私有化变量，我们可以通过定制接口等各种方法，来对变量的安全程度进行设置。 包装类*首先我们要清楚知道的一点是：原始值是没有属性和方法的。 前面讲过原始值有：Number,String,Boolean,undefined,null。 引用值有：array, object, function。 那么你硬要给原始值加上属性和方法，那么系统就会把它转化为原始值对应的对象的形式，称之为包装，那么该原始值的对象形式称之为包装类。 我们可以通过new来将原始值变成其对象形式。 123Number --&gt; new Number() --&gt;数字的对象形式String --&gt; new String() --&gt;字符串的对象形式Boolean --&gt; new Boolean() --&gt;布尔的对象形式 那当我们把一个原始值添加属性的时候，会发生什么事情呢？ JS引擎会隐式地将原始值转化为对应的对象类型，然后，进行delete操作，意思就是，当我们给一个原始值添加属性的时候，引擎将会马上删除该原始值的对象形式。举个例子： 12345var num = 123;//new Number(num).abc = &quot;a&quot;; --&gt;deletenum.abc = &quot;a&quot;;//新的 new Number(num).abcconsole.log(num.abc);//undefined 我们知道引用值数组有一个属性length，它可以查看数组的长度，那么字符串也是有长度的，但是它不能像数组那样使用length对字符串进行截断处理，就是因为当对string进行设置length之后，之后会把马上销毁掉不进行任何地保留或者处理。也就是字符串的对象形式。 12345var str = &quot;abcd&quot;;//new String(str).length = 2; --&gt;deletestr.length = 2;// //新的 new String(str).lengthconsole.log(str.length);//4 123var arr = [1,2,3,4];arr.length = 2;console.log(arr); //[1,2] 包装类的一些例子*我们来看一下和包装类相关的一些例子： 12345678910111213//题目1：//运行text()和new text()的结果分别是什么？var a = 5;function text() &#123; a = 0; alert(a);//会产生一个：var this = &#123;&#125; alert(this.a); var a; alert(a);&#125;text();// 0 5 0new text();// 0 undefined 0 像第一个text( );，this.a就是window.a，也就是说第二个出来的是5。其他的两个0是AO里的，在这里就不多说了。 像第二个new text( );，在内部会产生一个var this = {},其内部没有东西，所以没有任何东西，出现的就是undefined。 再来一个例子： 1234567var str = &quot;abc&quot;;str += 1;var text = typeof(str);if(text.length == 6)&#123; text.sign = &quot;typeof返回的可能是string&quot;;&#125;document.write(text.sign);//undefined 这题的陷阱很深，最后大家可能都认为能够打印出来”typeof的返回结果可能是String”，但是，大家可能忘了，包装类，当定义完之后，就会被马上销毁，所以最后打印结果是undefined。 再举一个例子： 12345678910111213141516function Person(name, age, sex) &#123; var a = 0; this.name = name; this.age = age; this.sex = sex; function sss() &#123; a ++; document.write(a); &#125; this.say = sss; //上面的函数体&#125;var oPerson = new Person();oPerson.say();//1oPerson.say();//2var oPerson1 = new Person();oPerson1.say();//1 这就是闭包的作用：私有化变量。 再看一下接下里的这个题目： 1234567var foo = &#123;n : 1&#125;;var bar = foo;foo.x = foo = &#123;n : 2&#125;;console.log(foo.x);//undefinedbar.x = foo = &#123;n : 2&#125;;console.log(bar.x);// &#123;n : 2&#125;console.log(bar);//&#123;n : 1,x:&#123;n : 2&#125;&#125; 上次被这个问题困扰了很久，现在是不是明白了。 还有一点要情调的是： undefined == null //true //true 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中原型的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的闭包","slug":"js的闭包","date":"2018-09-24T17:00:46.000Z","updated":"2018-09-25T05:46:58.358Z","comments":true,"path":"2018/09/25/js的闭包/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的闭包/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中闭包的相关知识。 闭包初探先来举个例子吧，让我们看看什么是闭包。 1234567891011121314function a()&#123; //AO = &#123; aaa:12 , b : function ()&#123;&#125;&#125; function b()&#123; //AO = &#123; bbb: 234&#125; var bbb = 234; console.log(aaa);//12 &#125; var aaa = 12; return b; &#125; a(); var glob = 100; var demo = a(); demo(); 函数里面还套了另一个函数，看起来特别难的样子。让我们先来分析一下。当b执行完之后，就相当于a也执行完了，这样a都会把自己的执行上下文销毁，但是这时候，因为return b，把b保存给了外部的变量demo，这时候当demo执行的时候，可以正常打印出12，具体原因就是，虽然a把自己的执行期上下文删掉，但是这时候b仍然保存有a的劳动成果，当它返回给外部变量的时候，就相当于外部变量也有这个执行期上下文，所以就能够访问到aaa了。这就是我们经常听说的内存泄漏，就是因为原有的作用域链不释放所导致的。具体来看下图。 当a执行完成之后，a scope chain [0] 中的指向将会被删除，但是因为b的指向仍然存在，所以仍能访问到所需要的变量。 举个例子吧。12345678910function a() &#123; var aaa = 123; function b() &#123; console.log(++aaa); &#125; return b;&#125;var demo = a();demo(); //124demo(); //125 当a函数定义的时候，产生一个执行上下文，里面有一个aaa，和一个函数b，当b定义的时候，已经含有a的劳动成果，意思就是它已经有a的执行上下文，并且在b执行的时候，产生它自己的执行上下文，最后当a函数执行完之后，把函数b返回到了全局作用域，虽然a执行完，并且销毁了它自己的执行上下文，但是因为其内部b函数的存在，仍然有a的全部执行上下文，所以，仍然可以通过demo来访问function a( ) { }里面的aaa变量。 闭包的作用实现公有变量实现公有变量的最经典的例子就是实现函数累加器的功能。举个例子： 1234567891011121314function add() &#123; var num = 0; function demo() &#123; num++; console.log(num); &#125; return demo;&#125;var add1 = add();add1();//1add1();//2add1();//3add1();//4add1();//5 我们可以利用闭包产生一个公有变量，对于上述例子，公有变量就是num。add函数，把demo函数返回到了外部，demo函数，仍然有add函数的执行上下文，所有每次执行test的时候，就相当于执行demo函数，并且每次访问的num都是同一个num变量，这样，我们就称num就是公有变量，通过这样的操作方式，就可以利用闭包产生一个累加器了。 做缓存机构首先来看一下下面的代码，我们来分析一下这段代码。 1234567891011121314151617function text() &#123; var num = 0; function a() &#123; console.log(++num); &#125; function b() &#123; console.log(--num); &#125; return [a,b];&#125;var arr = text();arr[0]();//1arr[1]();//0arr[0]();//1arr[0]();//2arr[0]();//3arr[1]();//2 这段代码把a函数和b函数都返回到了外部，这样a函数和b函数都与num产生了一个闭包，并且a和b执行的都是同一个变量，当a改变num的时候，b的num也会发生改变，同理，b操作了num，a的num也会发生改变，因为它们指向的num是同一个num，这样，就相当于一个缓存，每次都是操作之前操作过的同一个变量。 闭包还有一个作用就是可以实现封装，属性私有化。但我们还没有讲到对象，所以先放一下，之后再将这个功能。 立即执行函数立即执行函数的定义：此类函数没有声明，在一次执行过后即释放。适合做初始化工作。 首先来看一下它的写法和功能： 12345(function () &#123; &#125;)() // 写法(function () &#123; //在这里直接执行//执行完就被销毁了 &#125;)() 当然了，立即执行函数也可以传参数，例如： 1234var ret = (function (a,b)&#123; console.log(a + b); return [a,b]; &#125;(a,b)&#125; 立即执行函数的一些基本知识首先我们需要知道它一些基本知识：1、只有表达式才能被执行，2、表达式被执行了就会被销毁，3、函数声明不能被执行 12function test() &#123; &#125; // 函数声明，不是表达式var test = function () &#123;&#125; // 函数表达式 但我们可以利用一些简单的方法将函数声明转化为表达式 1+function test()&#123; &#125; //+号运算符，可以将函数声明转会表达式，这样就可以执行了。那-号也就肯定可以咯。 1! function test() &#123;&#125; //可以在函数声明前加一个!号，也是可以将声明转化为表达式。 1(function () &#123; &#125;) //()也能 但我们写立即执行函数的时候，需要遵循W3C标准，它规定的正确的写法就是下面这样的： 123(function () &#123;console.log(&apos;b&apos;);&#125;()) 举一个比较特殊的例子： 123function test(a,b)&#123; console.log(a,b);&#125;(1, 2); 这种写法是不会报错的，因为它传了参数，这样系统将会解析为这样的：123456function test()&#123; console.log(a,b); &#125; (1,2) 这样，系统认为它们是相互独立的两个部分，不会报错，这时JS引擎的容错机制。 1var text = (1,2); // text=2 是不是很神奇，和C，C++什么的区别的比较大啊。 利用立即执行函数解决闭包的问题我们首先来看一个经典的闭包产生的问题： 12345678910111213function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i ++)&#123; arr[i] = function () &#123; document.write(i + &quot;, &quot;); &#125; &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt; 10; j++)&#123; demo[j]();&#125;//打印10,10,10,10,10... ,10个10 这段代码最后打印出的是10个10，我们的目的是要让它打印出0到9，显然跟我们的目标有差距。为什么呢？ 首先解析一下为什么10个10，首先我们需要知道，function打印出的i并不是马上变限的，意思是，function要等到执行的时候才会去寻找i的值，这时候i的值已经是10了，因为i必须要等于10的时候才会停止循环。 其实循环可以这样理解： 1function () &#123; console.log(i),function () &#123; console.log(i),function () &#123; console.log(i),function () &#123; console.log(i),... 当数组执行完循环之后，i才是真正的打印结果，这时候，i就是10； 另外，打出10个10，就是我们的每一个i，用的都是同一个执行上下文的i，这时候我们需要利用立即执行函数来解决这个问题。 12345678910111213141516function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i ++)&#123; (function (k) &#123; //特别重要 // 相当于i=k=0.... arr[k] = function () &#123; console.log(k); &#125; &#125;(i)) //实参 &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt; 10; j++)&#123; demo[j]();&#125;//0~9 利用立即执行函数，每次访问的i都是不一样的值，这样就可以打印出0-9了。 再来看一个例子： 123456789101112131415161718192021222324a = 100;function demo(e) &#123; function e() &#123;&#125; arguments[0] = 2; document.write(e); //2 if(a)&#123; //if里不能有函数，有的话不报错，但不会在预编译的时候提出来 var b = 123;//if里有声明，预编译使可以提到前面 function c()&#123; //每个人都能做出来 &#125; &#125; var c; a = 10; var a; document.write(b); //undefined f = 123; //暗示全局变量。 //在GO上加f:123 document.write(c); //undefined document.write(a); //10&#125;var a;demo(1);document.write(a);//100document.write(f);//123 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中对象的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的预编译","slug":"js的预编译","date":"2018-09-24T16:30:32.000Z","updated":"2018-09-25T06:04:31.173Z","comments":true,"path":"2018/09/25/js的预编译/","link":"","permalink":"http://moreluckily.com/2018/09/25/js的预编译/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中函数预编译的相关知识。 js运行三部曲首先一个JS程序能运行起来，需要经历三个步骤：第一步，语法分析，先通篇看一遍，看有没有低级语法错误，例如：有没有中文符号，多加了括号什么的。第二步，预编译。第三步，开始执行。 暗示全局变量imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。举一些例子：12a = 1;//a为暗示全局变量var a = b = 1;//b为暗示全局变量 任何地方的变量如果没有声明就赋值，就是全局变量。注意是！！任意的地方，这意味着如果在函数内部没用声明变量，就直接赋值，这个变量在全局都是被访问到。更进一步的意思就是，无论这个变量是否在局部作用域，它都能在全局作用域中被访问到。 在第二行代码中，由于赋值的过程是自右向左进行的，b其实是没有声明的，只有a是声明了的。 一切声明的全局变量，全是window的属性。例如:12a = 3;//window.a=3var a = b = 3;//window.a=3,window.b=3 预编译**预编译四部曲在预编译的时候，会发生下面的四步，我们把这个过程称为预编译四部曲。 1234567第一步：产生执行上下文的对象（activition object）简称AO ，它存在于系统内部。第二步：找形参和变量声明，直接提到函数顶部，将变量和形参名作为AO属性名，并赋值undefined。第三步：将形参和实参相统一。第四步：在函数体里面找函数声明，值赋予函数体。 这个其实是在函数内部发生的，那不是函数内部呢？那就是会创建GO，GO相对AO来说就比较简单了，没有形参。 12345第一步：产生执行上下文的对象简称GO ，它存在于系统内部。第二步：找变量声明，直接提到函数顶部，将变量名作为GO属性名，并赋值undefined。第三步：在非函数体里面找函数声明，值赋予函数体。 其实在GO上的属性就是window上的属性12window = GO = &#123;a: &#125;//a = window.a 还需要注意的一点常识就是，if语句里面不能有function。 举一些例子首先讲一个上节课的一个小例子： 12345var foo = 100 + &apos;200&apos;; //100200var foo = &apos;200&apos; + 100; //200100var foo = &apos;20&apos; * 10; //200var foo = &apos;20&apos; / 10; //2var foo = &apos;21&apos; % 10; //1 接下来就是重点了，我将会讲一些经典的预编译的例子。大家一起加油哦！ 12345678910111213function fn(a) &#123; console.log(a); //function a() &#123;&#125; var a = 123; console.log(a); //123 function a() &#123;&#125; console.log(a); //123 console.log(b); //undefined var b = function () &#123;&#125; console.log(b); //function () &#123;&#125; console.log(d); //function d() &#123;&#125; function d () &#123;&#125;&#125;fn(1); 下面我们来一起分析一下，这是一个函数，会产生AO。会发生预编译四部曲，我们接下来一起分析一下吧。 1234567891、创建AO对象2、找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined3、将实参值和形参统一4、在函数体里面找函数声明，值赋予函数体AO = &#123; a : undefined, --&gt; 1, --&gt;function a() &#123;&#125;, b : undefined, d : function d() &#123;&#125;&#125; 预编译结束，接着一步一步的进行里面的语句，于是就得到了上面程序的结果。 看到这里，可能大家有点懵，没关系，我们继续来讲下一个例子。 123456789101112131415161718function text(a,b) &#123; console.log(a); //1 console.log(c); //undefined c = 0; console.log(c); //0 var c; console.log(c); //0 a = 3; console.log(a); //3 console.log(b); //function b() &#123;&#125; b = 2; console.log(b); //2 function b() &#123;&#125; console.log(d); //function d() &#123;&#125; function d() &#123;&#125; console.log(b); //2&#125;text(1); 这是一个函数，会产生AO。会发生预编译四部曲，我们接下来一起分析一下吧。123456789101、创建AO对象2、找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined3、将实参值和形参统一4、在函数体里面找函数声明，值赋予函数体AO = &#123; a : undefined, --&gt; 1, b : undefined, --&gt; funtion b() &#123;&#125;, c : undefined, d : function d() &#123;&#125;&#125; 是不是明白了许多，接下来我要加入GO了，将GO和AO一起进行分析。请看下面的例子： 12345678var a = 100;function text () &#123; //AO = &#123;&#125; console.log(a); //100,AO里面没有的话会向上找GO里面的a。 a = 200; console.log(a); //把GO里的100改成了200，200&#125;text();console.log(a); //200，GO里的100已经改成了200 可能看的有点懵，我再来举一个相似的例子： 1234567891011121314a = 100;//GO = &#123;100&#125;function text() &#123; //AO = &#123;a : function a() &#123;&#125;&#125; console.log(a); //function a()&#123;&#125; a = 200; //AO = &#123;a : 200&#125;,但没有将GO中的a进行更改 function a()&#123;&#125; console.log(a); //200 var a; console.log(a); //200&#125;text();var a;console.log(a); //100 是不是觉得特别有意思呢？哈哈哈。 为了让大家理解的更深，我多举几个例子吧。 123456789101112131415function b() &#123; console.log(c); //undefined c = 0; //暗示全局变量，会在GO中产生 console.log(c); //0 console.log(a); //undefined a = 123; console.log(a);//123 var a = 324; console.log(a); //324&#125;b();var c;console.log(c);//0//解析：GO = &#123;c : undefined&#125;AO = &#123;a : undefined&#125; 是不是已经比较熟练的掌握了预编译。再来一个例子吧。 123456789101112text();var a;a = 324;function text() &#123; console.log(b);//undefined if(a) &#123; var b = 234; &#125; console.log(b);//undefined&#125;//预编译不看能不能执行，有声明就直接扯出来，在if里面的b就直接给提前了。//并将b赋值为undefined 但是在预编译的时候，也需要return,举个例子： 12345678function a() &#123; //AO = &#123;foo : function foo()&#123;&#125;&#125; return foo;//function foo()&#123;&#125;，直接就返回了 foo = 10; function foo() &#123;&#125; var foo =11;&#125;console.log(a()); 这就是预编译的整个过程。 作用域精讲首先，函数上面有一些东西是不提供操作的，其中有一个就是：scope属性，它存储的就是函数的真实的作用域，是函数执行期上下文的集合。 运行期上下文:当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。 作用域链：就是scope中所存储的执行期上下文的集合，这个集合成链式连接。就是作用域链。来个例子讲解一下： 1234567891011function a() &#123; function b() &#123; var b = 234; &#125; var a = 123; b();&#125;var glob = 100;a();//a定义：a.[ [ scope ] ] --&gt; scope chain ---&gt; 0:GO（全局作用域链）;如图一//a执行：a.[ [ scope ] ] --&gt; scope chain ---&gt; 0:aAO; 1：GO；如图二 图一：图二： 可以看到，当a定义的时候，已经拥有了GO，查找元素的时候，就是在scope里找，如果在自己的作用链就在自己的AO中索取，如果不存在，就从顶往下寻找。 当函数执行完之后，会销毁a中产生的执行期上下文，回归到a定义的时候。这也可以跟我们之前所说的，只能里面访问外面的，不能外面访问里面的一样，具体到理论上，就是外面的作用链，没有局部的作用域链，所以不能找到所需要的变量。 同样，我们在分析一下b，当b定义的时候，已经又有了a的劳动成果，就是a的作用域。如图三。 然后当b执行的时候，又产生了自己的作用域链。如图四。 图三：图四： 最后强调一下，当b执行完之后，意味着a也执行完了，意味着a和b的执行期上下文都被销毁，直接就恢复到a被定义的时候，只有全局的GO。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中闭包的相关知识 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js函数相关","slug":"js函数相关","date":"2018-09-24T16:01:35.000Z","updated":"2018-09-24T16:50:27.937Z","comments":true,"path":"2018/09/25/js函数相关/","link":"","permalink":"http://moreluckily.com/2018/09/25/js函数相关/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript中函数的相关知识。 函数先说一下为什么我们需要函数，请看下面这个例子： 123456789101112131415if(1 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(2 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(3 &gt; 0)&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125; 我们可以看到，打印出a 、b、c的语句重复了很多次，在编程里面称为耦合（重复），但是这是与编程原则所相违背的，编程要讲究高内聚，弱耦合，我们需要将它们都整合到一起，这时候就出现了函数了。 我们可以定义一个函数，当符合条件的时候就让这个函数执行，我们可以优化代码：1234567891011121314function test()&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(&quot;c&quot;);&#125;if(1 &gt; 0) &#123; test(); &#125;if(2 &gt; 0)&#123; test();&#125;if(3 &gt; 0)&#123; test();&#125; 这样，我们就是耦合程度大大降低了，这也是使用函数的一个重要目的。称之为：解耦合，把功能抽象出来，进行逻辑的处理之后，通过编写函数，达到把耦合程度降到最低。 函数的定义方式函数有最基本几个要素： 声明关键词：function， 函数名称， 参数（可选）。 函数的命名方式，是有规范的，如果多个单词进行拼接的时候，我们需要使用小驼峰式命名，即第一个单词小写，之后的每个单词首字母大写。例如: function theFirstName( ) { } 说完函数的命名方式之后，我们需要知道怎样对函数进行定义。 有两种方式： 1、函数声明方式，例如 ：function theFirstName(){} 2、函数表达式方式，例如 ：123var test = function demo() &#123; code &#125; , 函数表达式var test = function () &#123; code &#125; , 匿名函数表达式 (重点) 当我们在控制台调试的时候，我们可以发现第一种方法，利用test ，可以寻找到该函数，但是利用函数的名字demo，却会报错。第二种方法直接利用test就可以寻找到该函数，这表明了，函数表达式的demo这个名字，其实填写和不填写是一样的，因为在JavaScript内部，会将函数表达式最后都转化为 匿名函数表达式，所以我们统一采用匿名函数表达式，并称之为：函数表达式。 函数的参数12function test（a, b）&#123; code &#125;test(1,2); test后面跟着的一个括号就是用来填函数的参数的，这里写上一个a和b，就相当于在函数内部隐式的定义了两个变量a和b，参数不代表实际的值，相当于占位而已，必须是当你传入实际的值的时候，才会有特定的意义。所以我们称之为形式参数，简称形参，然后我们都通过传入1,2，这样就相当于给a赋值1，给b赋值2，这两个实际的值就称之为实际参数，简称实参。 JavaScript的参数机制很强大，它不限制位数，不限制类型。形参和实参都是天生的不定参，两者的长度没有规定相等，你可以形参定义100个，但是实参只传10个，或者形参定义两个，实参传200个都是没有问题的。这里又引出了一个概念：参数列表。 实参列表：arguments[1,2] ,实参列表就是用来存放实际参数的，就是我们传进去的参数，对于test来说，arguments有两位分别是1,2.第二个就是arguments是一个类数组，它有长度，无论形参怎么样，实参都会存储arguments中。 形参列表：test[a,b],实参列表，就是函数名字的类数组，里面存放的就是形参，对于test，里面就是a和b。 要注意的是，形参列表和实参列表之间有个映射关系，这个映射关系必须是两者长度一样的时候才会存在，当这个映射关系存在的时候，如果形参列表发生改变，那么实参列表也会跟着改变。例如： 1234567function func(a,b)&#123; a = 2; b = 3; console.log(argements[0]); //2 console.log(argements[1]); //3&#125;func(1,2); 可以看出，func传进的参数个数跟形参的个数长度是一样的，所以当a，b改变的时候，形参会发生改变。 12345function sum(a,b)&#123;b=2;console.log(arguments[1]);//undefined&#125;sum(1); 但是要注意的是，映射规则必须是要一一对应的时候才会有“你变我就变”，没有一一对应例如，形参个数不等于实参个数，都是没有映射规则的。 12345678function sum()&#123;var result = 0;for(var i = 0; i&lt;arguments.length;i++)&#123;result += arguments[i];&#125;console.log(result);//1+2+3+4+5+6=21&#125;sum(1,2,3,4,5,6); returnreturn是用来确定函数的返回值的，例如：12345function demo2 () &#123; return 222; &#125;var func = demo();console.log(func) //222 第二个作用就是，终止函数，即，当引擎解析到return语句的时候，那么该函数会马上停止执行，并返回出return后面的语句。 作用域作用域是一个很重要的概念，每一个函数代码块都是一个作用域，这里有一个全局作用域和局部作用域的概念。 全局作用域：除了function内部的都是全局作用域，所有在这个作用域声明的变量都是全局变量。 局部作用域：函数可以生成局部作用域，在函数内部声明的变量称之为局部变量。 全局作用域不能访问到局部作用域里面的变量，局部作用域里可以访问到全局作用域的变量。如果利用房子比作作用域的话，一个大房子就相当于一个全局作用域，每个大房子里面的小房子就相当于局部作用域，小房子可以随时开门去到大房子去寻找自身需要的东西，但是大房子没有小房子的钥匙，只能在自身的空间寻找自身需要的东西。这就是全局作用域和局部作用域的概念。 简单来说就是，外面的不能访问到里面的东西，里面的东西可以访问到外面的东西。来看一下这个例子。 123456789var a = 1;function test()&#123; a = 2; console.log(a) //2&#125;function test2()&#123; a = 3; console.log(a) //3&#125; 函数会产生作用域，而作用域产生的效果：里面的可以访问外面的,外面的不能访问到里面的，并列的不可以互相访问。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的预编译 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js类型转换","slug":"js类型转换","date":"2018-09-24T15:29:42.000Z","updated":"2018-09-24T15:31:55.526Z","comments":true,"path":"2018/09/24/js类型转换/","link":"","permalink":"http://moreluckily.com/2018/09/24/js类型转换/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript的类型转换的知识。 初识引用值首先先简单的介绍2种引用值，数组和对象。首先来说一下数组（array）吧，举个例子：1234var arr = [1,undefined,null,true,345]；document.write(arr[0]);//1arr[0] = 2;document.write(arr[0]);//2 能读能写，数组的长度可以用arr.length来表示。接下来说一下对象（object），属性有属性名和属性值组成，举个例子：1234567891011var mrDeng = &#123; name:&quot;XXX&quot;, age:33, lastName:&quot;xxx&quot;, wife : &#123; name:&quot;xxx&quot; &#125;, height:172, health:100&#125;document.write(mrDeng.name);//xxx 这两个今天就先讲到这里吧，后面还会比较详细的讲到。 编程形式的区别编程语言按照形式上分，有两类，第一种称之为面向过程，第二种称为面向对象。面向过程编程：主要是按照步奏来来进行编程，考虑是怎么做。典型例子为C语言。面向对象编程：包含面向过程编程，但是它主要考虑是处理方法，利用什么资源进行编程，更加的结构化。js即面向过程又面向对象。 typeof 运算符在我们处理数据的时候，经常需要关注数据的类型，这时候可以使用typeof运算符。 typeof（）运算符可以区分出数据的类型，他返回六种值，分别是object，number，string，undefined，boolean，function。返回的是形式都是字符串形式。它还有一个特点就是，当一个变量未经声明就使用时会报错的，但是利用typeof判断一个未经声明的变量，会返回undefined，但是不报错。了解了typeof之后，我们就可以正式介绍类型转换了。 举一些例子来看一下吧。12345var a = 123;typeof（a）;//出现numbervar a = NaNtypeof（a）;//出现number 这就很奇怪了，下面就一起来学习类型转换吧。 显式类型转换Number（）这个方法可以将传进去的参数转化为数字类型的数据，如果传进去的不能被转化为数字，就会返回NAN。 有个注意的地方就是，false,null，’’(空串)，会转化成0，undefined，NAN，都会转化为NaN。 举一些例子吧， 12345Number(&apos;asdfa&apos;) // NaNNumber(&apos;12333&apos;) // 12333Number(null) // 0Number(undefined) // NaNNumber(NaN) //0 parseInt()这个方法会将字符串转化为数字类型，并进行数字截断处理，当传入的是数字和字符串，它会把数字单独截取。第二个用法，就是它可以进行十进制数向其他进制数进行转化。举一些例子吧。123456var num = parseInt（xxx）;&quot;123&quot; //123undefined //NaN NaN //NaNvar num=parseInt(&quot;12a3&quot;);//12var num=parseInt(&quot;6&quot;,2)//将6转化为2进制, 110 parseFloat（）toFix（）parseFloat（）这个方法也是将参数转化为数字类型，但是它不可以进行进制的转换。var num=parseFloat(&quot;10.123&quot;) //10.123 toFix（）可以设定保留多少为有效数字.var a = 199.223; a.toFixed(2); //199.23 string()string():这个方法就是将传进的参数转化为字符串类型的数据。这个没什么好说的。 Boolean()boolean():这个方法就是将传进的参数转化为true，或者是false，只有那6个值为false。undefined,null,NaN,””,false,0。 toString()这个方法很重要，首先它可以将调用它的变量转化字符串，第二个就是它可以将调用它的变量转化为十进制。另外可以利用它来判断object和array。这个之后可以跟大家在介绍，今天就不展开了。 12var str = 123;var num = str.toString(2);//string类型,将10进制转化为2进制。 1234将2进制转化为8进制：var num=parseInt(&quot;1000&quot;,2);document.write(num.toString(8));先转化成2进制，再转化为8进制。 隐式类型转化isNaN（）NaN是一个很特殊的东西，它“六亲不认”，它任何东西都不等于，包括它自己。12NaN == NaN //falseNaN === NaN //false isNaN（）就是用来判断NaN的。它可以将传入的参数判断是否为NaN。 12isNaN(NaN) //trueisNaN(0) //false 其他的隐式类型转化一元正负运算符:12var a = &quot;1234&quot;;var b = a + 1; // 12341 当使用+ 号进行字符串和数字类型进行操作的时候，+号两边，会有一个隐式类型转换，就是将数字调用string，然后进行拼接。 还有就是++运算符，例如：123var a = &quot;123&quot;;//Number(a) ++document.write(a++ + &quot;:&quot; + typeof(a));//123:Number 会先把a转化为数字类型,在进行其他的计算。 “- * / %” 转化成number,&amp;&amp; || !转化成布尔值。&gt; &lt; &lt;= &gt;=在一侧是数字时转化成number。 1234underfined == 0 //falsenull == 0 //falsenull == underfined //true(特殊规定)``` var a = “10” &gt; “9”;document.write(a);//输出false(字符串会比较ASCII码)12还有：===绝对等于和 !==绝对不等于不会发生类型转换，只有2侧一致才返回true。 var a = 0 == “”; //truevar a = 0 === “”; //false12 var a=(“11”*3 + “2”)/2 //166, 33+”2” 等于”332”`好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的函数 ,谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"js的运算符及语句","slug":"js的运算符及语句","date":"2018-09-23T16:12:47.000Z","updated":"2018-09-24T15:31:57.186Z","comments":true,"path":"2018/09/24/js的运算符及语句/","link":"","permalink":"http://moreluckily.com/2018/09/24/js的运算符及语句/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。今天要讲一下JavaScript的运算符和JavaScript的一些基本语句。 JS的运算符运算符首先运算符分为：算数运算符，比较运算符以及逻辑运算符。 “+和-”运算符“+”和“-”运算符其实是一样的规则的，在这里我只介绍“+”运算符，他和”-“运算符是一样的，就不花大量的时间去介绍了。 在这里比较重要的两点：数学运算、字符串链接，而且任何数据类型加字符串都等于字符串。 下面举一些例子来说明这些问题： 12var a = &apos;a&apos; + 1 + 1 ; //得到: a = &apos;a11&apos;var a = 1 + 1 + &apos;a&apos; + 1;//得到: a = &apos;2a1&apos; 这里就需要注意运算时的优先级了。优先级”=“最弱，”()”优先级较高。而且运算时是从左向右运算的，和生活中的数学计算还是有一定的差别的。这里需要注意一下。 再来看一下这些例子： 12345var a = 1;var b = a++; //2var c = ++a; //3console.log(a++);//3console.log(++a);//5 由以上的例子我们可以知道，a++和++a是有区别的，a++是先进行该语句，再进行a+1，++a是先进行a+1，再进行该语句。 “/和%”运算符“/”就是数学中的除法，这个没什么特别的作用，“%”是取余的意思。举个例子吧。 12var a = 10 / 3;//3.3333333333333335var b = 10 % 3;//1 通过这个例子我们也能知道数字在浏览器中只能取小数点后的17位，而且第17位是不准确的。 在来看下面的例子： 12345678var a = 1.0000000000000001;var b = 1.0000000000000001;//小数点后16位var c = a + b;var d = 1.000000000000001;var e = 1.000000000000001;//小数点后15位var f = d + e;console.log(c);//2console.log(f);//2.000000000000002 从这里我们可以知道，浏览器只能计算小数点后15位的数据。 比较运算符比较运算符有“&gt;”，”&lt;”，”==”，“&gt;=”，“&lt;=”，”!=”等等，两个值的比较结果为boolean值，即只有true和false这两种结果，而且需要注意的是：比较运算符如果存在跟算术运算符一起出现的时候，先计算算术运算符部分，即算数运算符的优先级是要高于比较运算符的。 OK，接下来就举一些例子来对其进行说明： 12var a = 1 + 2 &gt; 2 + 2;//falsevar a = 3 &gt; 2 &gt; 1;//false 第一个，首先进行加减运算，即两边得到：3&gt;4，答案肯定是false。第二个，首先进行3&gt;2，答案是true，这里会发生一个隐式类型转换，即会将true转换为1，1&gt;1，答案当然是false。 逻辑运算符*首先要说的就是运算时，会发生隐式类型转换，有6个值会转换为false，其他的都是true。这个是必须要记住的。 underfined NAN null 0 “”（空串） false。这6个值会转换成false,然后再去进行计算。 &amp;&amp; 运算符这是我们常说的与运算符。先不说它的特点。那接下来举一些例子吧：1234var a = 1 &amp;&amp; 2;//2var a = 0 &amp;&amp; 2;//0var a = 3 &amp;&amp; 2 &amp;&amp; 1;//1var a = 1 + 2 &amp;&amp; 2 + 3;//5 &amp;&amp;运算符就是当前面的出现false时，就不看后面的结果，直接将0返回。当前面不为0时，就将后面的值返回，当也要注意的是：加减的优先级任然是高于逻辑运算符的。比较常见的应用就是短路语句了，举个例子：12var data;data &amp;&amp; fn(data);//data有数据才执行后面的函数 | | 运算符或运算符，||当前面为true,就返回前面的东西，||当前面为false,再看后面的东西。举一些例子来看一下：12var a = 1 || 2;//1var a = 0 || NaN || undefined;//undefined ! 运算符非运算符，就是取反的意思。这个没什么介绍的。 JS语句if( )语句如果if( )语句里面的判断是正确的话，那么就会走接下来的代码块，否则就跳过if语句。例如：123if(a)&#123; console.log(a); &#125; if( ) else 语句看例子： 1234567if(a)&#123;console.log(a)&#125;else&#123;var a = 5 ;console.log(a);&#125; 如果，a不为0就会打印出a，否则就进行else里的语句。 else if( )语句看例子:123456if(date is monday）&#123;console.log(&apos;monday&apos;)&#125;else if(date is tuesday)&#123;console.log(tuesday)&#125;else&#123;&#125; for循环语句这个是最常见的语句之一，看例子：123for(var i = 0; i &lt;= 10; i++;)&#123;console.log(i + &apos;,&apos;);&#125; //0,1,2....10 这个也比较好理解，我就不多说了。 while 循环语句这个语句跟for循环是差不多的，但是我们有时候可以利用它来进行递归，这样效率更高（少些几行而已）while（）括号里面直接填写的是判断条件，代码块写的就是执行语句。但是我们要注意，如果填入的是一个一直成立的表达式，那么它就可能会一直死循环下去。never-ending loop 无限死循环。 switch 语句这个语句相信大家都很熟悉吧，我先来举个例子：1234567891011var date = window.prompt(&apos;input&apos;);switch(date)&#123; case &quot;monday&quot;： doucment.write(&apos;working&apos;); case &quot;tuesday&quot;: document.write(&apos;working&apos;); case &quot;wendesday&apos;: document.write(&apos;working&apos;); case &quot;sunday&quot;: document.write(&apos;resting&apos;); &#125; 当输入monday，会出现working，working，working，resting。就需要优化：123456789101112var date = window.prompt(&apos;input&apos;);switch(date)&#123; case &quot;monday&quot; : case &quot;tuesday&quot; : case &quot;wendesday&quot; : document.write(&apos;working&apos;); break; case &quot;sunday&quot; : document.write(&apos;resting&apos;); break; defalut :document.write(&apos;nice!&apos;)//其他的情况；&#125; break停止的是里面的一个循环。外面的循环正常进行。（停止循环就用break），continue结束本次循环，继续进行下一次循环。 好了，今天的这篇blog就到这里结束了，下节课为大家讲解JS中的类型转换，谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"javaScript的历史","slug":"javaScript的历史","date":"2018-09-22T17:02:44.000Z","updated":"2018-09-23T15:45:21.913Z","comments":true,"path":"2018/09/23/javaScript的历史/","link":"","permalink":"http://moreluckily.com/2018/09/23/javaScript的历史/","excerpt":"","text":"新的blog，新的开始。今天我将和大家一起学习javaScript。 前面的html和css忘了一些不要紧，我们需要好好学习javaScript，因为前端工程师也可以叫做JS工程师，也就是说JS是前端最重要的，大家一起加油吧！ JS的发展史首先我要说一下javaScript的简称是js，而且js和java没有任何的关系，它俩是两个东西。现在介绍一下js的发展史吧！1994年4月，马克.安德森和Silicon Graphics（简称为SGI，中译为“视算科技”或“硅图”）公司的创始人吉姆·克拉克（Jim Clark）在美国加州设立了“Mosaic Communication Corporation”。Mosaic公司成立后，由于伊利诺伊大学拥有Mosaic的商标权，且伊利诺伊大学已将技术转让给Spy Glass公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为Netscape Navigator，公司名字于1994年11月改名为“Netscape Communication Corporation”，此后沿用至今，中译为“网景”。微软的Internet Explorer及Mozilla Firefox等，其早期版本皆以Mosaic为基础而开发。微软随后买下Spy Glass公司的技术开发出Internet Explorer浏览器，而Mozilla Firefox则是网景通讯家开放源代码后所衍生出的版本。 JavaScript作为Netscape Navigator浏览器的一部分首次出现在1996年。它最初的设计目标是改善网页的用户体验。初期JavaScript被命名为，LiveScript，后因和Sun公司合作，因市场宣传需要改名JavaScript。后来Sun公司被Oracle收购，JavaScript版权归Oracle所有。 浏览器组成浏览器分为shell部分和内核部分。内核部分又有渲染引擎（语法规则和渲染），和Js引擎以及其他模块。最出名的就是谷歌公司chrome的js引擎，就是著名的v8引擎。它的特点就是可以直接把js编译为机器码，所以这速度是最快的，后来许多浏览器也有了自己的js引擎。 js引擎的发展： 2001年发布ie6，首次实现对js引擎的优化。2008年Google发布最新浏览器Chrome，它是采用优化后的javascript引擎，引擎代号V8，因能把js代码直接转化为机械码来执行，进而以速度快而闻名。后Firefox也推出了具备强大功能的js引擎Firefox3.5 TraceMonkey（对频繁执行的代码做了路径优化）Firefox4.0 JeagerMonkey 同步和异步同步就是，同一时间只能干一件事情。异步就是，同一时间可以干多件事情。 单线程，同一时间，只能干一件事情。 多线程，同一时间，能干多个事情。 js的特点解释型语言计算机语言可以分为两种，第一种称为编译性语言，第二种称为解释性语言。 编译性语言：通篇翻译完，再执行一遍，然后生成一个编译文件，执行的是编译文件，优点是：比较快，缺点：跨平台差。典型的例子：C，C++等 解释型语言：翻译一行，执行一行，缺点就是：速度慢，优点是：可以跨平台。典型代表：PHP，Python，js。 注意比较常见的一种语言：Java，它属于两者之间，既不是编译型语言，也不是解释型语言。通过javac弄成.class文件，有兴趣的可以去百度一下。 js就是单线程的，同一时间只能干一件事。但我们可以让它看起来像多线程一样。举个例子，就像我们吃饭一样，吃一口饭，再吃一口菜，吃完之后，我们将这段时间快进快进，现在看碗里的饭和盘里的菜。我们可以看见饭和菜是同时慢慢减少的。这就是js的执行队列。 ECMA标注 — 为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格JavaScript兼容于ECMA标准，因此也称为ECMAScript。 开始学习JSJS分为三大部分，ECMAScript ， DOM，BOM。前两个最重要，ECMAScript是基础，DOM可以操作html和CSS。而BOM可以操作浏览器，那这样的话就权限太大了，在开发中是不允许。 JS的引入JS的引入方式和CSS类似，首先介绍第一种方式，就是页面级js，在head或者body中加入：&lt;script&gt;js的内容&lt;/sxript&gt;第二种方式就是外部js形式，一般在head标签里加：&lt;script src=&quot;lesson1.js&quot;&gt;&lt;/script&gt;为符合web的开发标准：结构html、样式css、行为js相分离，通常采用外部引入。 有一点需要注意的就是：JS文件加载的时候，它会把所有内容都阻塞了，所有东西都不能够进行操作，必须要等到JS加载完才能进行操作。所以我们最后一般将script标签放在body标签的底部。避免js文件阻塞html和CSS的运行。 js的基本语法JS中的变量（variable）一个变量，肯定首先需要对这个变量进行声明。var a;然后对变量进行赋值：123var a;a = 1;var a = 1; 前两句的效果和第三句的效果是一模一样的。当声明多个变量时，可以这样来写：12345var a,a,b,c,d;var a,//一般都这样来写 b, c, d; 变量的命名规则1、变量名必须以英文字母、_、$ 开头 2、变量名可以包括英文字母、_、$、数字 3、不可以用系统的关键字、保留字作为变量名 那js中有哪些关键字和保留字呢？看下面这张图： 这些我们并不需要去背。 js的基本语法数据类型数据的类型分为两大类，原始值和引用值。 原始值（栈数据） Number，数字类型。例如：1,2,3… String，字符串类型。例如：”123”,’123’。要用单引号或双引号包裹起来 Boolean，布尔类型，只有:true,false。 Undefined，未定义，只有一个，它自己本身undefined Null，空，也只有一个，null 引用值（堆数据）前期先介绍三类： Array，数组。例如：[1,2,3] Object，对象。例如：{name : “wang”,age : 20 } Function，函数，例如：function () {} 栈数据和对数据的区别栈（stack）数据，类似一个框，只有一个口。先进后出。first in last out。堆（heap）数据，指向的是堆的地址。 那我们来分析一下下面代码的情况： 12var a = 1;a = 2; 首先，js向系统索取了一个地址，假设为1000，来放a这个变量，然后赋值为1。然后当我们修改这个变量的时候，原来的1000地址的名字将不再为a，但是它的数据仍然存在。这个时候系统将另外取一个地址，假设为1001，这个地址将会命名为a，并且，值为2。它并不是真正意义上的删除，而是将原来的地址名字删掉，并重新赋值一个新地址而已。 js语法句的基本规则1、语句后面要用分号结束“；” 2、js语法错误会引发后续代码终止，但不会影响其它js代码块 3、书写格式要规范，“= + / -”两边都应该有空格 好了，今天的这篇blog就到这里结束了，谢谢大家的陪伴，希望大家能有所收获。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://moreluckily.com/categories/javaScript/"}],"tags":[{"name":"-javaScript","slug":"javaScript","permalink":"http://moreluckily.com/tags/javaScript/"}]},{"title":"制作百度主页","slug":"制作百度主页","date":"2018-09-22T16:01:06.000Z","updated":"2018-09-22T15:50:26.150Z","comments":true,"path":"2018/09/23/制作百度主页/","link":"","permalink":"http://moreluckily.com/2018/09/23/制作百度主页/","excerpt":"","text":"新的blog，新的开始。今天我将带着大家一起制作百度主页。 百度主页的制作首先是html的框架：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;div class=&quot;navSection&quot;&gt; &lt;ul&gt; &lt;li class=&quot;more&quot;&gt; &lt;a href=&quot;#&quot;&gt;更多产品&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;light&quot;&gt; &lt;a href=&quot;#&quot;&gt;设置&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;light&quot;&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;视屏&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;地图&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;hao123&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;糯米&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;searchSection&quot;&gt; &lt;div class=&quot;logoSection&quot;&gt; &lt;img src=&quot;./src/img/bd.png&quot; alt=&quot;baidu&quot;&gt; &lt;/div&gt; &lt;div class=&quot;keywordSection&quot;&gt; &lt;form action=&quot;/&quot; method=&quot;GET&quot;&gt; &lt;div class=&quot;inputSection&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottonSection&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;infoSection&quot;&gt; &lt;div class=&quot;codeSection&quot;&gt; &lt;img src=&quot;./src/img/code.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;手机百度&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;messageSection&quot;&gt; &lt;p class=&quot;topP&quot;&gt; &lt;a href=&quot;#&quot;&gt;把百度设为主页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;关于百度&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;About Baidu&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百度推广&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;bottomP&quot;&gt; &lt;a href=&quot;#&quot;&gt; ©2017 Baidu 使用百度前必读 意见反馈 京ICP证030173号 &lt;/a&gt; &lt;span class=&quot;icon1&quot;&gt;&lt;/span&gt; &lt;a href=&quot;#&quot;&gt; 京公网安备11000002000001号 &lt;/a&gt; &lt;span class=&quot;icon2&quot;&gt;&lt;/span&gt; 然后就是css的内容来修饰这个框架了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151*&#123; margin: 0px; padding: 0px; list-style: none; font-family: arial;&#125;/* 导航区域css */ .navSection&#123; height: 60px;&#125;.navSection ul::after&#123; content: &quot;&quot;; display: block; clear: both;&#125;.navSection ul li&#123; height: 60px; line-height: 60px; float: right; margin-right: 15px;&#125;.navSection ul li a&#123; color: #333; font-size: 13px; font-weight: bold; /* text-decoration:none; */&#125;.navSection ul .light a&#123; font-weight: normal;&#125;.navSection ul .more &#123; margin-right: 30px;&#125;.navSection ul .more a&#123; color: #fff; background-color: #38f; padding: 6px 4px; text-decoration: none; font-weight: normal;&#125;/* 搜索区域css */.searchSection&#123; margin-top: 40px; text-align: center;&#125;.searchSection .logoSection &#123; /* text-align: center; */ margin-bottom: 20px;&#125;.searchSection .logoSection img&#123; width: 270px; height: 129px;&#125;.searchSection form div&#123; display: inline-block;&#125;.searchSection form .inputSection&#123; vertical-align: top; position: relative;&#125;.searchSection form .inputSection input&#123; width: 539px; height: 34px; padding-left: 15px;&#125;.searchSection form .inputSection span&#123; position: absolute; right: 10px; top: 50%; width: 18px; height: 16px; margin-top: -8px; background-image: url(../img/camera.png); background-position: 0px 0px; cursor: pointer;&#125;.searchSection form .inputSection span:hover &#123; background-position: 0px -20px;&#125;.searchSection form .bottonSection&#123; margin-left: -5px;&#125;.searchSection form .bottonSection input&#123; width: 100px; height: 38px; background-color: #3385ff; border: none; color: #fff; font-size: 15px;&#125;/* 信息展示区 */.infoSection &#123; text-align: center; margin-top: 270px;&#125;.infoSection .codeSection span &#123; display: block; font-size: 12px; font-weight: bold; color: #666;&#125;.infoSection .codeSection &#123; margin-bottom: 30px;&#125;.infoSection .messageSection p a&#123; color: #999; margin-right: 20px;&#125;.infoSection .messageSection .topP &#123; margin-bottom: 10px;&#125;.infoSection .messageSection .bottomP span &#123; display: inline-block; width: 14px; height: 17px; margin-left: -20px; margin-right: 20px; background-image: url(&apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/global/img/icons_5859e57.png&apos;);&#125;.infoSection .messageSection .bottomP .icon1 &#123; background-position: -600px -96px;&#125;.infoSection .messageSection .bottomP .icon2 &#123; background-position: -623px -96px;&#125; 这样一个百度主页就完成了，我们来看一下效果吧！ 看到这个效果，是不是特别开心和自豪呢？ 好了，今天到这就把前端的html和css告一段落，下篇blog将继续和大家一起学习javaScript，大家和我一起加油吧。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css -html","slug":"css-html","permalink":"http://moreluckily.com/tags/css-html/"}]},{"title":"css学习5","slug":"css学习5","date":"2018-09-22T14:07:33.000Z","updated":"2018-09-22T15:30:48.753Z","comments":true,"path":"2018/09/22/css学习5/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习5/","excerpt":"","text":"从小到大我们都在听着别人的声音给自己的人生划格子，左边的这条线是要学业有成，右边的这条线是一定要有一个安稳的好工作，上面的这条线是三十岁之前要结婚，下面的这条线就是你结了婚一定得生个孩子，好像只有在这个格子里面才是安全的，才被别人认为是幸福的。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 溢出打点溢出打点是什么？ 一上来我们肯定会有这样的问题。其实在百度的网页中，这是特别常见的。我们先来看一下： 在文字的结尾处，我们发现内容并没有显示的特别完整，文字的最后是以“…”的形式结束的，这个效果是怎么实现的呢？ 首先是单行打点的情况：在标签中，当文字快溢出容器的时候，它们是会自动换行的。但是一旦换行，我们就不会有那种打点的效果了。这时候，有一个属性： white-space:nowrap; 它会使文字失去换行的本领。 这时候，文字就不会自动换行了，但是又要怎样才能让它出现“…”的形式呢？这时候又有一个属性： txet-overflow:ellipsis; 这就是文字溢出之后是ellipsis（省略），也就得到了文字溢出打点的效果。 最后当然也需要将溢出的文字隐藏起来，这就实现了文字溢出打点的效果了。 这三个东西配合，也就是三件套配合，会得到溢出打点的效果。举个例子来看一下吧。 1234567891011&lt;div&gt;有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。&lt;/div&gt;div&#123; width:200px; height:60px; border:1px solid black; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; &#125; 它的效果特别明显了，如下图所示： 可以看到，文字省略的部分已经用了“…”来代替了。 这个是单行打点，如果是多行文字打点呢？鉴于兼容性，多行文字我们一般不做打点处理，一般做多行文字截断处理。 而且在百度中常见的多行文字打点是什么情况呢？我们检查一下里面的情况，我们可以发现如下情况： 通过该图片我们可以发现，直接用的就是“…”的形式，即没有用技术的手段是实现索航文字打点技术。 背景图片当引用一张图片的时候，这些图片就是当做背景图片来进行设定的。 首先我们来了解一下背景图片的几个属性 1234567background-image:url(adress);//图片地址background-repeat:no-repeat;//图片不重复,不允许平铺background-repeat:repeat-x;//图片向x轴平铺background-repeat:repeat-y;//图片向y轴平铺background-size:100px 100px;//图片大小background-position:50% 50%;//图片位置,放在正中间 background-position:center center;//图片位置,放在正中间 先说一下 background-repeat，如我们不设定这个属性，当引入一张图片的时候，如果图片大小不等于容器大小的话，它们会自动重复，直到铺满容器。 第二再说一下background-position,这里的50%直接就是居中到容器中心，不需要在调整margin。还可以设定left center表示左边居中，当然还有bottom值来进行设定，可以灵活运用进行图片的定位。当background-size设定为100%的时候，就是直接铺满整个容器。 background引入图片的时候，存在网络不好，这时候就只加载html，不加载css和javaScript，图片显示不出来的时候，我们需要想利用img标签那样给它添加文字，怎样做呢？这里有2中方法去实现。 1、第一种方法，先让文字溢出，然后强制不换行 1234567891011121314&lt;a href=&quot;#&quot;&gt;淘宝&lt;/a&gt;a&#123;display:block;text-decoration:none;width:142px;height:58px;border:1px solid balck;background-image:url(address); background-repeat:no-repeat;background-size:100% 100%; text-indent:150px;//缩进大于容器宽度 让文字出去 white-space:nowrap;//不换行overflow:hidden;&#125; 2、这个是重点，比较常用。利用padding来显示背景图。当css加载不出来的时候，显示文字。 12345678910111213&lt;a href=&quot;#&quot;&gt;淘宝&lt;/a&gt;a&#123;display:block;text-decoration:none;width:142px;height:0px;border:1px solid balck;background-image:url(address);back-repeat:no-repeat;background-size:100% 100%; overflow:hidden;//文字溢出隐藏padding-top:100px;//利用padding来放背景图。&#125; 比较常用的实战方法 inline-block元素或者block元素可以嵌套任何元素 行级元素可以嵌套行级元素 p标签里不能放块级元素 a标签里不能放a标签 父子关系别写太多，4层5层就行了，写多了就浪费效率 float浮动模型实战上一篇blog由于篇幅的影响，今天再来对其进行实战。来实现显示淘宝的标价和多少人付款。 123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;span class=&quot;price&quot;&gt;$1000&lt;/span&gt; &lt;span class=&quot;offer&quot;&gt;20人付款&lt;/span&gt;&lt;/div&gt; *&#123; margin:0; padding:0; font-family: arial;&#125;div&#123; width: 200px; border:1px solid black; *zoom:1;&#125;div::after&#123; content: &quot;&quot;; display:block; clear:both;&#125;.price&#123; float:left; color:#f40; font-weight: bold;&#125;.offer&#123; float:right; font-size: 12px; color:#999; margin-top: 2px;//可以调节&#125; 实现的效果图如下图所示： 通过这个例子，你是不是对其理解的更加深刻呢？是不是觉得WEB前端特别有意思。 好了，今天到这就把前端的基础和css讲完了，下篇blog将带着大家把百度的主页做出来，当然我们也可以做淘宝的静态主页了。淘宝的静态主页就不在blog中放出来了，大家可以加我微信一起交流，谢谢大家！","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习4","slug":"css学习4","date":"2018-09-22T13:01:39.000Z","updated":"2018-09-22T14:10:48.286Z","comments":true,"path":"2018/09/22/css学习4/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习4/","excerpt":"","text":"这个世界那么大、那么精彩，你什么都还没有看到过的时候就甘心的呆在一个格子里面，循规蹈矩安分守己地生活，这样的生活没有任何的风险，也不会被别人嘲笑，但是我总觉得一个没有把百酒都尝遍的人他是不大懂得清水之味的。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 两栏布局*这是一个经常考的一个问题，两栏布局问题也是一个特别重要的问题之一，它的题目是右侧固定，左侧自适应。也就是无论浏览怎么拉伸和收缩，右侧的一部分内容不会发生变化，而左侧的那部分内容进行自适应。123456789101112131415161718192021222324&lt;div class=&quot;left&quot;&gt;举个例子举个例子举 个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例子举个 例子举个例子举个例子&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;//写这么多字，让我们看起来更加的直观。*&#123; margin:0; padding:0;&#125;.left&#123; margin-right: 100px; (重点) height: 100px; background-color: green;&#125;.right&#123; position: absolute; top:0; right:0; width: 100px; height: 100px; background-color: red; opacity: 0.5;&#125; 会得到如下图所示的图形，由此我们知道，改变浏览器的宽度，不会使右侧的更改了透明度的红色正方形方块发生变化。 三栏布局*这是一个经常考的一个问题，三栏布局问题也是一个特别重要的问题之一，它的题目是右侧和左侧固定，中间部分自适应。也就是无论浏览怎么拉伸和收缩，右侧和左侧的一部分内容不会发生变化，而中间的那部分内容进行自适应。 123456789101112131415161718192021222324252627282930313233&lt;div class=&quot;middle&quot;&gt;举个例子举个例子举 个例子举个例子举个例子举个例子举个例子 举个例子举个例子举个例子举个例子举个例子举个例 子举个例子举个例子举个例子举个例子举个例子举个例子 举个例子&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;*&#123; margin:0; padding:0;&#125;.left,.right,.middle&#123; height: 100px;&#125;.left,.right&#123; position: absolute; width:100px; opacity: 0.5;&#125;.left&#123; top:0; left:0; background-color: red;&#125;.right&#123; top:0; right: 0; background-color: green;&#125;.middle&#123; margin:0 100px; background-color: blue;&#125; 会得到如下图所示的图形，由此我们知道，改变浏览器的宽度，中间自适应，两边的东西大小不会发生改变。 float浮动模型**float属性是一个古老的属性。它是用的最频繁的布局属性，以前它是专门为了实现文字环绕效果而设置的。就是用来为报纸设计的一个功能属性。但是对于响应式布局来说，float不具容错性比较差，容易出现比较严重的布局问题，而且他还可能带来一些其它问题，例如父元素塌陷，以及其它兼容性的问题。 文字环绕图片1234567891011&lt;img src=&quot;C:/Users/Administrator/Desktop/hg.jpg&quot; alt=&quot;这是胡歌&quot; class=&quot;left&quot;&gt;很多胡歌加油*&#123; margin: 0; padding: 0;&#125;.left&#123; width: 100px; float: left; margin-right: 1px; margin-bottom: 1px;&#125; 我们可以看到下图所示的样子：就像报纸一样，是不是特别有意思呢？哈哈哈。 float模型的特点float模型的feature（特点）：产生浮动流，只有块级元素（block）看不见浮动元素，所以块级元素会占据浮动元素原来的位置。文本（文字），文本类元素（inline,inline-block）,并且触发了bfc的元素都能看到浮动元素，并且会排列到浮动元素的后面。 clear加伪元素clear是用来对抗float的。而且只有块级元素才能用clear。通常，我们会使用到伪元素来进行clear。 伪元素又是什么呢？ 看下这个例子：123456789101112131415161718&lt;span&gt;加油&lt;/span&gt;*&#123; margin: 0; padding: 0;&#125;span&#123; background-color: red;&#125;span::before&#123; content: &quot;lucky&quot;; display: inline-block; width:60px; height: 20px; background-color: green;&#125;span::after&#123; content: &quot;Fighting&quot;; background-color:orange; 会得到如下的图形: 伪元素：（天生就存在），可以当元素使用，但是inline元素要改成display:inline-block。每个标签都有2个伪元素。 浮动的解决办法只有块级元素才可以清除浮动，这里有个标准。3+1标准：123456father&#123;*zoom：1；&#125;father::after&#123;//注意这里写的是两个冒号，主要的是跟伪类进行区分content:&quot;&quot;; //注意的是，即使content没有内容，也需要写display:block;clear:both;&#125; 实例讲解float浮动模型**这个例子就是淘宝的导航栏：我们使用float浮动模型来对它的一部分导航栏进行制作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;淘抢购&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;电器城&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;司法拍卖&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;*&#123; margin: 0; padding: 0; text-decoration: none; color: #424242; font-family: arial;&#125;.nav&#123; //3+1清除浮动 list-style: none; *zoom: 1;&#125;.nav::after&#123; content: &quot;&quot;; display: inline-block; clear:both;&#125;.nav .nav-item&#123; float: left; margin: 0 8px; height: 25px; line-height: 25px; font-weight: bold;&#125;.nav .nav-item a&#123; height: 25px; padding: 0 5px; display: block;&#125;.nav .nav-item a:hover&#123; border-radius: 15px; background-color: #f40; color:#fff;&#125; 得到的效果图就是如下图所示： 可以看到这个导航栏使用浮动模型来写的，基本和淘宝的导航栏是一样的。是不是特别有意思。鼠标放在哪个导航栏上，导航栏就会变色，你们可以去淘宝上看是不是这样的，哈哈。 这一篇blog就先讲到这里，下篇blog会更有意思。谢谢大家。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习3","slug":"css学习3","date":"2018-09-22T12:21:19.000Z","updated":"2018-09-22T14:06:07.550Z","comments":true,"path":"2018/09/22/css学习3/","link":"","permalink":"http://moreluckily.com/2018/09/22/css学习3/","excerpt":"","text":"你要相信，命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，这个故事关于独立，关于梦想，关于勇气，关于坚韧，它不是一个水到渠成的童话，没有一点点人间疾苦。这个故事是有志者，事竟成，破釜沉舟，百二秦关终属楚，这个故事是，苦心人，天不负，卧薪尝胆，三千越甲可吞吴。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 层模型*说起层模型这个名字，可能大家会想到我的上篇blog中的盒模型，但不是一个东西哈，它俩的区别还是挺大的。首先来介绍一下position这个属性，它有几个常见的值，常见的有三个值，static，absolute，relative。position：absolute；这个属性它的feature(特点）是：脱离原来位置进行定位，相对于最近的有定位的父级（bfc）进行定位，如果没有，那么相对于文档（document）（浏览器边框）进行定位。position：relative；保留原来位置，进行层定位。相对于自己（出生）原来的位置进行定位。我下面介绍一个例子去帮助大家去理解层模型。 1234567891011121314151617181920212223242526&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;*&#123; margin: 0; padding: 0;&#125;.demo&#123; position: absolute; width: 100px; height: 100px; background-color: red; opacity: 0.5;//透明度，更好观察 left: 100px; top: 100px; z-index: 5;//层的设定，大于下面的就行&#125;.demo2&#123; position: absolute; width: 150px; height: 150px; background-color: green; top: 10px; left: 10px; z-index: 1;&#125; 得到的结果如下图所示： 可以看见红的在上面，当设置的z-index比下面的小时，则green在上面。 接下来在介绍一下position：relative；它在进行定位的时候，元素首先会出现在自己的位置上，然后再根据left，top的值，以自己原来的位置进行定位。 最后提一下position：fixed，相对于可是窗口进行定位，典型的例子就是网页中的小广告，窗口无论怎样往下走，他都是固定的位置不动，在两边的固定位置不变。但IE6中没有fixed（注意）。 居中布局*12345678910111213141516&lt;div&gt;&lt;/div&gt;*&#123; margin: 0; padding: 0;&#125;div&#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 50%; top: 50%; margin-top: -50px; margin-left: -50px;&#125; 它的效果图不就不在这里给出了，因为图可能会比较大，我把现象和大家说一下吧，就是会有一个长宽都为100px的正方形红色的方块在整个浏览器的正中间居中了。 简单的居中五环*了解了居中的情况，我们就能写一个简单的居中的五环了，是不是很有趣呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div class=&quot;plat&quot;&gt; &lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle5&quot;&gt;&lt;/div&gt;&lt;/div&gt;*&#123; padding:0; margin:0;&#125;.plat&#123; position: absolute; left: 50%; top: 50%; margin-top: -95px; margin-left: -190px;&#125;.circle1,.circle2,.circle3,.circle4,.circle5&#123; position: absolute; width: 100px; height: 100px; border-width:10px; border-style: solid; border-radius: 50%;&#125;.circle1&#123; left: 0px; top: 0px; border-color: red;&#125;.circle2&#123; left: 130px; top: 0px; border-color: green;&#125;.circle3&#123; left: 260px; top: 0px; border-color: yellow;&#125;.circle4&#123; left: 65px; top: 70px; border-color: blue;&#125;.circle5&#123; left: 195px; top: 70px; border-color: orange;&#125; 会出现如下图所示的一个简单的五环，这个颜色是我随便取得，并不是真正的五环的颜色。 这一篇blog就先讲到这里，下篇blog特别重要。谢谢大家。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习2","slug":"css学习2","date":"2018-09-21T07:02:33.000Z","updated":"2018-09-22T12:17:05.893Z","comments":true,"path":"2018/09/21/css学习2/","link":"","permalink":"http://moreluckily.com/2018/09/21/css学习2/","excerpt":"","text":"年龄越大，越学会了顺其自然，以前总认为坚持会让人更强大，但是长大后才发现，让我们强大的是放下。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 css渲染机制section div ui li a em { }。计算机找这些标签的时候是从右向左找的，一步一步的过滤。这样找的时间最短，速度最快。这个就是css渲染机制，在上一篇blog中提到过这一点。 css属性*接下来说一下常见的css属性： 1、background-color：设定背景颜色 2、color：设定字体颜色 3、font-size：设定字体大小，默认字体大小为16px，这里设定的是字体的高，如果设定字体宽就会显得参差不齐。 4、font-weight：设定字体粗细，常用值为bold（加粗），normal（正常），lighter（细），一般只有bold和normal好使，这取决于浏览器的字体包是否有我们需要的字体。还可以通过integer这个属性来设置，100|200..|900 改变粗细，具体的写法是：font-weight:100,200…strong天生有这个属性。 5、font-style：italic，改变字体为斜体。em标签是天生就有这个属性。 6、font-family：字体，通用字体就是font-family: Arial。 这个字体是最好看的，最美观的。 颜色的三种表示方法1、直接形式英文的green，blue，yellow，red等，表示的是比较含糊的值。 2、颜色代码十六进制表示：光源三原色rgb，两位两位的十六进制数，0-ff，颜色饱和程度，0表示没有颜色混合； rgb 对应都是两位重复，则可以简写。 它的写法是：例如：#ffff00，可以简写为#ff0；#f0f0f0，就不能进行简写了。最常见的就是淘宝红#f40了。3、颜色函数rgb代表顺序Red(红色)、Green(绿色)和Blue(蓝色)。它的写法就是：rgb(255，255，255) 白色rgb(255，0， 0)代表红色rgb(0，255， 0)代表绿色rgb(0， 0，255)代表蓝色 css盒模型*首先来了解一下css盒模型的一些概念。 1、content：内容区，大小为width乘height。就是我们以前经常写的东西。2、padding：内边距，用来进行分隔边框和content，可以理解为缓冲位置。分上下左右四部分，设定的时候我们可以这样来写：123456padding:30px;//(表示上下左右全部为30px)padding:30px 20px 10px 20px;//(顺序为:上右下左，顺时针,进行设定内边距）padding:50px 20px 30px;//(顺序为:上 左右 下）padding:50px 30px;//(顺序为:上下 左右） 当然也可以通过padding-left，right，top，bottom分别来进行设置。 3、border：边框12345border-width:10px 20px 30px 40px;border-style:solid;border-color:balck;//边框的颜色border:1px solid black;//产生边框的形象，1px边框的粗细border-top-width:10px;//左边框的长度 style表示的是边框的样式为实线，color表示颜色为黑色，边框粗细为上右下左10px，20px，30px，40px像素，border设定粗细的时候顺序问题跟padding是一样的。上面是几种不同的设置方法，但最后都能得到我们想要的结果。 4、margin：外边距，设定盒子与盒子之间的距离。可以单独设置。但是margin不属于有色区域，计算盒子模型的大小的时候，不需要考虑其大小。5、盒模型图通过上面的介绍，其实我们得到一张盒模型的图：这个图就能特别清晰明了的知道了整个盒模型的基本情况。 6、远视图效果通过这些知识，我们就能写一个比较小的好玩的东西了，下面我就做了一个远视图效果的东西。123456789101112131415161718192021222324252627282930&lt;div class=&quot;wrapper1&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.box&#123; width: 20px; height: 20px; background-color: red;&#125;.content&#123; width: 20px; height: 20px; background-color: blue; padding: 20px;&#125;.wrapper&#123; width: 60px; height: 60px; background-color:red; padding: 20px;&#125;.wrapper1&#123; width: 100px; height: 100px; background-color:blue; padding: 20px;&#125; 得到的效果是如下图所示：当然还可以继续多加几层，是不是特别好玩呢？ margin塌陷问题先来看一下什么是margin塌陷：1234567891011121314&lt;div class=&apos;father&apos;&gt; &lt;div class=&apos;son&apos;&gt;&lt;/div&gt;&lt;/div&gt;.father&#123; width:200px; height:200px; background-color:red; &#125;.son&#123; margin-top:50px; width:100px; height:100px; background-color:green; &#125; 我们可以看到的现象是如下图所示： 子元素加上绿色，父元素为红色，理论上我们给子元素设置margin-top，绿色顶部应该跟黄色会产生一段距离，但是现在的问题就是，子元素带动父元素一起移动了50px，这就是margin塌陷问题。那怎么解决这个问题呢？就是让子元素离父元素的顶部50px，但父元素不移动。 margin塌陷解决1、第一种方法就是父级元素的顶部没了，塌陷了，那我给他加一个顶。border-top:10px solid black;这样虽然结决了这块的问题，但是在开发整个页面的时候是不行的，这个方法特别不靠谱，不能用这个方法。那就引出了下面的第二个方法了。 2、触发bfc机制，什么是bfc呢？bfc的全称是bfc-block format content。每一个盒模型都会有它们默认的一套渲染机制，就是我们平常用的都属于它们的默认渲染机制，在这套机制里面，会存在margin塌陷的问题，这时候，我们需要利用另一套渲染机制来进行渲染，这就叫做利用触发bfc了。那怎样触发bfc呢？ 在这里先只介绍三种方法： overflow:hidden; //溢出隐藏position：absolute;float浮动 当我们在父级father触发bfc即可得到我们想要的情况，操作方法如下。12345.father&#123; width:200px; height:200px; background-color:red; overflow:hidden; &#125; 操作完成之后，我们在重新进入以下页面，尽可以看见正常位置了，也就是我们想要得到的东西。 margin合并问题margin合并讨论的就不是父子结构了，而是兄弟结构。一个设定了margin-bottom,另外一个设定了margin-top，这两个取的是更大的一个，它们并不会产生更大的间距。这时候我们需要在其中一个兄弟元素中套上一个父级标签，对父级标签触发bfc即可解决这个问题。但是通常我们不会通过这种方法解决margin合并的问题，因为这样会带来其他的反效果。我们通常就直接取其中的最大值来用就行了。 好了，这篇blog到这里就结束了，希望大家喜欢。","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"css学习1","slug":"css学习1","date":"2018-09-21T03:58:39.000Z","updated":"2018-09-21T07:02:58.117Z","comments":true,"path":"2018/09/21/css学习1/","link":"","permalink":"http://moreluckily.com/2018/09/21/css学习1/","excerpt":"","text":"我根本不知道我将来想要过什么样的生活，我根本不知道我将来想过什么样的生活，去哪个城市，做什么工作，我只是知道自己不想要什么，我不想要那种循规蹈矩、安安分分的平平淡淡的日子，不想要一个一眼就可以看到死的生活。 新的blog，新的开始。今天我将带着大家一起继续学习css中一些特别重要的的知识。 浏览器的一些必备知识浏览器是由2大部分组成的，shell外核部分和内核部分。外核相对比较好做，但内核才是一个浏览器的核心。目前来说世界上主流浏览器有:1、微软 IE浏览器，它的内核是：trident。2、谷歌 Chrome，它的内核是：blink/webkit。3、苹果 Safari，它的内核是：webkit。4、火狐 Firefox，它的内核是：gecko。5、欧朋 Opera，它的内核是：presto 。它的兼容性特别好，这个浏览器可以在Windows、Mac和Linux三个操作系统平台上运行。在这里补充一点：以前谷歌和苹果一起开发的内核webkit，后来谷歌单独开发了一个内核blink，所以chorme内核写了两个，但现在基本都说是blink内核。 在这里还是强调一下，html 负责框架，css 负责内容， javascript 负责行为css的引入方式css的全称是cascading style sheet，也就是层叠样式表，必须依赖于html来进行操作，用以负责网页的内容。 它在html中引入的方式有三种： 1、行间样式，在标签里直接进行设置。例如：&lt;div style=&#39;width:100px;height:100px;background:red;&#39;&gt;&lt;/div&gt;2、页面级css，直接在html文件中，添加一个style标签，在style标签中进行css的设置。例如：1234567&lt;style type=&quot;text/css&quot;&gt; &lt;div&gt; width:100px; height:100px; background:red; &lt;/div&gt;&lt;/style&gt; 3、外部引入的方式，利用link标签，进行引入。一般在head中放入。&lt;link rel=&#39;stylesheet&#39; href=&#39;相对地址或绝对地址&#39;&gt; css的加载机制当我们引入了css之后呢，要介绍一下，是怎样加载的css文件的，在这里我们就要理解一下异步和同步的概念了。 异步的，并行的；在计算机术语中，异步是并行的，多线程的；同步的，串行的；在计算机术语中，同步指的是串行的，单线程，一个时刻只能干一件事情。这块可能我说的有点问题，大家可以在网上进行相关资料查找。当浏览器加载html文件的时候，是加载一行执行一行，当读到link标签的时候，会另开一个线程加载css，即异步加载css，html继续加载，css也一起加载，成一种“你干你的，我干我的”情况，这就是css的异步加载机制，这个很重要。 css选择器***在引入了css之后，若想添加样式，css的选择器就登场了。什么是css选择器呢？就是通过选择器，来确定某个或某种元素，以供我们进行样式的设定。下面就给大家介绍一下具体有哪些选择器。 1、id选择器当在一个标签中添上一个id，就可以通过该id选择器，将html中的框架和css内容进行联系起来。例：123456&lt;div id=&quot;only&quot;&gt;&lt;/div&gt;//html中的框架#only&#123; width:100px; height:100px; background-color:red; &#125; //css中的内容 id选择器，使用“#”+id来选择出对应的框架，然后将这个框架中的内容用css来补充。id选择器是一对一的。 2、class选择器123456&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;.demo&#123; width:100px; height:100px; background-color:red; &#125; 和id类似，其主要的形式如上面的程序所示。class选择器是多对多的。 3、标签选择器123456&lt;div&gt;&lt;/div&gt;div&#123; width:100px; height:100px; background-color:red; &#125; 和上面的标签类似，我们能够特别简单的就能理解了。 4、通配符选择器123*&#123; background-color:red; &#125; 这里注意一下，通配符选择器是将全部的标签都进行选择，包括html，head，body等标签。这里是将整个页面都变成红色。 5、属性选择器1234567&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;[class]&#123; width:100px; height:100px; background-color:red; &#125; 这里就是有class的全被选择了,当然也可以将class=”demo”写全，那就只选择一个了。 css选择器优先级比较介绍了这么多的选择器，我们不禁要想，如果有两个或者多个的选择器都选择了同一个元素的时候，而且这些选择器中的内容都不一样，那这个元素应该设置成什么样的样式呢？应该听谁的呢？举几个例子：1234567891011&lt;div id=&apos;only&apos; class=&apos;demo&apos;&gt;d&lt;/div&gt; #only&#123; width:100px; height:100px; background-color:red; &#125; .demo&#123; width:100px; height:100px; background-color:green; &#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现红色。也就是说id选择器的优先级是高于class选择器的。 123456&lt;div id=&apos;only&apos; style=&apos;background-color:green;width:100px;height:100px;&apos;&gt;&lt;/div&gt;#only&#123; width:100px; height:100px; background-color:red;&#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现green。也就是说行间样式的优先级是高于id选择器的。 1234567891011&lt;div class=&apos;demo&apos;&gt;123&lt;/div&gt; [class]div &#123; width:100px; height:100px; background-color:green; &#125; .demo&#123; width:100px; height:100px; background-color:red; &#125; 这个时候div应该是什么颜色呢？我们可以试一下，在浏览器中会出现red，但当.demo和[class]互换一下位置，此时浏览器会出现green。也就是说class选择器的优先级是等于属性选择器的。 css选择器权重*在这里就引出了一个比较重要的知识了，css选择器的权重，可以将这些权重归纳为如下： ！important infinity行间样式 1,0,0,0id选择器 1,0,0class选择器&amp;属性选择器&amp;伪类选择器 1,0标签选择器&amp;伪元素选择器 1,通配符选择器 0 当然了，我们就可以得出结论，当多个选择器混合使用的时候，我们需要将选择器的权重相加，之后再看那个权重进行比较，谁高就听谁的。这里的1,0,0,0是256进制的，在部分IE浏览器中256个class选择器才会大于id选择器。这里稍微要注意一下。（并不是2进制或者10进制） 6、父子选择器1234567891011&lt;div&gt; &lt;em&gt; &lt;p class=&apos;demo&apos;&gt;12345&lt;/p&gt; &lt;/em&gt;&lt;/div&gt;div em p&#123;width:100px;height:100px; background-color:green;&#125; 在开发的时候需要写成这种多级关系，让结构等价清晰明了。 7、直接子元素选择器直接子元素选择器，真正的父子选择器。1234567891011&lt;div&gt; &lt;em&gt; &lt;p class=&apos;demo&apos;&gt;12345&lt;/p&gt; &lt;/em&gt;&lt;/div&gt;div &gt; em &gt; p&#123;width:100px;height:100px; background-color:green;&#125; 而且父子选择器和直接子元素选择器是可以混用的。但在这里如果有多个这种在一起的时候，比如：section div ui li a em { }。计算机找这些标签的时候是从右向左找的，一步一步的过滤。这样找的时间最短，速度最快。 8、并列选择器12345678&lt;div class=&apos;demo&apos;&gt;1&lt;/div&gt;&lt;p class=&apos;demo&apos;&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; // 此时若想单独让2变成红色，这时候就需要用到并列选择器p.demo&#123; width:100px; height:100px; background:red;&#125; 9、分组选择器1234567div,p,em&#123; width:100px; height:100px; background-color:green; &#125; 这样div、p、em标签里的东西就全部都变成绿色，宽高各100。 在这里这篇blog就先告一段落了，下一篇blog就开始讲继续为大家讲解css。谢谢大家！！！","categories":[{"name":"css","slug":"css","permalink":"http://moreluckily.com/categories/css/"}],"tags":[{"name":"-css","slug":"css","permalink":"http://moreluckily.com/tags/css/"}]},{"title":"html学习3","slug":"html学习3","date":"2018-09-20T16:16:31.000Z","updated":"2018-09-21T06:59:14.834Z","comments":true,"path":"2018/09/21/html学习3/","link":"","permalink":"http://moreluckily.com/2018/09/21/html学习3/","excerpt":"","text":"新的一天，每天都要元气满满哦。今天我将继续带着大家一起继续学习htnl中特别重要的一些标签的知识。 ol和li标签ol和li标签通常是一起出现的，是有序列表的意思，ol的全称就是order list，这2个标签能进行排序，例如：12345&lt;ol&gt; &lt;li&gt;第一点&lt;/li&gt; &lt;li&gt;第二点&lt;/li&gt; &lt;li&gt;第三点&lt;/li&gt;&lt;/ol&gt; 就会出现1.第一点2.第二点3.第三点，默认是用数字进行排序，当然也可以不用数字进行排序，例如：12345&lt;ol type=&quot;a&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;1&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;i&quot;&gt;&lt;/ol&gt;&lt;ol type=&quot;a&quot; reversed=&quot;reversed&quot;&gt;&lt;ol type=&quot;a&quot; start=&quot;2&quot;&gt; 第一行的意思就是用a,b,c等进行排序，当超过26个字母之后，就开始使用aa,ab,ac等等进行排序，type里也可以用A来进行排序，和a排序类似；第二行的意思就是用1,2,3等进行排序；第三行的意思就是用罗马数字进行排序，当然也可以用大写的罗马数字进行排序；第四行的意思就是用a,b,c等进行排序，但后面又加了一个属性reversed，reversed的中文意思是翻转,颠倒的。也就是反过来倒着排序；第五行的意思就是用a,b,c等进行排序，但后面又加了一个属性start，也就是从第2个值也就是b来进行排序。但要提的一点就是type里只能填5个值，也就是a,A,1,i,I这五个值。中特别重要的一些标签的知识。 ul和li标签*ul和li标签也是在一起出现的，ul的全称就是unorder list，是有序列表的意思。这个其实是用比较多的，ol反而基本上不怎么用。它的使用场景：大功能块，下面有很多功能子项 ，它们样式都一样，典型的例子就是网页的导航栏。即打个比方就是：ul相当于柜子，li相当于抽屉。li的全称是list item，ul也可以加type值来进行设置样式，属性值有三个，disc（实心圆 默认），square（方块），circle（空心圆）。 img标签*img标签的标准写法：&lt;img src=&#39;图片地址&#39; alt=&#39;文字&#39; title=&#39;图片内容&#39;&gt;img标签是用来显示图片的功能，img的全称就是image，就是图片，影像的意思，也就是将图片引入网页中。它是一个单标签，也可以将其写成一对标签的形式，即：&lt;img&gt;&lt;/img&gt;img标签中的src属性是图片的地址，这里有三种地址方式可以选择： 1、网络地址：就是网上的图片，网上的url,就是带http什么什么的。 2、相对路径，如果如果网页程序文件和图片文件是在同一文件夹下，这时候就可以写相对地址，相对路径就是一个大的范围。 3、绝对路径，如果网页文件和图片文件不在同一文件夹下，就需要使用绝对地址，绝对路径是一个特别绝对的地方，需要将路径写的特别清晰，位置要特别的清楚不能出错。 第二个属性就是alt属性，这是一个工业级别的属性，当我们网络比较差的时候，或者图片地址出错的时候，就会在图片位置显示出alt属性中的文字。其实这是一种容错手段，一级容错，将错误降到最低。也就是当图片不能正常显示的时候，文字就会被显示出来，这样用户体验更加好，尽管看不到图，但是至少知道图的内容是什么。这个也叫图片占位符。第三个属性就是title属性，这也是一个工业级的属性，当鼠标移动到图片位置的时候，就会在鼠标点处显示出title里的值。这个也叫图片提示符。 注释*html中注释的快捷键是“Ctrl加？”，具体的形式如下所示：&lt;!-- 注释内容 --&gt;注释能够找错，可以一个模块一个模块的注释，然后找到错误出在了哪个模块，然后再在这个模块里去寻找出错的位置。 a标签**a标签的写法如下所示：&lt;a href=&quot;http://www.baidu.com&quot;&gt; www.baidu.com&lt;/a&gt;a标签就是超文本引用，它是由anchor得来的，这个单词的意思是抛锚，锚。a标签的功能是：1、网页链接功能，即在href里写上一个地址，我在上面写了一个百度的地址，当点击这个地址的时候，网页就会自动跳转到该地。2、锚点功能，同样的在href处写一个id，当点击a标签的时候，会自动调到带有id的标签处，典型的例子就是我们常常看到的“一键置顶”的功能。3、打电话功能和发邮件，Tel属性可以填入一个电话号码。我们常常在美团外卖，饿了么等app中看到，他们都有一个给商家致电的功能，就是用这个写的，当点击a标签的时候，就会自动给Tel中的电话号码致电。发邮件和他类似。4、协议限定符，在恶意网站中，我们常常点击了一个东西，于是网页就自动跳出很多弹窗，而且退出不了，必须把浏览器关了。可以利用a标签这样写，其实就是里面写了一个死循环。 table标签table标签可以实现嵌套，能实现表格的功能。具体的写法如下图所示：1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; tr就是表格的行，td就是表格的列，table标签在以前是用来布局的，以前布局都用它，但是现在不用了，只需知道为什么不用它进行布局就ok。我们正常的程序是下载一行执行一行，并不会阻塞下面的代码，但是table必须是等待它里面的内容全部下载完才会进行渲染。这样的体验效果是极差的，所以不用table来进行布局。 form标签*form标签，能实现通信功能，也就是当前端与后端进行数据交换的时候，就会使用from表单进行数据的传输。form标签的写法是：&lt;form method=&quot;get/post&quot; action=&quot;&quot;&gt; action=&quot;http://www...&quot;&lt;/form&gt;这里面的属性就是：1、method:get或者post，发送数据的方式。2、action:目标接收地址，就是数据发送的地方。发送的信息要有信息的名和信息的值。 input标签*input标签是单标签：写法如下所示：&lt;input type=&quot;text password radio/checkbox sumbit&quot; name=&quot;&quot; value=&quot;&quot; value=&#39;默认值&#39; checked=&#39;chechked&#39;&gt;第一个属性type，可以通过type属性的值来显示不同类型的input。1、text，文本框，输入用户名之类的。 2、password，密码框输入密码。 3、radio，checkbox，单选框，多选框。 4、submit，提交数据。 在第三条radio和checkbox，当type为radio的时候，input作为单选框，这时候需要利用name属性，所有选项的name属性必须都相等，表示他们属于同一单选框，这样才可以实现单选功能。当type属性为checkbox的时候，就是作为多选框，这时候，各选项的name属性不一样。 还有我们可以改善用户体验，举个例子，当使用input调查性别的时候，只有两个选项，男女，这时候，我们可以设置一个默认选项，假如默认是男性，我们可以在男性的input里添加一个属性：checked=”checked”，表示，男性为默认选项。这样就可以减少用户操作，提升用户体验。就是每一个选项不用我们都去点，而只需要进行对默认的选项进行肯定或者是否定，肯定就不需要用户去操作了，这样就让用户的体验改善了。 标签的分类**html标签可以分为三类，第一类称之为块级元素，第二类称之为行级元素，第三类就是行级块元素。 1、块级元素：占满整行，可以改变宽高。“display=block”， 可以通过CSS样式设置宽高。典型的标签： div p ul ol li address form h1 - h6等等2、行级元素：不占满整行， 元素所占空间完全由内容所控制。不可以通过CSS样式设置宽高。“dispaly=inline”， 典型的标签： span a em strong select br3、行级块元素 “display=inline-block”，这种标签是既不属于行级元素，也不属于块级元素。根据自身内容大小决定其所占据的空间，可以通过CSS样式设置宽高。典型的标签：img input。 在这里html就告一段落了，下一篇blog就开始讲css了。谢谢大家！！！","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"html学习2","slug":"html学习2","date":"2018-09-19T15:58:27.000Z","updated":"2018-09-20T16:13:58.205Z","comments":true,"path":"2018/09/19/html学习2/","link":"","permalink":"http://moreluckily.com/2018/09/19/html学习2/","excerpt":"","text":"新的一天，每天都要元气满满哦。今天我将带着大家一起继续学习htnl标签的一些知识。 P标签p标签，也叫段落标签，它能使写在其里面的内容成段落展示。标准写法就是如下所示：&lt;p&gt;内容&lt;/p&gt;p标签的p就是paragraph的缩写，是html中比较常用的标签之一。 h1-h6标签h1-h6标签能呈现越来越小的趋势标题的功能，h1标签的字号最大，h6标签的字号最小，它们的特点就是就是独占一行，改变大小，加粗文字。它们的基本写法如下所示： 123&lt;h1&gt;1级标题&lt;/h1&gt;...&lt;h6&gt;6级标题&lt;/h6&gt; strong标签&lt;strong&gt;加粗文字&lt;/strong&gt;这个标签就是起到加粗的作用，但是在之前用的都是b标签，即：&lt;b&gt;加粗文字&lt;/b&gt;熟悉WORD软件的朋友可能对其不陌生，对的，可以在WORD中用来加粗文字，但现在strong标签更加语义化，让我们更能理解他的意义。 em标签&lt;em&gt;斜体&lt;/em&gt;这个标签就是起到使文字变成斜体的作用，在之前用的都是 i标签，即：&lt;i&gt;斜体&lt;/i&gt;和b标签一样，都是从WORD中引用过来的，但现在基本不会使用i标签了，基本都会使用em标签。 del标签&lt;del&gt;￥80元&lt;/del&gt;这个标签会在文字中间加一条横线，得到的效果图如下图所示：这个效果是不是在很多地方都见过呢？没错，在淘宝或者京东里见过许多次，但是根据开发根据开发标准，del标签是不能使用的，因为，这个可以利用css进行设置，因为直接对其样式进行了修改，而html主要负责的是页面的框架架，这个标签在使用的时候，那么css和html的功能有重合的部分，所以不能使用这个这个标签，也即是这个标签不重要，可以将其忽略。在这里也介绍几个不重要的标签，单标签br和hr。1&lt;br&gt;2&lt;hr&gt;3br标签是换行，hr标签是加一条横线的效果，都不经常使用。在这里还是强调一点，html只负责结构和框架，css才能负责样式，javascript负责行为。 特别重要的2个标签*&lt;div&gt;容器&lt;/div&gt;&lt;span&gt;容器&lt;/span&gt;这两个标签没有任何的作用，不像上面讲的那几个标签，可以出现一些效果，但是这两个标签最大的特点就是没有任何特点。举个例子，我们可以将其当做一个书桌中的一个抽屉，我们可以将这些抽屉进行交换，而里面的东西，随着这些抽屉一起移动。使这些功能更加结构化，结构合理，分布较好，可以当成容器来使用，而容器的作用就是结构化和集中化操作。 文字分隔符12345&lt;p&gt;aa&lt;/p&gt;&lt;p&gt;a a&lt;/p&gt;&lt;p&gt;a a&lt;/p&gt;&lt;p&gt;a&amp;nbsp;a&lt;/p&gt;&lt;p&gt;a&amp;nbsp;&amp;nbsp;&amp;nbsp;a&lt;/p&gt; 在浏览器中，默认将空格当成一个文字分隔符，但是不管空多少，它都只认为是一个文字分隔符。我们来看看效果：当我们需要较多的空时，就需要文字分隔符来帮忙了。还有就是当我们需要在浏览器中显示&lt;div&gt;时，我们发现我们不能在浏览器中显示出来，因为它是关键字，这个时候就需要“&lt;”和“&gt;”上场了，在html中，&gt;&amp;lt;就表示“&lt;”，它就是less than的缩写，也就是小于号。而:&gt;&amp;gt;就代表“&gt;”，它就是great than的缩写，也就是大于号的意思。 好了，今天的这篇 blog就到这里结束了，谢谢大家的观看。*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上！","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"html学习1","slug":"html学习1","date":"2018-09-19T13:21:28.000Z","updated":"2018-09-19T15:59:06.809Z","comments":true,"path":"2018/09/19/html学习1/","link":"","permalink":"http://moreluckily.com/2018/09/19/html学习1/","excerpt":"","text":"html是什么html css javaScript 并称WEB前端的三剑客，那它们具体的作用是什么呢？用比较专业的词汇说就是html负责结构，css负责样式，javaScript（缩写为js，以后都用缩写来对其进行介绍）负责行为。进行开发首先需要下载编程工具，在这里我推荐使用Sublime2或者Sublime3 或者Visual Studio Code（简称VS Code），在这里博主使用的是VS Code。html是WEB前端的基础，也是最简单的，html的全称是htperText markup language!!!中文翻译就是超文本链接语言，它是由一对一对的标签组成的。例如：&lt;html&gt; &lt;/html&gt;html标签就是根标签它的框架就是：1234&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这里面的head标签是给浏览器看的，就是这里面的内容是对浏览器进行一些定义什么的，而body标签是给用户看的，即这里面写的一些东西就是整个页面的框架。那我们现在就开始写代码，在head标签写以下代码：&lt;title&gt;百度一下&lt;/title&gt;然后点击保存（Ctrl+S），接下来点击鼠标右键，再然后点击Open In Default Browser选项（或者直接使用快捷键A/t+B），就会在自己电脑上默认的浏览器中打开一个网页（在这里我推荐使用Google Chrome 浏览器），但在这时我们会发现出现乱码的现象。这是因为外国的浏览器不能识别中文，这时我们就需要在 head标签里加一个另一个标签了，就是设置浏览器属性，让浏览器能够识别中文，需要加的标签是meta标签，这是一个单标签。&lt;meta charset=&quot;UTF-8&quot;&gt;charset代表了一定的属性，里面可以写比较多的东西，例如：可以在里面加gb2312，它代表的是国家标准，但其只能识别简体字，不能识别繁体字；在其基础上就有了gbk，它既能识别简体字也能识别繁体字；在之后就有了unicode，一般将它称为万国码，但utf-8是它的升级版本，于是我们在这里就使用utf-8了。&lt;html lang=&quot;en&quot;&gt;也就是language=”english”的缩写，这句话的意思也就是告诉搜索引擎爬虫，我们的网站是关于什么内容的。当然这里的en可以用”zh”和“de”等代替，”zh”就是zhongwen的缩写，”de”就是德语的缩写，还要在head标签里写的内容就是：&lt;meta name=&quot;keywords&quot; content=&quot;关键字&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;描述信息&quot;&gt;这些信息就是告诉搜索引擎爬虫我们写的浏览器是关于什么内容的，让搜索这些关键字的人能快速的找到我们浏览器并打开它。 我们可以直接在VS Code中输入html:5然后按下Tab键，就可以生成一些基本的信息内容了。就会出现以下的一些基本内容：1234567891011&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这些虽然可以直接生成，但我们需要知道他是怎么来的，不能不求甚解。 好了，今天的blog内容就是这些了，我明天就会向大家介绍html中常见的标签名称和作用。大家晚安，希望大家都不要活成自己讨厌的样子。good night,have a sweet dream.","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"WEB前端介绍","slug":"WEB前端介绍","date":"2018-09-19T12:51:01.000Z","updated":"2018-09-19T15:44:12.248Z","comments":true,"path":"2018/09/19/WEB前端介绍/","link":"","permalink":"http://moreluckily.com/2018/09/19/WEB前端介绍/","excerpt":"","text":"WEB前端介绍首先我们需要知道WEB前端技术能做什么？它能做的东西还是蛮多的，下面我就对其进行一些简单的介绍。 公司官网（在PC通过浏览器来访问公司网站） 移动端网页（在手机上来浏览公司信息、小游戏等） 移动端APP界面（例如：淘宝、去哪儿旅游、携程等） 微信小程序（微信推出的功能，随用随装，不占用手机空间）WEB前端需要掌握的一些技能，其核心要求掌握： 语言技术：JS基础和核心、HTML5、CSS3 框架技术：JQuery、ajax、Bootstrap、AngularJS, React, React Native, Cordova, Hadoop 通讯协议技术：HTTP协议、服务端开发技术, NodeJS 客户端技术：微信开发技术、JS、SDK开发、Web App开发技术下面的blog我将开始对其各个部分进行详细的介绍与教学，OK，这篇blog就先介绍到这里了。期待大家对我接下来blog的支持与喜爱，谢谢大家。","categories":[{"name":"html","slug":"html","permalink":"http://moreluckily.com/categories/html/"}],"tags":[{"name":"-html","slug":"html","permalink":"http://moreluckily.com/tags/html/"}]},{"title":"大学三年总结","slug":"大学三年总结","date":"2018-09-19T11:46:12.000Z","updated":"2018-09-19T13:18:38.539Z","comments":true,"path":"2018/09/19/大学三年总结/","link":"","permalink":"http://moreluckily.com/2018/09/19/大学三年总结/","excerpt":"","text":"三年的一些感受时光如白驹过隙，稍纵即逝，一晃大学三年就过去了。在这三年中，努力过，奋斗过，笑过，也哭过，成功过，失败过，喜悦过，悲伤过，徘徊过，疯狂过，失落过。在前几天，参加学校的保研面试，但是很难受的是，没有得到学校的保研名额。其中的情况有自己的一部分原因，也用一些学校老师的情况。在这里真的不想说什么了，同时自己确实是挺难过的，努力了三年，最后得到了这个结果无论是谁都会都会有一段低潮期，在失败之后呢？不禁要想自己的未来在哪里呢？找工作或者考研？我的学校并不是985也不是211学校，只是一个普通的一本院校。考上研究生之后呢？我一直在思考这个问题。毕竟大学的出身还是挺重要的，找工作是找本专业的工作还是跨专业找呢？前几天我跑了我们学校的宣讲会，我这个专业说白了就是自动化分出来的一个旁支，对口的工作特别少，要么就是工资太低了，而一些比较好进的国企工资也低，热门的国企又不好进，而且录取的时间特别晚，等它出结果黄花菜都凉了。同时我发现这些公司有一大半都是来自互联网公司，而像我这样的非计算机专业的学生想直接进入这些公司还是太难了。经过了几天的思考，我决定还是进入互联网公司，毕竟这些公司是不看你的出身的，只看你的想法和实力。回顾过去，自己仍然有不少缺点，如创新潜力还不够强，有时候不懂得坚持，但我会尽可能地在以后的学习和生活中着重提高这些方面的潜力，人的一生就是在不断地学习、实践中得到提高、完善的。 大四的计划时光已逝，良晨难在，获取超于失去，何乐而不为，憧憬，是因为新的梦想在开启斗士的豪情！保研失败并不是结束，只是为下一个阶段学习的开始打下基础。此刻，我将重新整装，确定新的目标，迎接下一个阶段的学习。未来之路就在眼前，遥远，需要不断求索。那么就让我们屏弃所有的恐惧，和我一齐上路，为我以后的学习和工作继续创造自己的辉煌。特别喜欢超级演说家刘媛媛的演讲，“人生那么短，我就选择做那种又盲目又热情的傻瓜。永远年轻；永远热泪盈眶；永远相信梦想；相信努力的意义；相信遗憾会比失败更可怕。因为不成功的人生，它只是不完美，但是它完整。”我觉得我应该振作起来，继续努力的开始去学习，去不断的让自己没有时间去思考为什么自己没有保上研，毕竟中国是个人情社会，别人可能没你优秀，但别人在选择老师的实验室选择的好呀。也确实自己还是挺倒霉的，参加的一些比较重要的比赛都没有取得好成绩。在这里还是特别感谢我宝哥，鼓励我激励我，上帝给你关了一道门，可能是想告诉你，孩子啊！我在为你留了一扇窗呢。接下来的日子里，我将会与WEB前端结缘，拿起曾经丢下的一项能在这个社会上立足的技能，为自己的未来再次奋斗杨帆起航。长风破浪会有时，直挂云帆济苍海 。自己肯定能在明年的春招中收获自己胜利的果实，到那时，必定春风得意马蹄疾，一日看尽长安花。","categories":[{"name":"总结","slug":"总结","permalink":"http://moreluckily.com/categories/总结/"}],"tags":[{"name":"-总结","slug":"总结","permalink":"http://moreluckily.com/tags/总结/"}]}]}